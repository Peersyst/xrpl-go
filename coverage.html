
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>address-codec: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Peersyst/xrpl-go/address-codec/address_codec.go (93.9%)</option>
				
				<option value="file1">github.com/Peersyst/xrpl-go/address-codec/base58.go (98.0%)</option>
				
				<option value="file2">github.com/Peersyst/xrpl-go/address-codec/base58check.go (94.7%)</option>
				
				<option value="file3">github.com/Peersyst/xrpl-go/binary-codec/definitions/definitions.go (92.1%)</option>
				
				<option value="file4">github.com/Peersyst/xrpl-go/binary-codec/definitions/field_instance.go (0.0%)</option>
				
				<option value="file5">github.com/Peersyst/xrpl-go/binary-codec/definitions/helpers.go (100.0%)</option>
				
				<option value="file6">github.com/Peersyst/xrpl-go/binary-codec/definitions/init.go (66.7%)</option>
				
				<option value="file7">github.com/Peersyst/xrpl-go/binary-codec/main.go (81.6%)</option>
				
				<option value="file8">github.com/Peersyst/xrpl-go/binary-codec/serdes/binary_parser.go (32.8%)</option>
				
				<option value="file9">github.com/Peersyst/xrpl-go/binary-codec/serdes/binary_serializer.go (46.7%)</option>
				
				<option value="file10">github.com/Peersyst/xrpl-go/binary-codec/serdes/field_id_codec.go (0.0%)</option>
				
				<option value="file11">github.com/Peersyst/xrpl-go/binary-codec/types/account_id.go (100.0%)</option>
				
				<option value="file12">github.com/Peersyst/xrpl-go/binary-codec/types/amount.go (54.6%)</option>
				
				<option value="file13">github.com/Peersyst/xrpl-go/binary-codec/types/blob.go (100.0%)</option>
				
				<option value="file14">github.com/Peersyst/xrpl-go/binary-codec/types/errors/json.go (100.0%)</option>
				
				<option value="file15">github.com/Peersyst/xrpl-go/binary-codec/types/hash.go (100.0%)</option>
				
				<option value="file16">github.com/Peersyst/xrpl-go/binary-codec/types/hash128.go (100.0%)</option>
				
				<option value="file17">github.com/Peersyst/xrpl-go/binary-codec/types/hash160.go (100.0%)</option>
				
				<option value="file18">github.com/Peersyst/xrpl-go/binary-codec/types/hash256.go (100.0%)</option>
				
				<option value="file19">github.com/Peersyst/xrpl-go/binary-codec/types/issue.go (100.0%)</option>
				
				<option value="file20">github.com/Peersyst/xrpl-go/binary-codec/types/pathset.go (55.2%)</option>
				
				<option value="file21">github.com/Peersyst/xrpl-go/binary-codec/types/serialized_type.go (50.0%)</option>
				
				<option value="file22">github.com/Peersyst/xrpl-go/binary-codec/types/st_array.go (83.9%)</option>
				
				<option value="file23">github.com/Peersyst/xrpl-go/binary-codec/types/st_object.go (80.0%)</option>
				
				<option value="file24">github.com/Peersyst/xrpl-go/binary-codec/types/uint16.go (81.2%)</option>
				
				<option value="file25">github.com/Peersyst/xrpl-go/binary-codec/types/uint32.go (77.8%)</option>
				
				<option value="file26">github.com/Peersyst/xrpl-go/binary-codec/types/uint64.go (59.3%)</option>
				
				<option value="file27">github.com/Peersyst/xrpl-go/binary-codec/types/uint8.go (61.1%)</option>
				
				<option value="file28">github.com/Peersyst/xrpl-go/binary-codec/types/vector256.go (31.6%)</option>
				
				<option value="file29">github.com/Peersyst/xrpl-go/binary-codec/types/xchain_bridge.go (100.0%)</option>
				
				<option value="file30">github.com/Peersyst/xrpl-go/keypairs/crypto.go (44.4%)</option>
				
				<option value="file31">github.com/Peersyst/xrpl-go/keypairs/keypairs.go (75.9%)</option>
				
				<option value="file32">github.com/Peersyst/xrpl-go/pkg/big-decimal/big_decimal.go (96.6%)</option>
				
				<option value="file33">github.com/Peersyst/xrpl-go/pkg/crypto/der.go (85.7%)</option>
				
				<option value="file34">github.com/Peersyst/xrpl-go/pkg/crypto/ed25519.go (78.6%)</option>
				
				<option value="file35">github.com/Peersyst/xrpl-go/pkg/crypto/secp256k1.go (90.3%)</option>
				
				<option value="file36">github.com/Peersyst/xrpl-go/pkg/crypto/sha512.go (100.0%)</option>
				
				<option value="file37">github.com/Peersyst/xrpl-go/pkg/crypto/types.go (0.0%)</option>
				
				<option value="file38">github.com/Peersyst/xrpl-go/pkg/map_utils/map_utils.go (100.0%)</option>
				
				<option value="file39">github.com/Peersyst/xrpl-go/pkg/random/main.go (80.0%)</option>
				
				<option value="file40">github.com/Peersyst/xrpl-go/pkg/typecheck/typecheck.go (100.0%)</option>
				
				<option value="file41">github.com/Peersyst/xrpl-go/xrpl/currency/native.go (100.0%)</option>
				
				<option value="file42">github.com/Peersyst/xrpl-go/xrpl/currency/non-standard.go (95.0%)</option>
				
				<option value="file43">github.com/Peersyst/xrpl-go/xrpl/hash/tx.go (85.7%)</option>
				
				<option value="file44">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/account_root.go (0.0%)</option>
				
				<option value="file45">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/amendments.go (0.0%)</option>
				
				<option value="file46">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/amm.go (100.0%)</option>
				
				<option value="file47">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/bridge.go (100.0%)</option>
				
				<option value="file48">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/check.go (0.0%)</option>
				
				<option value="file49">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/deposit_preauth.go (0.0%)</option>
				
				<option value="file50">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/did.go (100.0%)</option>
				
				<option value="file51">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/directory_node.go (0.0%)</option>
				
				<option value="file52">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/escrow.go (0.0%)</option>
				
				<option value="file53">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/fee_settings.go (0.0%)</option>
				
				<option value="file54">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/ledger_hashes.go (0.0%)</option>
				
				<option value="file55">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/ledger_object.go (0.0%)</option>
				
				<option value="file56">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/negative_unl.go (0.0%)</option>
				
				<option value="file57">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/nftoken_offer.go (72.7%)</option>
				
				<option value="file58">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/nftoken_page.go (0.0%)</option>
				
				<option value="file59">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/offer.go (73.3%)</option>
				
				<option value="file60">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/oracle.go (100.0%)</option>
				
				<option value="file61">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/pay_channel.go (0.0%)</option>
				
				<option value="file62">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/ripple_state.go (0.0%)</option>
				
				<option value="file63">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/signer_list.go (0.0%)</option>
				
				<option value="file64">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/ticket.go (0.0%)</option>
				
				<option value="file65">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/xchain_owned_claim_id.go (100.0%)</option>
				
				<option value="file66">github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types/xchain_owned_create_account_claim_id.go (100.0%)</option>
				
				<option value="file67">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_channels_request.go (71.4%)</option>
				
				<option value="file68">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_currencies_request.go (72.7%)</option>
				
				<option value="file69">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_info_request.go (66.7%)</option>
				
				<option value="file70">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_lines_request.go (66.7%)</option>
				
				<option value="file71">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_nfts_request.go (72.7%)</option>
				
				<option value="file72">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_objects_request.go (66.7%)</option>
				
				<option value="file73">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_offers_request.go (72.7%)</option>
				
				<option value="file74">github.com/Peersyst/xrpl-go/xrpl/queries/account/account_transactions_request.go (0.0%)</option>
				
				<option value="file75">github.com/Peersyst/xrpl-go/xrpl/queries/account/offer_result.go (81.2%)</option>
				
				<option value="file76">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/can_delete_request.go (75.0%)</option>
				
				<option value="file77">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/crawl_shards_request.go (0.0%)</option>
				
				<option value="file78">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/download_shard_request.go (0.0%)</option>
				
				<option value="file79">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/ledger_cleaner_request.go (0.0%)</option>
				
				<option value="file80">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/ledger_request_request.go (0.0%)</option>
				
				<option value="file81">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/ledger_request_response.go (77.8%)</option>
				
				<option value="file82">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/log_level_request.go (0.0%)</option>
				
				<option value="file83">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/logrotate_request.go (0.0%)</option>
				
				<option value="file84">github.com/Peersyst/xrpl-go/xrpl/queries/admin/data/node_to_shard_request.go (0.0%)</option>
				
				<option value="file85">github.com/Peersyst/xrpl-go/xrpl/queries/admin/key/validation_create_request.go (0.0%)</option>
				
				<option value="file86">github.com/Peersyst/xrpl-go/xrpl/queries/admin/key/wallet_propose_request.go (0.0%)</option>
				
				<option value="file87">github.com/Peersyst/xrpl-go/xrpl/queries/admin/peer/connect_request.go (0.0%)</option>
				
				<option value="file88">github.com/Peersyst/xrpl-go/xrpl/queries/admin/peer/peer_reservations_add_request.go (0.0%)</option>
				
				<option value="file89">github.com/Peersyst/xrpl-go/xrpl/queries/admin/peer/peer_reservations_del_request.go (0.0%)</option>
				
				<option value="file90">github.com/Peersyst/xrpl-go/xrpl/queries/admin/peer/peer_reservations_list_request.go (0.0%)</option>
				
				<option value="file91">github.com/Peersyst/xrpl-go/xrpl/queries/admin/peer/peers_request.go (0.0%)</option>
				
				<option value="file92">github.com/Peersyst/xrpl-go/xrpl/queries/admin/server/ledger_accept_request.go (0.0%)</option>
				
				<option value="file93">github.com/Peersyst/xrpl-go/xrpl/queries/admin/server/stop_request.go (0.0%)</option>
				
				<option value="file94">github.com/Peersyst/xrpl-go/xrpl/queries/admin/signing/sign_for_request.go (0.0%)</option>
				
				<option value="file95">github.com/Peersyst/xrpl-go/xrpl/queries/admin/signing/sign_request.go (0.0%)</option>
				
				<option value="file96">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/consensus_info_request.go (0.0%)</option>
				
				<option value="file97">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/feature_request.go (0.0%)</option>
				
				<option value="file98">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/fetch_info_request.go (0.0%)</option>
				
				<option value="file99">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/get_counts_request.go (0.0%)</option>
				
				<option value="file100">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/validator_info_request.go (0.0%)</option>
				
				<option value="file101">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/validator_list_sites_request.go (0.0%)</option>
				
				<option value="file102">github.com/Peersyst/xrpl-go/xrpl/queries/admin/status/validators_request.go (0.0%)</option>
				
				<option value="file103">github.com/Peersyst/xrpl-go/xrpl/queries/channel/channel_authorize_request.go (0.0%)</option>
				
				<option value="file104">github.com/Peersyst/xrpl-go/xrpl/queries/channel/channel_verify_request.go (0.0%)</option>
				
				<option value="file105">github.com/Peersyst/xrpl-go/xrpl/queries/clio/ledger_request.go (72.7%)</option>
				
				<option value="file106">github.com/Peersyst/xrpl-go/xrpl/queries/clio/nft_info_request.go (77.8%)</option>
				
				<option value="file107">github.com/Peersyst/xrpl-go/xrpl/queries/clio/server_info_request.go (0.0%)</option>
				
				<option value="file108">github.com/Peersyst/xrpl-go/xrpl/queries/common/ledger.go (73.7%)</option>
				
				<option value="file109">github.com/Peersyst/xrpl-go/xrpl/queries/ledger/ledger_closed_request.go (0.0%)</option>
				
				<option value="file110">github.com/Peersyst/xrpl-go/xrpl/queries/ledger/ledger_current_request.go (0.0%)</option>
				
				<option value="file111">github.com/Peersyst/xrpl-go/xrpl/queries/ledger/ledger_data_request.go (80.0%)</option>
				
				<option value="file112">github.com/Peersyst/xrpl-go/xrpl/queries/ledger/ledger_entry_request.go (70.6%)</option>
				
				<option value="file113">github.com/Peersyst/xrpl-go/xrpl/queries/ledger/ledger_request.go (66.7%)</option>
				
				<option value="file114">github.com/Peersyst/xrpl-go/xrpl/queries/path/book_offers_request.go (76.9%)</option>
				
				<option value="file115">github.com/Peersyst/xrpl-go/xrpl/queries/path/book_offers_response.go (80.0%)</option>
				
				<option value="file116">github.com/Peersyst/xrpl-go/xrpl/queries/path/deposit_authorized_request.go (76.9%)</option>
				
				<option value="file117">github.com/Peersyst/xrpl-go/xrpl/queries/path/nftoken_buy_offers_request.go (76.9%)</option>
				
				<option value="file118">github.com/Peersyst/xrpl-go/xrpl/queries/path/nftoken_offer.go (83.3%)</option>
				
				<option value="file119">github.com/Peersyst/xrpl-go/xrpl/queries/path/nftoken_sell_offers_request.go (76.9%)</option>
				
				<option value="file120">github.com/Peersyst/xrpl-go/xrpl/queries/path/path_find_request.go (76.5%)</option>
				
				<option value="file121">github.com/Peersyst/xrpl-go/xrpl/queries/path/path_find_response.go (80.8%)</option>
				
				<option value="file122">github.com/Peersyst/xrpl-go/xrpl/queries/path/ripple_path_find_request.go (77.3%)</option>
				
				<option value="file123">github.com/Peersyst/xrpl-go/xrpl/queries/server/fee_request.go (0.0%)</option>
				
				<option value="file124">github.com/Peersyst/xrpl-go/xrpl/queries/server/manifest_request.go (0.0%)</option>
				
				<option value="file125">github.com/Peersyst/xrpl-go/xrpl/queries/server/server_info_request.go (0.0%)</option>
				
				<option value="file126">github.com/Peersyst/xrpl-go/xrpl/queries/server/server_state_request.go (0.0%)</option>
				
				<option value="file127">github.com/Peersyst/xrpl-go/xrpl/queries/subscription/subscribe_request.go (0.0%)</option>
				
				<option value="file128">github.com/Peersyst/xrpl-go/xrpl/queries/subscription/unsubscribe_request.go (0.0%)</option>
				
				<option value="file129">github.com/Peersyst/xrpl-go/xrpl/queries/transactions/submit_multisigned_request.go (0.0%)</option>
				
				<option value="file130">github.com/Peersyst/xrpl-go/xrpl/queries/transactions/submit_request.go (0.0%)</option>
				
				<option value="file131">github.com/Peersyst/xrpl-go/xrpl/queries/transactions/transaction_entry_request.go (0.0%)</option>
				
				<option value="file132">github.com/Peersyst/xrpl-go/xrpl/queries/transactions/tx_request.go (0.0%)</option>
				
				<option value="file133">github.com/Peersyst/xrpl-go/xrpl/queries/utility/ping_request.go (0.0%)</option>
				
				<option value="file134">github.com/Peersyst/xrpl-go/xrpl/queries/utility/random_request.go (0.0%)</option>
				
				<option value="file135">github.com/Peersyst/xrpl-go/xrpl/rpc/client.go (83.1%)</option>
				
				<option value="file136">github.com/Peersyst/xrpl-go/xrpl/rpc/config.go (100.0%)</option>
				
<<<<<<< HEAD
				<option value="file137">github.com/Peersyst/xrpl-go/xrpl/rpc/queries.go (0.0%)</option>
				
				<option value="file138">github.com/Peersyst/xrpl-go/xrpl/rpc/response.go (85.7%)</option>
				
				<option value="file139">github.com/Peersyst/xrpl-go/xrpl/transaction/account_delete.go (0.0%)</option>
				
				<option value="file140">github.com/Peersyst/xrpl-go/xrpl/transaction/account_set.go (53.0%)</option>
				
				<option value="file141">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_bid.go (100.0%)</option>
				
				<option value="file142">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_create.go (85.7%)</option>
				
				<option value="file143">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_deposit.go (0.0%)</option>
				
				<option value="file144">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_vote.go (0.0%)</option>
				
				<option value="file145">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_withdraw.go (0.0%)</option>
				
				<option value="file146">github.com/Peersyst/xrpl-go/xrpl/transaction/check_cancel.go (0.0%)</option>
				
				<option value="file147">github.com/Peersyst/xrpl-go/xrpl/transaction/check_cash.go (72.2%)</option>
				
				<option value="file148">github.com/Peersyst/xrpl-go/xrpl/transaction/check_create.go (66.7%)</option>
				
				<option value="file149">github.com/Peersyst/xrpl-go/xrpl/transaction/clawback.go (85.7%)</option>
				
				<option value="file150">github.com/Peersyst/xrpl-go/xrpl/transaction/deposit_preauth.go (0.0%)</option>
				
				<option value="file151">github.com/Peersyst/xrpl-go/xrpl/transaction/escrow_cancel.go (0.0%)</option>
				
				<option value="file152">github.com/Peersyst/xrpl-go/xrpl/transaction/escrow_create.go (0.0%)</option>
				
				<option value="file153">github.com/Peersyst/xrpl-go/xrpl/transaction/escrow_finish.go (0.0%)</option>
				
				<option value="file154">github.com/Peersyst/xrpl-go/xrpl/transaction/flags.go (100.0%)</option>
				
				<option value="file155">github.com/Peersyst/xrpl-go/xrpl/transaction/flat_tx.go (0.0%)</option>
				
				<option value="file156">github.com/Peersyst/xrpl-go/xrpl/transaction/memo.go (92.3%)</option>
				
				<option value="file157">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_accept_offer.go (66.7%)</option>
				
				<option value="file158">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_burn.go (0.0%)</option>
				
				<option value="file159">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_cancel_offer.go (0.0%)</option>
				
				<option value="file160">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_create_offer.go (66.7%)</option>
				
				<option value="file161">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_mint.go (0.0%)</option>
				
				<option value="file162">github.com/Peersyst/xrpl-go/xrpl/transaction/offer_cancel.go (0.0%)</option>
				
				<option value="file163">github.com/Peersyst/xrpl-go/xrpl/transaction/offer_create.go (72.2%)</option>
				
				<option value="file164">github.com/Peersyst/xrpl-go/xrpl/transaction/path_step.go (100.0%)</option>
				
				<option value="file165">github.com/Peersyst/xrpl-go/xrpl/transaction/payment.go (79.8%)</option>
				
				<option value="file166">github.com/Peersyst/xrpl-go/xrpl/transaction/payment_channel_claim.go (12.5%)</option>
				
				<option value="file167">github.com/Peersyst/xrpl-go/xrpl/transaction/payment_channel_create.go (0.0%)</option>
				
				<option value="file168">github.com/Peersyst/xrpl-go/xrpl/transaction/payment_channel_fund.go (0.0%)</option>
				
				<option value="file169">github.com/Peersyst/xrpl-go/xrpl/transaction/set_regular_key.go (0.0%)</option>
				
				<option value="file170">github.com/Peersyst/xrpl-go/xrpl/transaction/signer.go (100.0%)</option>
				
				<option value="file171">github.com/Peersyst/xrpl-go/xrpl/transaction/signer_list_set.go (0.0%)</option>
				
				<option value="file172">github.com/Peersyst/xrpl-go/xrpl/transaction/ticket_create.go (83.3%)</option>
				
				<option value="file173">github.com/Peersyst/xrpl-go/xrpl/transaction/transaction_metadata.go (0.0%)</option>
				
				<option value="file174">github.com/Peersyst/xrpl-go/xrpl/transaction/trust_set.go (73.0%)</option>
				
				<option value="file175">github.com/Peersyst/xrpl-go/xrpl/transaction/tx.go (83.1%)</option>
				
				<option value="file176">github.com/Peersyst/xrpl-go/xrpl/transaction/tx_type.go (100.0%)</option>
				
				<option value="file177">github.com/Peersyst/xrpl-go/xrpl/transaction/types/address.go (100.0%)</option>
				
				<option value="file178">github.com/Peersyst/xrpl-go/xrpl/transaction/types/currency_amount.go (84.6%)</option>
				
				<option value="file179">github.com/Peersyst/xrpl-go/xrpl/transaction/types/hash128.go (100.0%)</option>
				
				<option value="file180">github.com/Peersyst/xrpl-go/xrpl/transaction/types/hash256.go (100.0%)</option>
				
				<option value="file181">github.com/Peersyst/xrpl-go/xrpl/transaction/validations_commons.go (81.0%)</option>
				
				<option value="file182">github.com/Peersyst/xrpl-go/xrpl/transaction/validations_xrpl_objects.go (100.0%)</option>
				
				<option value="file183">github.com/Peersyst/xrpl-go/xrpl/wallet.go (68.6%)</option>
				
				<option value="file184">github.com/Peersyst/xrpl-go/xrpl/websocket/client.go (48.8%)</option>
				
				<option value="file185">github.com/Peersyst/xrpl-go/xrpl/websocket/config.go (0.0%)</option>
				
				<option value="file186">github.com/Peersyst/xrpl-go/xrpl/websocket/queries.go (87.2%)</option>
				
				<option value="file187">github.com/Peersyst/xrpl-go/xrpl/websocket/response.go (75.0%)</option>
=======
				<option value="file137">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_create.go (100.0%)</option>
				
				<option value="file138">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_delete.go (100.0%)</option>
				
				<option value="file139">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_deposit.go (100.0%)</option>
				
				<option value="file140">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_vote.go (100.0%)</option>
				
				<option value="file141">github.com/Peersyst/xrpl-go/xrpl/transaction/amm_withdraw.go (100.0%)</option>
				
				<option value="file142">github.com/Peersyst/xrpl-go/xrpl/transaction/check_cancel.go (0.0%)</option>
				
				<option value="file143">github.com/Peersyst/xrpl-go/xrpl/transaction/check_cash.go (72.2%)</option>
				
				<option value="file144">github.com/Peersyst/xrpl-go/xrpl/transaction/check_create.go (66.7%)</option>
				
				<option value="file145">github.com/Peersyst/xrpl-go/xrpl/transaction/clawback.go (85.7%)</option>
				
				<option value="file146">github.com/Peersyst/xrpl-go/xrpl/transaction/deposit_preauth.go (0.0%)</option>
				
				<option value="file147">github.com/Peersyst/xrpl-go/xrpl/transaction/escrow_cancel.go (0.0%)</option>
				
				<option value="file148">github.com/Peersyst/xrpl-go/xrpl/transaction/escrow_create.go (0.0%)</option>
				
				<option value="file149">github.com/Peersyst/xrpl-go/xrpl/transaction/escrow_finish.go (0.0%)</option>
				
				<option value="file150">github.com/Peersyst/xrpl-go/xrpl/transaction/flags.go (100.0%)</option>
				
				<option value="file151">github.com/Peersyst/xrpl-go/xrpl/transaction/flat_tx.go (0.0%)</option>
				
				<option value="file152">github.com/Peersyst/xrpl-go/xrpl/transaction/memo.go (92.3%)</option>
				
				<option value="file153">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_accept_offer.go (66.7%)</option>
				
				<option value="file154">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_burn.go (0.0%)</option>
				
				<option value="file155">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_cancel_offer.go (0.0%)</option>
				
				<option value="file156">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_create_offer.go (66.7%)</option>
				
				<option value="file157">github.com/Peersyst/xrpl-go/xrpl/transaction/nftoken_mint.go (0.0%)</option>
				
				<option value="file158">github.com/Peersyst/xrpl-go/xrpl/transaction/offer_cancel.go (100.0%)</option>
				
				<option value="file159">github.com/Peersyst/xrpl-go/xrpl/transaction/offer_create.go (100.0%)</option>
				
				<option value="file160">github.com/Peersyst/xrpl-go/xrpl/transaction/path_step.go (100.0%)</option>
				
				<option value="file161">github.com/Peersyst/xrpl-go/xrpl/transaction/payment.go (79.8%)</option>
				
				<option value="file162">github.com/Peersyst/xrpl-go/xrpl/transaction/payment_channel_claim.go (12.5%)</option>
				
				<option value="file163">github.com/Peersyst/xrpl-go/xrpl/transaction/payment_channel_create.go (0.0%)</option>
				
				<option value="file164">github.com/Peersyst/xrpl-go/xrpl/transaction/payment_channel_fund.go (0.0%)</option>
				
				<option value="file165">github.com/Peersyst/xrpl-go/xrpl/transaction/set_regular_key.go (0.0%)</option>
				
				<option value="file166">github.com/Peersyst/xrpl-go/xrpl/transaction/signer.go (100.0%)</option>
				
				<option value="file167">github.com/Peersyst/xrpl-go/xrpl/transaction/signer_list_set.go (0.0%)</option>
				
				<option value="file168">github.com/Peersyst/xrpl-go/xrpl/transaction/ticket_create.go (83.3%)</option>
				
				<option value="file169">github.com/Peersyst/xrpl-go/xrpl/transaction/transaction_metadata.go (0.0%)</option>
				
				<option value="file170">github.com/Peersyst/xrpl-go/xrpl/transaction/trust_set.go (73.0%)</option>
				
				<option value="file171">github.com/Peersyst/xrpl-go/xrpl/transaction/tx.go (78.7%)</option>
				
				<option value="file172">github.com/Peersyst/xrpl-go/xrpl/transaction/tx_type.go (100.0%)</option>
				
				<option value="file173">github.com/Peersyst/xrpl-go/xrpl/transaction/types/address.go (0.0%)</option>
				
				<option value="file174">github.com/Peersyst/xrpl-go/xrpl/transaction/types/currency_amount.go (2.5%)</option>
				
				<option value="file175">github.com/Peersyst/xrpl-go/xrpl/transaction/types/hash128.go (0.0%)</option>
				
				<option value="file176">github.com/Peersyst/xrpl-go/xrpl/transaction/types/hash256.go (0.0%)</option>
				
				<option value="file177">github.com/Peersyst/xrpl-go/xrpl/transaction/validations_commons.go (81.0%)</option>
				
				<option value="file178">github.com/Peersyst/xrpl-go/xrpl/transaction/validations_xrpl_objects.go (100.0%)</option>
				
				<option value="file179">github.com/Peersyst/xrpl-go/xrpl/wallet.go (68.6%)</option>
				
				<option value="file180">github.com/Peersyst/xrpl-go/xrpl/websocket/client.go (48.8%)</option>
				
				<option value="file181">github.com/Peersyst/xrpl-go/xrpl/websocket/config.go (0.0%)</option>
				
				<option value="file182">github.com/Peersyst/xrpl-go/xrpl/websocket/queries.go (87.2%)</option>
				
				<option value="file183">github.com/Peersyst/xrpl-go/xrpl/websocket/response.go (75.0%)</option>
				
				<option value="file184">github.com/Peersyst/xrpl-go/xrpl/websocket/testutil/mock-webserver.go (81.2%)</option>
>>>>>>> v1.x.x
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package addresscodec

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"

        "github.com/Peersyst/xrpl-go/pkg/crypto"
        //nolint
        "golang.org/x/crypto/ripemd160"
)

const (
        // Lengths in bytes
        AccountAddressLength   = 20
        AccountPublicKeyLength = 33
        FamilySeedLength       = 16
        NodePublicKeyLength    = 33

        // Account/classic address prefix - value is 0
        AccountAddressPrefix = 0x00
        // Account public key prefix - value is 35
        AccountPublicKeyPrefix = 0x23
        // Family seed prefix - value is 33
        FamilySeedPrefix = 0x21
        // Node/validation public key prefix - value is 28
        NodePublicKeyPrefix = 0x1C
)

type EncodeLengthError struct {
        Instance string
        Input    int
        Expected int
}

func (e *EncodeLengthError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("`%v` length should be %v not %v", e.Instance, e.Expected, e.Input)
}</span>

type InvalidClassicAddressError struct {
        Input string
}

func (e *InvalidClassicAddressError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("`%v` is an invalid classic address", e.Input)
}</span>

// Returns the base58 encoding of byte slice, with the given type prefix, whilst ensuring that the byte slice is the expected length.
func Encode(b []byte, typePrefix []byte, expectedLength int) string <span class="cov8" title="1">{

        if len(b) != expectedLength </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return Base58CheckEncode(b, typePrefix...)</span>
}

// Returns the byte slice decoding of the base58-encoded string and prefix.
func Decode(b58string string, typePrefix []byte) ([]byte, error) <span class="cov8" title="1">{

        prefixLength := len(typePrefix)

        if !bytes.Equal(DecodeBase58(b58string)[:prefixLength], typePrefix) </span><span class="cov8" title="1">{
                return nil, errors.New("b58string prefix and typeprefix not equal")
        }</span>

        <span class="cov8" title="1">result, err := Base58CheckDecode(b58string)
        result = result[prefixLength:]

        return result, err</span>
}

// Returns the classic address from public key hex string.
func EncodeClassicAddressFromPublicKeyHex(pubkeyhex string) (string, error) <span class="cov8" title="1">{

        pubkey, err := hex.DecodeString(pubkeyhex)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if len(pubkey) == AccountPublicKeyLength-1 </span><span class="cov8" title="1">{
                pubkey = append([]byte{crypto.ED25519().Prefix()}, pubkey...)
        }</span> else<span class="cov8" title="1"> if len(pubkey) != AccountPublicKeyLength </span><span class="cov8" title="1">{
                return "", &amp;EncodeLengthError{Instance: "PublicKey", Expected: AccountPublicKeyLength, Input: len(pubkey)}
        }</span>

        <span class="cov8" title="1">accountID := Sha256RipeMD160(pubkey)

        if len(accountID) != AccountAddressLength </span><span class="cov0" title="0">{
                return "", &amp;EncodeLengthError{Instance: "AccountID", Expected: AccountAddressLength, Input: len(accountID)}
        }</span>

        <span class="cov8" title="1">address := Encode(accountID, []byte{AccountAddressPrefix}, AccountAddressLength)

        if !IsValidClassicAddress(address) </span><span class="cov0" title="0">{
                return "", &amp;InvalidClassicAddressError{Input: address}
        }</span>

        <span class="cov8" title="1">return address, nil</span>
}

// Returns the decoded 'accountID' byte slice of the classic address.
func DecodeClassicAddressToAccountID(cAddress string) (typePrefix, accountID []byte, err error) <span class="cov8" title="1">{

        if len(DecodeBase58(cAddress)) != 25 </span><span class="cov8" title="1">{
                return nil, nil, &amp;InvalidClassicAddressError{Input: cAddress}
        }</span>

        <span class="cov8" title="1">return DecodeBase58(cAddress)[:1], DecodeBase58(cAddress)[1:21], nil</span>

}

func IsValidClassicAddress(cAddress string) bool <span class="cov8" title="1">{
        _, _, c := DecodeClassicAddressToAccountID(cAddress)

        return c == nil
}</span>

// Returns a base58 encoding of a seed.
func EncodeSeed(entropy []byte, encodingType CryptoImplementation) (string, error) <span class="cov8" title="1">{

        if len(entropy) != FamilySeedLength </span><span class="cov8" title="1">{
                return "", &amp;EncodeLengthError{Instance: "Entropy", Input: len(entropy), Expected: FamilySeedLength}
        }</span>

        <span class="cov8" title="1">if encodingType == crypto.ED25519() </span><span class="cov8" title="1">{
                prefix := []byte{0x01, 0xe1, 0x4b}
                return Encode(entropy, prefix, FamilySeedLength), nil
        }</span> else<span class="cov8" title="1"> if secp256k1 := crypto.SECP256K1(); encodingType == secp256k1 </span><span class="cov8" title="1">{
                prefix := []byte{secp256k1.FamilySeedPrefix()}
                return Encode(entropy, prefix, FamilySeedLength), nil
        }</span> else<span class="cov8" title="1"> {
                return "", errors.New("encoding type must be `ed25519` or `secp256k1`")
        }</span>

}

// Returns decoded seed and its algorithm.
func DecodeSeed(seed string) ([]byte, CryptoImplementation, error) <span class="cov8" title="1">{

        // decoded := DecodeBase58(seed)
        decoded, err := Base58CheckDecode(seed)

        if err != nil </span><span class="cov8" title="1">{
                return nil, crypto.CryptoAlgorithm{}, errors.New("invalid seed; could not determine encoding algorithm")
        }</span>

        <span class="cov8" title="1">if bytes.Equal(decoded[:3], []byte{0x01, 0xe1, 0x4b}) </span><span class="cov8" title="1">{
                return decoded[3:], crypto.ED25519(), nil
        }</span> else<span class="cov8" title="1"> {
                return decoded[1:], crypto.SECP256K1(), nil
        }</span>

}

// Returns byte slice of a double hashed given byte slice.
// The given byte slice is SHA256 hashed, then the result is RIPEMD160 hashed.
func Sha256RipeMD160(b []byte) []byte <span class="cov8" title="1">{
        sha256 := sha256.New()
        sha256.Write(b)

        ripemd160 := ripemd160.New()
        ripemd160.Write(sha256.Sum(nil))

        return ripemd160.Sum(nil)
}</span>

// Returns the node public key encoding of the byte slice as a base58 string.
func EncodeNodePublicKey(b []byte) (string, error) <span class="cov8" title="1">{

        if len(b) != NodePublicKeyLength </span><span class="cov8" title="1">{
                return "", &amp;EncodeLengthError{Instance: "NodePublicKey", Expected: NodePublicKeyLength, Input: len(b)}
        }</span>

        <span class="cov8" title="1">npk := Base58CheckEncode(b, NodePublicKeyPrefix)

        return npk, nil</span>
}

// Returns the decoded node public key encoding as a byte slice from a base58 string.
func DecodeNodePublicKey(key string) ([]byte, error) <span class="cov8" title="1">{

        decodedNodeKey, err := Decode(key, []byte{NodePublicKeyPrefix})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return decodedNodeKey, nil</span>
}

// Returns the account public key encoding of the byte slice as a base58 string.
func EncodeAccountPublicKey(b []byte) (string, error) <span class="cov8" title="1">{

        if len(b) != AccountPublicKeyLength </span><span class="cov8" title="1">{
                return "", &amp;EncodeLengthError{Instance: "AccountPublicKey", Expected: AccountPublicKeyLength, Input: len(b)}
        }</span>

        <span class="cov8" title="1">apk := Base58CheckEncode(b, AccountPublicKeyPrefix)

        return apk, nil</span>
}

// Returns the decoded account public key encoding as a byte slice from a base58 string.
func DecodeAccountPublicKey(key string) ([]byte, error) <span class="cov8" title="1">{

        decodedAccountKey, err := Decode(key, []byte{AccountPublicKeyPrefix})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return decodedAccountKey, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package addresscodec

import (
        "math/big"
)

var bigRadix = [...]*big.Int{
        big.NewInt(0),
        big.NewInt(58),
        big.NewInt(58 * 58),
        big.NewInt(58 * 58 * 58),
        big.NewInt(58 * 58 * 58 * 58),
        big.NewInt(58 * 58 * 58 * 58 * 58),
        big.NewInt(58 * 58 * 58 * 58 * 58 * 58),
        big.NewInt(58 * 58 * 58 * 58 * 58 * 58 * 58),
        big.NewInt(58 * 58 * 58 * 58 * 58 * 58 * 58 * 58),
        big.NewInt(58 * 58 * 58 * 58 * 58 * 58 * 58 * 58 * 58),
        bigRadix10,
}

var bigRadix10 = big.NewInt(58 * 58 * 58 * 58 * 58 * 58 * 58 * 58 * 58 * 58)

// Encodes a byte slice to a base58 string encoded with the XRP alphabet.
func EncodeBase58(b []byte) string <span class="cov8" title="1">{

        x := new(big.Int)
        x.SetBytes(b)

        // Maximum length of output is log58(2^(8*len(b))) == len(b) * 8 / log(58)
        maxlen := int(float64(len(b))*1.365658237309761) + 1
        answer := make([]byte, 0, maxlen)
        mod := new(big.Int)

        for x.Sign() &gt; 0 </span><span class="cov8" title="1">{
                // Calculating with big.Int is slow for each iteration.
                //    x, mod = x / 58, x % 58
                //
                // Instead we can try to do as much calculations on int64.
                //    x, mod = x / 58^10, x % 58^10
                //
                // Which will give us mod, which is 10 digit base58 number.
                // We'll loop that 10 times to convert to the answer.

                x.DivMod(x, bigRadix10, mod)

                if x.Sign() == 0 </span><span class="cov8" title="1">{
                        // When x = 0, we need to ensure we don't add any extra zeros.
                        m := mod.Int64()
                        for m &gt; 0 </span><span class="cov8" title="1">{
                                answer = append(answer, xrpAlphabet[m%58])
                                m /= 58
                        }</span>
                } else<span class="cov8" title="1"> {
                        m := mod.Int64()
                        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                                answer = append(answer, xrpAlphabet[m%58])
                                m /= 58
                        }</span>
                }
        }
        // leading zero bytes
        <span class="cov8" title="1">for _, i := range b </span><span class="cov8" title="1">{
                if i != 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">answer = append(answer, alphabetIdx0)</span>
        }

        // reverse
        <span class="cov8" title="1">alen := len(answer)
        for i := 0; i &lt; alen/2; i++ </span><span class="cov8" title="1">{
                answer[i], answer[alen-1-i] = answer[alen-1-i], answer[i]
        }</span>

        <span class="cov8" title="1">return string(answer)</span>

}

// Decodes a modified base58 string to a byte slice.
func DecodeBase58(b string) []byte <span class="cov8" title="1">{
        answer := big.NewInt(0)
        scratch := new(big.Int)

        // Calculating with big.Int is slow for each iteration.
        //    x += b58[b[i]] * j
        //    j *= 58
        //
        // Instead we can try to do as much calculations on int64.
        // We can represent a 10 digit base58 number using an int64.
        //
        // Hence we'll try to convert 10, base58 digits at a time.
        // The rough idea is to calculate `t`, such that:
        //
        //   t := b58[b[i+9]] * 58^9 ... + b58[b[i+1]] * 58^1 + b58[b[i]] * 58^0
        //   x *= 58^10
        //   x += t
        //
        // Of course, in addition, we'll need to handle boundary condition when `b` is not multiple of 58^10.
        // In that case we'll use the bigRadix[n] lookup for the appropriate power.

        for t := b; len(t) &gt; 0; </span><span class="cov8" title="1">{
                n := len(t)
                if n &gt; 10 </span><span class="cov8" title="1">{
                        n = 10
                }</span>

                <span class="cov8" title="1">total := uint64(0)
                for _, v := range t[:n] </span><span class="cov8" title="1">{
                        tmp := b58[v]
                        if tmp == 255 </span><span class="cov0" title="0">{
                                return []byte("")
                        }</span>
                        <span class="cov8" title="1">total = total*58 + uint64(tmp)</span>
                }

                <span class="cov8" title="1">answer.Mul(answer, bigRadix[n])
                scratch.SetUint64(total)
                answer.Add(answer, scratch)

                t = t[n:]</span>
        }

        <span class="cov8" title="1">tmpval := answer.Bytes()

        var numZeros int
        for numZeros = 0; numZeros &lt; len(b); numZeros++ </span><span class="cov8" title="1">{
                if b[numZeros] != alphabetIdx0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">flen := numZeros + len(tmpval)
        val := make([]byte, flen)
        copy(val[numZeros:], tmpval)

        return val</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package addresscodec

import (
        "crypto/sha256"
        "errors"
)

// ErrChecksum indicates that the checksum of a check-encoded string does not verify against
// the checksum.
// ErrInvalidFormat indicates that the check-encoded string has an invalid format.
var (
        ErrChecksum      = errors.New("checksum error")
        ErrInvalidFormat = errors.New("invalid format: version and/or checksum bytes missing")
)

// checksum: first four bytes of sha256^2
func checksum(input []byte) (cksum [4]byte) <span class="cov8" title="1">{
        h := sha256.Sum256(input)
        h2 := sha256.Sum256(h[:])
        copy(cksum[:], h2[:4])
        return cksum
}</span>

// CheckEncode prepends a version byte, appends a four byte checksum and returns
// a base58 encoding of the byte slice.
func Base58CheckEncode(input []byte, prefix ...byte) string <span class="cov8" title="1">{
        b := make([]byte, 0, 1+len(input)+4)
        b = append(b, prefix...)
        b = append(b, input...)

        cksum := checksum(b)
        b = append(b, cksum[:]...)
        return EncodeBase58(b)
}</span>

// CheckDecode decodes a string that was encoded with CheckEncode and verifies the checksum.
func Base58CheckDecode(input string) (result []byte, err error) <span class="cov8" title="1">{
        decoded := DecodeBase58(input)
        if len(decoded) &lt; 5 </span><span class="cov8" title="1">{
                return nil, ErrInvalidFormat
        }</span>

        <span class="cov8" title="1">var cksum [4]byte
        copy(cksum[:], decoded[len(decoded)-4:])
        if checksum(decoded[:len(decoded)-4]) != cksum </span><span class="cov0" title="0">{
                return nil, ErrChecksum
        }</span>

        <span class="cov8" title="1">result = decoded[:len(decoded)-4]
        return</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package definitions

import (
        _ "embed"
        "errors"
        "fmt"

        "github.com/ugorji/go/codec"
)

var definitions *Definitions

//go:embed definitions.json
var docBytes []byte

func Get() *Definitions <span class="cov0" title="0">{
        return definitions
}</span>

type NotFoundError struct {
        Instance string
        Input    string
}

func (e *NotFoundError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v %v not found", e.Instance, e.Input)
}</span>

type NotFoundErrorInt struct {
        Instance string
        Input    int32
}

func (e *NotFoundErrorInt) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v %v not found", e.Instance, e.Input)
}</span>

type NotFoundErrorFieldHeader struct {
        Instance string
        Input    FieldHeader
}

func (e *NotFoundErrorFieldHeader) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v %v not found", e.Instance, e.Input)
}</span>

type Definitions struct {
        Types              map[string]int32
        LedgerEntryTypes   map[string]int32
        Fields             fieldInstanceMap
        TransactionResults map[string]int32
        TransactionTypes   map[string]int32
        FieldIdNameMap     map[FieldHeader]string
}
type definitionsDoc struct {
        Types              map[string]int32 `json:"TYPES"`
        LedgerEntryTypes   map[string]int32 `json:"LEDGER_ENTRY_TYPES"`
        Fields             fieldInstanceMap `json:"FIELDS"`
        TransactionResults map[string]int32 `json:"TRANSACTION_RESULTS"`
        TransactionTypes   map[string]int32 `json:"TRANSACTION_TYPES"`
}

type fieldInstanceMap map[string]*FieldInstance

func (fi *fieldInstanceMap) CodecEncodeSelf(e *codec.Encoder) {<span class="cov0" title="0">}</span>

func (fi *fieldInstanceMap) CodecDecodeSelf(d *codec.Decoder) <span class="cov8" title="1">{
        var x [][]interface{}
        d.MustDecode(&amp;x)
        y := convertToFieldInstanceMap(x)
        *fi = y
}</span>

// Loads JSON from the definitions file and converts it to a preferred format.
// The definitions file contains information required for the XRP Ledger's
// canonical binary serialization format:
// `Serialization &lt;https://xrpl.org/serialization.html&gt;`_
func loadDefinitions() error <span class="cov8" title="1">{

        var jh codec.JsonHandle

        jh.MapKeyAsString = true
        jh.SignedInteger = true

        dec := codec.NewDecoderBytes(docBytes, &amp;jh)
        var data definitionsDoc
        err := dec.Decode(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">definitions = &amp;Definitions{
                Types:              data.Types,
                Fields:             data.Fields,
                LedgerEntryTypes:   data.LedgerEntryTypes,
                TransactionResults: data.TransactionResults,
                TransactionTypes:   data.TransactionTypes,
        }

        addFieldHeadersAndOrdinals()
        createFieldIdNameMap()

        return nil</span>
}

func convertToFieldInstanceMap(m [][]interface{}) map[string]*FieldInstance <span class="cov8" title="1">{
        nm := make(map[string]*FieldInstance, len(m))

        for _, j := range m </span><span class="cov8" title="1">{
                k := j[0].(string)
                fi, _ := castFieldInfo(j[1])
                nm[k] = &amp;FieldInstance{
                        FieldName: k,
                        fieldInfo: &amp;fi,
                        Ordinal:   fi.Nth,
                }
        }</span>
        <span class="cov8" title="1">return nm</span>
}

func castFieldInfo(v interface{}) (fieldInfo, error) <span class="cov8" title="1">{
        if fi, ok := v.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                return fieldInfo{
                        Nth:            int32(fi["nth"].(int64)),
                        IsVLEncoded:    fi["isVLEncoded"].(bool),
                        IsSerialized:   fi["isSerialized"].(bool),
                        IsSigningField: fi["isSigningField"].(bool),
                        Type:           fi["type"].(string),
                }, nil
        }</span>
        <span class="cov0" title="0">return fieldInfo{}, errors.New("unable to cast to field info")</span>
}

func addFieldHeadersAndOrdinals() <span class="cov8" title="1">{
        for k := range definitions.Fields </span><span class="cov8" title="1">{
                t, _ := definitions.GetTypeCodeByTypeName(definitions.Fields[k].Type)

                if fi, ok := definitions.Fields[k]; ok </span><span class="cov8" title="1">{
                        fi.FieldHeader = &amp;FieldHeader{
                                TypeCode:  t,
                                FieldCode: definitions.Fields[k].Nth,
                        }
                        fi.Ordinal = (t&lt;&lt;16 | definitions.Fields[k].Nth)
                }</span>
        }
}

func createFieldIdNameMap() <span class="cov8" title="1">{
        definitions.FieldIdNameMap = make(map[FieldHeader]string, len(definitions.Fields))
        for k := range definitions.Fields </span><span class="cov8" title="1">{
                fh, _ := definitions.GetFieldHeaderByFieldName(k)

                definitions.FieldIdNameMap[*fh] = k
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package definitions

type FieldInstance struct {
        FieldName string
        *fieldInfo
        FieldHeader *FieldHeader
        Ordinal     int32
}

type fieldInfo struct {
        Nth            int32
        IsVLEncoded    bool
        IsSerialized   bool
        IsSigningField bool
        Type           string
}

type FieldHeader struct {
        TypeCode  int32
        FieldCode int32
}

func CreateFieldHeader(tc, fc int32) FieldHeader <span class="cov0" title="0">{
        return FieldHeader{
                TypeCode:  tc,
                FieldCode: fc,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package definitions

// Returns the serialization data type for the given field name.
func (d *Definitions) GetTypeNameByFieldName(n string) (string, error) <span class="cov8" title="1">{

        fi, ok := d.Fields[n]

        if !ok </span><span class="cov8" title="1">{
                return "", &amp;NotFoundError{
                        Instance: "FieldName",
                        Input:    n,
                }
        }</span>

        <span class="cov8" title="1">return fi.Type, nil</span>
}

// Returns the type code associated with the given type name.
func (d *Definitions) GetTypeCodeByTypeName(n string) (int32, error) <span class="cov8" title="1">{
        typeCode, ok := d.Types[n]

        if !ok </span><span class="cov8" title="1">{
                return 0, &amp;NotFoundError{
                        Instance: "TypeName",
                        Input:    n,
                }
        }</span>
        <span class="cov8" title="1">return typeCode, nil</span>
}

// Returns the type code associated with the given field name.
func (d *Definitions) GetTypeCodeByFieldName(n string) (int32, error) <span class="cov8" title="1">{
        typeName, err := d.GetTypeNameByFieldName(n)

        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return d.Types[typeName], nil</span>
}

// Returns the field code associated with the given field name.
func (d *Definitions) GetFieldCodeByFieldName(n string) (int32, error) <span class="cov8" title="1">{

        fi, ok := d.Fields[n]

        if !ok </span><span class="cov8" title="1">{
                return 0, &amp;NotFoundError{
                        Instance: "FieldName",
                        Input:    n,
                }
        }</span>

        <span class="cov8" title="1">return fi.Nth, nil</span>
}

// Returns the field header struct associated with the given field name.
func (d *Definitions) GetFieldHeaderByFieldName(n string) (*FieldHeader, error) <span class="cov8" title="1">{

        fi, ok := d.Fields[n]

        if !ok </span><span class="cov8" title="1">{
                return nil, &amp;NotFoundError{
                        Instance: "FieldName",
                        Input:    n,
                }
        }</span>

        <span class="cov8" title="1">return fi.FieldHeader, nil</span>
}

// Returns the field name associated with the given field header struct.
func (d *Definitions) GetFieldNameByFieldHeader(fh FieldHeader) (string, error) <span class="cov8" title="1">{

        fim, ok := definitions.FieldIdNameMap[fh]

        if !ok </span><span class="cov8" title="1">{
                return "", &amp;NotFoundErrorFieldHeader{
                        Instance: "FieldHeader",
                        Input:    fh,
                }
        }</span>
        <span class="cov8" title="1">return fim, nil</span>
}

// Returns the field info struct associated with the given field name.
func (d *Definitions) GetFieldInfoByFieldName(n string) (*fieldInfo, error) <span class="cov8" title="1">{

        fi, ok := d.Fields[n]

        if !ok </span><span class="cov8" title="1">{
                return nil, &amp;NotFoundError{
                        Instance: "FieldName",
                        Input:    n,
                }
        }</span>

        <span class="cov8" title="1">return fi.fieldInfo, nil</span>
}

// Returns the field instance struct associated with the given field name.
func (d *Definitions) GetFieldInstanceByFieldName(n string) (*FieldInstance, error) <span class="cov8" title="1">{

        fi, ok := d.Fields[n]

        if !ok </span><span class="cov8" title="1">{
                return nil, &amp;NotFoundError{
                        Instance: "FieldName",
                        Input:    n,
                }
        }</span>
        <span class="cov8" title="1">return fi, nil</span>
}

// Returns the transaction type code associated with the transaction type name.
func (d *Definitions) GetTransactionTypeCodeByTransactionTypeName(n string) (int32, error) <span class="cov8" title="1">{
        txTypeCode, ok := d.TransactionTypes[n]

        if !ok </span><span class="cov8" title="1">{
                return 0, &amp;NotFoundError{
                        Instance: "TransactionTypeName",
                        Input:    n,
                }
        }</span>
        <span class="cov8" title="1">return txTypeCode, nil</span>
}

// Returns the transaction type name associated with the transaction type code.
func (d *Definitions) GetTransactionTypeNameByTransactionTypeCode(c int32) (string, error) <span class="cov8" title="1">{

        for txTypeName, code := range d.TransactionTypes </span><span class="cov8" title="1">{
                if code == c </span><span class="cov8" title="1">{
                        return txTypeName, nil
                }</span>
        }
        <span class="cov8" title="1">return "", &amp;NotFoundErrorInt{
                Instance: "TransactionTypeCode",
                Input:    c,
        }</span>
}

// Returns the transaction result name associated with the transaction result type code.
func (d *Definitions) GetTransactionResultNameByTransactionResultTypeCode(c int32) (string, error) <span class="cov8" title="1">{

        for txResultName, code := range d.TransactionResults </span><span class="cov8" title="1">{
                if code == c </span><span class="cov8" title="1">{
                        return txResultName, nil
                }</span>
        }

        <span class="cov8" title="1">return "", &amp;NotFoundErrorInt{
                Instance: "TransactionResultTypeCode",
                Input:    c,
        }</span>
}

// Returns the transaction result type code associated with the transaction result name.
func (d *Definitions) GetTransactionResultTypeCodeByTransactionResultName(n string) (int32, error) <span class="cov8" title="1">{

        txResultTypeCode, ok := d.TransactionResults[n]

        if !ok </span><span class="cov8" title="1">{
                return 0, &amp;NotFoundError{
                        Instance: "TransactionResultName",
                        Input:    n,
                }
        }</span>
        <span class="cov8" title="1">return txResultTypeCode, nil</span>
}

// Returns the ledger entry type code associated with the ledger entry type name.
func (d *Definitions) GetLedgerEntryTypeCodeByLedgerEntryTypeName(n string) (int32, error) <span class="cov8" title="1">{

        ledgerEntryTypeCode, ok := d.LedgerEntryTypes[n]

        if !ok </span><span class="cov8" title="1">{
                return 0, &amp;NotFoundError{
                        Instance: "LedgerEntryTypeName",
                        Input:    n,
                }
        }</span>
        <span class="cov8" title="1">return ledgerEntryTypeCode, nil</span>
}

// Returns the ledger entry type name associated with the ledger entry type code.
func (d *Definitions) GetLedgerEntryTypeNameByLedgerEntryTypeCode(c int32) (string, error) <span class="cov8" title="1">{

        for ledgerEntryTypeName, code := range d.LedgerEntryTypes </span><span class="cov8" title="1">{

                if code == c </span><span class="cov8" title="1">{
                        return ledgerEntryTypeName, nil
                }</span>
        }

        <span class="cov8" title="1">return "", &amp;NotFoundErrorInt{
                Instance: "LedgerEntryTypeCode",
                Input:    c,
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package definitions

func init() <span class="cov8" title="1">{
        err := loadDefinitions()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package binarycodec

import (
        "bytes"
        "encoding/hex"
        "errors"
        "strings"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"

        "github.com/Peersyst/xrpl-go/binary-codec/serdes"
        "github.com/Peersyst/xrpl-go/binary-codec/types"
)

var ErrSigningClaimFieldNotFound = errors.New("'Channel' &amp; 'Amount' fields are both required, but were not found")

const (
        txMultiSigPrefix          = "534D5400"
        paymentChannelClaimPrefix = "434C4D00"
        txSigPrefix               = "53545800"
)

// Encode converts a JSON transaction object to a hex string in the canonical binary format.
// The binary format is defined in XRPL's core codebase.
func Encode(json map[string]any) (string, error) <span class="cov8" title="1">{

        st := &amp;types.STObject{}

        // Iterate over the keys in the provided JSON
        for k := range json </span><span class="cov8" title="1">{

                // Get the FieldIdNameMap from the definitions package
                fh := definitions.Get().Fields[k]

                // If the field is not found in the FieldIdNameMap, delete it from the JSON

                if fh == nil </span><span class="cov0" title="0">{
                        delete(json, k)
                        continue</span>
                }
        }

        <span class="cov8" title="1">b, err := st.FromJson(json)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.ToUpper(hex.EncodeToString(b)), nil</span>
}

// EncodeForMultiSign: encodes a transaction into binary format in preparation for providing one
// signature towards a multi-signed transaction.
// (Only encodes fields that are intended to be signed.)
func EncodeForMultisigning(json map[string]any, xrpAccountID string) (string, error) <span class="cov8" title="1">{

        st := &amp;types.AccountID{}

        // SigningPubKey is required for multi-signing but should be set to empty string.

        json["SigningPubKey"] = ""

        suffix, err := st.FromJson(xrpAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">encoded, err := Encode(removeNonSigningFields(json))

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.ToUpper(txMultiSigPrefix + encoded + hex.EncodeToString(suffix)), nil</span>
}

// Encodes a transaction into binary format in preparation for signing.
func EncodeForSigning(json map[string]any) (string, error) <span class="cov8" title="1">{

        encoded, err := Encode(removeNonSigningFields(json))

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.ToUpper(txSigPrefix + encoded), nil</span>
}

// EncodeForPaymentChannelClaim: encodes a payment channel claim into binary format in preparation for signing.
func EncodeForSigningClaim(json map[string]any) (string, error) <span class="cov8" title="1">{

        if json["Channel"] == nil || json["Amount"] == nil </span><span class="cov8" title="1">{
                return "", ErrSigningClaimFieldNotFound
        }</span>

        <span class="cov8" title="1">channel, err := types.NewHash256().FromJson(json["Channel"])

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">t := &amp;types.Amount{}
        amount, err := t.FromJson(json["Amount"])

        if err != nil </span><span class="cov0" title="0">{
                return "", err

        }</span>

        <span class="cov8" title="1">if bytes.HasPrefix(amount, []byte{0x40}) </span><span class="cov8" title="1">{
                amount = bytes.Replace(amount, []byte{0x40}, []byte{0x00}, 1)
        }</span>

        <span class="cov8" title="1">return strings.ToUpper(paymentChannelClaimPrefix + hex.EncodeToString(channel) + hex.EncodeToString(amount)), nil</span>
}

// removeNonSigningFields removes the fields from a JSON transaction object that should not be signed.
func removeNonSigningFields(json map[string]any) map[string]any <span class="cov8" title="1">{

        for k := range json </span><span class="cov8" title="1">{
                fi, _ := definitions.Get().GetFieldInstanceByFieldName(k)

                if fi != nil &amp;&amp; !fi.IsSigningField </span><span class="cov8" title="1">{
                        delete(json, k)
                }</span>
        }

        <span class="cov8" title="1">return json</span>
}

// Decode decodes a hex string in the canonical binary format into a JSON transaction object.
func Decode(hexEncoded string) (map[string]any, error) <span class="cov8" title="1">{
        b, err := hex.DecodeString(hexEncoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p := serdes.NewBinaryParser(b)
        st := &amp;types.STObject{}
        m, err := st.ToJson(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return m.(map[string]any), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package serdes

import (
        "errors"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"
)

var (
        ErrParserOutOfBound error = errors.New("parser out of bounds")
)

type BinaryParser struct {
        data []byte
}

// NewBinaryParser returns a new BinaryParser initialized with the given data.
func NewBinaryParser(d []byte) *BinaryParser <span class="cov8" title="1">{
        return &amp;BinaryParser{
                data: d,
        }
}</span>

// ReadField reads the next field in the data.
// It reads the field's header, fetches the field's name based on its header,
// and then gets the FieldInstance for that field name.
func (p *BinaryParser) ReadField() (*definitions.FieldInstance, error) <span class="cov0" title="0">{
        fh, err := p.readFieldHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fn, err := definitions.Get().GetFieldNameByFieldHeader(*fh)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">f, err := definitions.Get().GetFieldInstanceByFieldName(fn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return f, nil</span>
}

// readFieldHeader reads the header of the next field in the data.
func (p *BinaryParser) readFieldHeader() (*definitions.FieldHeader, error) <span class="cov0" title="0">{
        // Read the first byte of the field header
        typeCode, _ := p.ReadByte()

        // The field code is the last 4 bits of the first byte
        fieldCode := typeCode &amp; 15
        typeCode = typeCode &gt;&gt; 4

        // Read the type code if it's not in the first byte
        if typeCode == 0 </span><span class="cov0" title="0">{
                typeCode, _ = p.ReadByte()
                if typeCode == 0 || typeCode &lt; 16 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid typecode")
                }</span>
        }

        // Read the field code if it's not in the first byte
        <span class="cov0" title="0">if fieldCode == 0 </span><span class="cov0" title="0">{
                fieldCode, _ = p.ReadByte()
                if fieldCode == 0 || fieldCode &lt; 16 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid fieldcode")
                }</span>
        }

        // Return the field header
        <span class="cov0" title="0">return &amp;definitions.FieldHeader{
                TypeCode:  int32(typeCode),
                FieldCode: int32(fieldCode),
        }, nil</span>
}

// ReadByte reads the next byte in the data.
// It returns an error if no more data is available.
func (p *BinaryParser) ReadByte() (byte, error) <span class="cov8" title="1">{
        if len(p.data) &lt; 1 </span><span class="cov0" title="0">{
                return 0, ErrParserOutOfBound
        }</span>
        <span class="cov8" title="1">b := p.data[0]
        p.data = p.data[1:]
        return b, nil</span>
}

// Peek returns the next byte in the data without advancing the read cursor.
// It returns an error if no more data is available.
func (p *BinaryParser) Peek() (byte, error) <span class="cov0" title="0">{
        if len(p.data) &lt; 1 </span><span class="cov0" title="0">{
                return 0, ErrParserOutOfBound
        }</span>
        <span class="cov0" title="0">return p.data[0], nil</span>
}

// ReadBytes reads the next n bytes in the data.
// It returns an error if fewer than n bytes are available.
func (p *BinaryParser) ReadBytes(n int) ([]byte, error) <span class="cov0" title="0">{
        var bytes []byte
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                b, err := p.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">bytes = append(bytes, b)</span>
        }
        <span class="cov0" title="0">return bytes, nil</span>
}

// HasMore returns true if there is more data to read, and false otherwise.
func (p *BinaryParser) HasMore() bool <span class="cov0" title="0">{
        return len(p.data) != 0
}</span>

// ReadVariableLength reads a variable-length field from the binary data
// and returns the length as an integer. The length is determined by
// 1 to 3 bytes length prefix according to XRPL documentation.
func (p *BinaryParser) ReadVariableLength() (int, error) <span class="cov8" title="1">{
        b1, err := p.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if b1 &lt; 193 </span><span class="cov8" title="1">{
                return int(b1), nil
        }</span>
        <span class="cov8" title="1">if b1 &gt; 192 &amp;&amp; b1 &lt; 241 </span><span class="cov8" title="1">{
                b2, err := p.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return 193 + ((int(b1) - 193) * 256) + int(b2), nil</span>
        }
        <span class="cov8" title="1">if b1 &gt; 240 &amp;&amp; b1 &lt; 255 </span><span class="cov8" title="1">{
                b2, err := p.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">b3, err := p.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return 12481 + ((int(b1) - 241) * 65536) + (int(b2) * 256) + int(b3), nil</span>
        }
        <span class="cov0" title="0">return 0, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package serdes

import (
        "errors"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"
)

var ErrLengthPrefixTooLong = errors.New("length of value must not exceed 918744 bytes of data")

type binarySerializer struct {
        sink []byte
}

func NewSerializer() *binarySerializer <span class="cov0" title="0">{
        return &amp;binarySerializer{}
}</span>

func (s *binarySerializer) put(v []byte) <span class="cov0" title="0">{
        s.sink = append(s.sink, v...)
}</span>

func (s *binarySerializer) GetSink() []byte <span class="cov0" title="0">{
        return s.sink
}</span>

func (s *binarySerializer) WriteFieldAndValue(fi definitions.FieldInstance, value []byte) error <span class="cov0" title="0">{
        h, err := encodeFieldID(fi.FieldName)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.put(h)

        if fi.IsVLEncoded </span><span class="cov0" title="0">{
                vl, err := encodeVariableLength(len(value))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">s.put(vl)</span>
        }

        <span class="cov0" title="0">s.put(value)

        if fi.Type == "STObject" </span><span class="cov0" title="0">{
                s.put([]byte{0xE1})
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func encodeVariableLength(len int) ([]byte, error) <span class="cov8" title="1">{
        if len &lt;= 192 </span><span class="cov8" title="1">{
                return []byte{byte(len)}, nil
        }</span>
        <span class="cov8" title="1">if len &lt; 12480 </span><span class="cov8" title="1">{
                len -= 193
                b1 := byte((len &gt;&gt; 8) + 193)
                b2 := byte((len &amp; 0xFF))
                return []byte{b1, b2}, nil
        }</span>
        <span class="cov8" title="1">if len &lt;= 918744 </span><span class="cov8" title="1">{
                len -= 12481
                b1 := byte((len &gt;&gt; 16) + 241)
                b2 := byte((len &gt;&gt; 8) &amp; 0xFF)
                b3 := byte(len &amp; 0xFF)
                return []byte{b1, b2, b3}, nil
        }</span>
        <span class="cov8" title="1">return nil, ErrLengthPrefixTooLong</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package serdes

import (
        "encoding/hex"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"
)

// Returns the unique field ID for a given field name.
// This field ID consists of the type code and field code, in 1 to 3 bytes
// depending on whether those values are "common" (&lt;16) or "uncommon" (&gt;16).
func encodeFieldID(fieldName string) ([]byte, error) <span class="cov0" title="0">{
        fh, err := definitions.Get().GetFieldHeaderByFieldName(fieldName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var b []byte
        if fh.TypeCode &lt; 16 &amp;&amp; fh.FieldCode &lt; 16 </span><span class="cov0" title="0">{
                return append(b, (byte(fh.TypeCode&lt;&lt;4))|byte(fh.FieldCode)), nil
        }</span>
        <span class="cov0" title="0">if fh.TypeCode &gt;= 16 &amp;&amp; fh.FieldCode &lt; 16 </span><span class="cov0" title="0">{
                return append(b, (byte(fh.FieldCode)), byte(fh.TypeCode)), nil
        }</span>
        <span class="cov0" title="0">if fh.TypeCode &lt; 16 &amp;&amp; fh.FieldCode &gt;= 16 </span><span class="cov0" title="0">{
                return append(b, byte(fh.TypeCode&lt;&lt;4), byte(fh.FieldCode)), nil
        }</span>
        <span class="cov0" title="0">if fh.TypeCode &gt;= 16 &amp;&amp; fh.FieldCode &gt;= 16 </span><span class="cov0" title="0">{
                return append(b, 0, byte(fh.TypeCode), byte(fh.FieldCode)), nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// Returns the field name represented by the given field ID in hex string form.
// nolint
func decodeFieldID(h string) (string, error) <span class="cov0" title="0">{
        b, err := hex.DecodeString(h)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(b) == 1 </span><span class="cov0" title="0">{
                return definitions.Get().GetFieldNameByFieldHeader(definitions.CreateFieldHeader(int32(b[0]&gt;&gt;4), int32(b[0]&amp;byte(15))))
        }</span>
        <span class="cov0" title="0">if len(b) == 2 </span><span class="cov0" title="0">{
                firstByteHighBits := b[0] &gt;&gt; 4
                firstByteLowBits := b[0] &amp; byte(15)
                if firstByteHighBits == 0 </span><span class="cov0" title="0">{
                        return definitions.Get().GetFieldNameByFieldHeader(definitions.CreateFieldHeader(int32(b[1]), int32(firstByteLowBits)))
                }</span>
                <span class="cov0" title="0">return definitions.Get().GetFieldNameByFieldHeader(definitions.CreateFieldHeader(int32(firstByteHighBits), int32(b[1])))</span>
        }
        <span class="cov0" title="0">if len(b) == 3 </span><span class="cov0" title="0">{
                return definitions.Get().GetFieldNameByFieldHeader(definitions.CreateFieldHeader(int32(b[1]), int32(b[2])))
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import (
        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// AccountID struct represents an account ID.
type AccountID struct{}

// FromJson is a method for the AccountID type that takes a value as a parameter,
// serializes it to a byte slice representing an AccountID.
// Decodes the ClassicAddress to an AccountID and returns the byte representation.
// AccountIDs that appear as stand-alone fields (such as Account and Destination)
// are length-prefixed despite being a fixed 160 bits in length. As a result,
// the length indicator for these fields is always the byte 0x14.
// AccountIDs that appear as children of special fields (Amount issuer and PathSet account) are not length-prefixed.
// So in Amount and PathSet fields, don't use the length indicator 0x14.
func (a *AccountID) FromJson(value any) ([]byte, error) <span class="cov8" title="1">{
        _, accountID, err := addresscodec.DecodeClassicAddressToAccountID(value.(string))

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return accountID, nil</span>
}

// ToJson is a method for the AccountID type that deserializes a byte slice
// representation of an AccountID into a JSON value.
// It takes a binary parser and an optional length prefix size as arguments.
// The method reads the bytes using the binary parser,
// then encodes the result to an AccountID format.
// If no length prefix size is given, it returns an ErrNoLengthPrefix error.
func (a *AccountID) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                return nil, ErrNoLengthPrefix
        }</span>
        <span class="cov8" title="1">b, err := p.ReadBytes(opts[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return addresscodec.Encode(b, []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "encoding/hex"
        "errors"
        "fmt"
        "math/big"
        "regexp"
        "strconv"
        "strings"

        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
        bigdecimal "github.com/Peersyst/xrpl-go/pkg/big-decimal"
)

const (
        MinIOUExponent  = -96
        MaxIOUExponent  = 80
        MaxIOUPrecision = 16
        MinIOUMantissa  = 1000000000000000
        MaxIOUMantissa  = 9999999999999999

        NotXRPBitMask            = 0x80
        PosSignBitMask           = 0x4000000000000000
        ZeroCurrencyAmountHex    = 0x8000000000000000
        NativeAmountByteLength   = 8
        CurrencyAmountByteLength = 48

        MinXRP   = 1e-6
        MaxDrops = 1e17 // 100 billion XRP in drops aka 10^17

        IOUCodeRegex = `[0-9A-Za-z?!@#$%^&amp;*&lt;&gt;(){}\[\]|]{3}`
)

var (
        ErrInvalidXRPValue     = errors.New("invalid XRP value")
        ErrInvalidCurrencyCode = errors.New("invalid currency code")
        zeroByteArray          = make([]byte, 20)
)

// InvalidAmountError is a custom error type for invalid amounts.
type InvalidAmountError struct {
        Amount string
}

// Error method for InvalidAmountError returns a formatted error string.
func (e *InvalidAmountError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("value '%s' is an invalid amount", e.Amount)
}</span>

// OutOfRangeError is a custom error type for out-of-range values.
type OutOfRangeError struct {
        Type string
}

// Error method for OutOfRangeError returns a formatted error string.
func (e *OutOfRangeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s is out of range", e.Type)
}</span>

// InvalidCodeError is a custom error type for invalid currency codes.
type InvalidCodeError struct {
        Disallowed string
}

// Error method for InvalidCodeError returns a formatted error string.
func (e *InvalidCodeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("'%s' is/are disallowed or invalid", e.Disallowed)
}</span>

// Amount is a struct that represents an XRPL Amount.
type Amount struct{}

// FromJson serializes an issued currency amount to its bytes representation from JSON.
func (a *Amount) FromJson(value any) ([]byte, error) <span class="cov0" title="0">{

        switch value := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return serializeXrpAmount(value)</span>
        case map[string]any:<span class="cov0" title="0">
                return serializeIssuedCurrencyAmount(value["value"].(string), value["currency"].(string), value["issuer"].(string))</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("invalid amount type")</span>
        }
}

// ToJson deserializes a binary-encoded Amount object from a BinaryParser into a JSON representation.
func (a *Amount) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov0" title="0">{
        b, err := p.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var sign string
        if !isPositive(b) </span><span class="cov0" title="0">{
                sign = "-"
        }</span>
        <span class="cov0" title="0">if isNative(b) </span><span class="cov0" title="0">{
                xrp, err := p.ReadBytes(8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">xrpVal := binary.BigEndian.Uint64(xrp)
                xrpVal = xrpVal &amp; 0x3FFFFFFFFFFFFFFF
                return sign + strconv.FormatUint(xrpVal, 10), nil</span>
        } else<span class="cov0" title="0"> {
                token, err := p.ReadBytes(48)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return deserializeToken(token)</span>
        }
}

func deserializeToken(data []byte) (map[string]any, error) <span class="cov0" title="0">{

        var value string
        var err error
        if bytes.Equal(data[0:8], []byte{0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}) </span><span class="cov0" title="0">{
                value = "0"
        }</span> else<span class="cov0" title="0"> {
                value, err = deserializeValue(data[:8])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">issuer, err := deserializeIssuer(data[28:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">curr, err := deserializeCurrencyCode(data[8:28])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return map[string]any{
                "value":    value,
                "currency": curr,
                "issuer":   issuer,
        }, nil</span>
}

func deserializeValue(data []byte) (string, error) <span class="cov0" title="0">{
        sign := ""
        if !isPositive(data[0]) </span><span class="cov0" title="0">{
                sign = "-"
        }</span>
        <span class="cov0" title="0">value_bytes := data[:8]
        b1 := value_bytes[0]
        b2 := value_bytes[1]
        e1 := int((b1 &amp; 0x3F) &lt;&lt; 2)
        e2 := int(b2 &gt;&gt; 6)
        exponent := e1 + e2 - 97
        sig_figs := append([]byte{0, (b2 &amp; 0x3F)}, value_bytes[2:]...)
        sig_figs_int := binary.BigEndian.Uint64(sig_figs)
        d, err := bigdecimal.NewBigDecimal(sign + strconv.Itoa(int(sig_figs_int)) + "e" + strconv.Itoa(exponent))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">val := d.GetScaledValue()
        err = verifyIOUValue(val)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

func deserializeCurrencyCode(data []byte) (string, error) <span class="cov8" title="1">{
        // Check for special xrp case
        if bytes.Equal(data, zeroByteArray) </span><span class="cov0" title="0">{
                return "XRP", nil
        }</span>

        <span class="cov8" title="1">if bytes.Equal(data[0:12], make([]byte, 12)) &amp;&amp; bytes.Equal(data[12:15], []byte{0x58, 0x52, 0x50}) &amp;&amp; bytes.Equal(data[15:20], make([]byte, 5)) </span><span class="cov0" title="0">{ // XRP in bytes
                return "", ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">iso := strings.ToUpper(string(data[12:15]))
        ok, _ := regexp.MatchString(IOUCodeRegex, iso)

        if !ok </span><span class="cov0" title="0">{
                return strings.ToUpper(hex.EncodeToString(data)), nil
        }</span>
        <span class="cov8" title="1">return iso, nil</span>
}

func deserializeIssuer(data []byte) (string, error) <span class="cov0" title="0">{
        return addresscodec.Encode(data, []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength), nil
}</span>

// verifyXrpValue validates the format of an XRP amount value.
// XRP values should not contain a decimal point because they are represented as integers as drops.
func verifyXrpValue(value string) error <span class="cov8" title="1">{

        r := regexp.MustCompile(`\d+`) // regex to match only digits
        m := r.FindAllString(value, -1)

        if len(m) != 1 </span><span class="cov8" title="1">{
                return ErrInvalidXRPValue
        }</span>

        <span class="cov8" title="1">decimal := new(big.Float)
        decimal, ok := decimal.SetString(value) // bigFloat for precision

        if !ok </span><span class="cov0" title="0">{
                return errors.New("failed to convert string to big.Float")
        }</span>

        <span class="cov8" title="1">if decimal.Sign() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if decimal.Cmp(big.NewFloat(MinXRP)) == -1 || decimal.Cmp(big.NewFloat(MaxDrops)) == 1 </span><span class="cov8" title="1">{
                return &amp;InvalidAmountError{value}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// verifyIOUValue validates the format of an issued currency amount value.
func verifyIOUValue(value string) error <span class="cov8" title="1">{

        bigDecimal, err := bigdecimal.NewBigDecimal(value)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if bigDecimal.UnscaledValue == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">exp := bigDecimal.Scale

        if bigDecimal.Precision &gt; MaxIOUPrecision </span><span class="cov8" title="1">{
                return &amp;OutOfRangeError{Type: "Precision"} // if the precision is greater than 16, return an error
        }</span>
        <span class="cov8" title="1">if exp &lt; MinIOUExponent </span><span class="cov8" title="1">{
                return &amp;OutOfRangeError{Type: "Exponent"} // if the scale is less than -96 or greater than 80, return an error
        }</span>
        <span class="cov8" title="1">if exp &gt; MaxIOUExponent </span><span class="cov8" title="1">{
                return &amp;OutOfRangeError{Type: "Exponent"} // if the scale is less than -96 or greater than 80, return an error
        }</span>

        <span class="cov8" title="1">return err</span>
}

// serializeXrpAmount serializes an XRP amount value.
func serializeXrpAmount(value string) ([]byte, error) <span class="cov8" title="1">{

        if verifyXrpValue(value) != nil </span><span class="cov8" title="1">{
                return nil, verifyXrpValue(value)
        }</span>

        <span class="cov8" title="1">val, err := strconv.ParseUint(value, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">valWithPosBit := val | PosSignBitMask
        valBytes := make([]byte, NativeAmountByteLength)

        binary.BigEndian.PutUint64(valBytes, uint64(valWithPosBit))

        return valBytes, nil</span>
}

// XRPL definition of precision is number of significant digits:
// Tokens can represent a wide variety of assets, including those typically measured in very small or very large denominations.
// This format uses significant digits and a power-of-ten exponent in a similar way to scientific notation.
// The format supports positive and negative significant digits and exponents within the specified range.
// Unlike typical floating-point representations of non-whole numbers, this format uses integer math for all calculations,
// so it always maintains 15 decimal digits of precision. Multiplication and division have adjustments to compensate for
// over-rounding in the least significant digits.

// SerializeIssuedCurrencyValue serializes the value field of an issued currency amount to its bytes representation.
func SerializeIssuedCurrencyValue(value string) ([]byte, error) <span class="cov8" title="1">{

        if verifyIOUValue(value) != nil </span><span class="cov8" title="1">{
                return nil, verifyIOUValue(value)
        }</span>

        <span class="cov8" title="1">bigDecimal, err := bigdecimal.NewBigDecimal(value)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if bigDecimal.UnscaledValue == "" </span><span class="cov0" title="0">{
                zeroAmount := make([]byte, 8)
                binary.BigEndian.PutUint64(zeroAmount, uint64(ZeroCurrencyAmountHex))
                return zeroAmount, nil // if the value is zero, then return the zero currency amount hex
        }</span>

        <span class="cov8" title="1">mantissa, err := strconv.ParseUint(bigDecimal.UnscaledValue, 10, 64) // convert the unscaled value to an unsigned integer

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">exp := bigDecimal.Scale // get the scale

        for mantissa &lt; MinIOUMantissa &amp;&amp; exp &gt; MinIOUExponent </span><span class="cov8" title="1">{
                mantissa *= 10
                exp--
        }</span>

        <span class="cov8" title="1">for mantissa &gt; MaxIOUMantissa </span><span class="cov0" title="0">{
                if exp &gt;= MaxIOUExponent </span><span class="cov0" title="0">{
                        return nil, &amp;OutOfRangeError{Type: "Exponent"} // if the scale is less than -96 or greater than 80, return an error
                }</span>
                <span class="cov0" title="0">mantissa /= 10
                exp++

                if exp &lt; MinIOUExponent || mantissa &lt; MinIOUMantissa </span><span class="cov0" title="0">{
                        // round down to zero
                        zeroAmount := make([]byte, 8)
                        binary.BigEndian.PutUint64(zeroAmount, uint64(ZeroCurrencyAmountHex))
                        return zeroAmount, nil
                }</span>

                <span class="cov0" title="0">if exp &gt; MaxIOUExponent || mantissa &gt; MaxIOUMantissa </span><span class="cov0" title="0">{
                        return nil, &amp;OutOfRangeError{Type: "Exponent"} // if the scale is less than -96 or greater than 80, return an error
                }</span>
        }

        // convert components to bytes

        <span class="cov8" title="1">serial := uint64(ZeroCurrencyAmountHex) // set first bit to 1 because it is not XRP
        if bigDecimal.Sign == 0 </span><span class="cov8" title="1">{
                serial |= PosSignBitMask // if the sign is positive, set the sign (second) bit to 1
        }</span>
        <span class="cov8" title="1">serial |= (uint64(exp+97) &lt;&lt; 54) // if the exponent is positive, set the exponent bits to the exponent + 97
        serial |= uint64(mantissa)       // last 54 bits are mantissa

        serialReturn := make([]byte, 8)
        binary.BigEndian.PutUint64(serialReturn, serial)

        return serialReturn, nil</span>
}

// serializeIssuedCurrencyCode serializes an issued currency code to its bytes representation.
// The currency code can be 3 allowed string characters, or 20 bytes of hex.
func serializeIssuedCurrencyCode(currency string) ([]byte, error) <span class="cov8" title="1">{

        currency = strings.TrimPrefix(currency, "0x")                                    // remove the 0x prefix if it exists
        if currency == "XRP" || currency == "0000000000000000000000005852500000000000" </span><span class="cov8" title="1">{ // if the currency code is uppercase XRP, return an error
                return nil, &amp;InvalidCodeError{Disallowed: "XRP uppercase"}
        }</span>

        <span class="cov8" title="1">switch len(currency) </span>{
        case 3:<span class="cov8" title="1"> // if the currency code is 3 characters, it is standard
                return serializeIssuedCurrencyCodeChars(currency)</span>
        case 40:<span class="cov8" title="1"> // if the currency code is 40 characters, it is hex encoded
                return serializeIssuedCurrencyCodeHex(currency)</span>
        }

        <span class="cov8" title="1">return nil, &amp;InvalidCodeError{Disallowed: currency}</span>

}

func serializeIssuedCurrencyCodeHex(currency string) ([]byte, error) <span class="cov8" title="1">{
        decodedHex, err := hex.DecodeString(currency)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if bytes.HasPrefix(decodedHex, []byte{0x00}) </span><span class="cov8" title="1">{

                if bytes.Equal(decodedHex[12:15], []byte{0x00, 0x00, 0x00}) </span><span class="cov8" title="1">{
                        return make([]byte, 20), nil
                }</span>

                <span class="cov8" title="1">if containsInvalidIOUCodeCharactersHex(decodedHex[12:15]) </span><span class="cov8" title="1">{
                        return nil, ErrInvalidCurrencyCode
                }</span>
                <span class="cov8" title="1">return decodedHex, nil</span>

        }
        <span class="cov8" title="1">return decodedHex, nil</span>
}

func serializeIssuedCurrencyCodeChars(currency string) ([]byte, error) <span class="cov8" title="1">{

        r := regexp.MustCompile(IOUCodeRegex) // regex to check if the currency code is valid
        m := r.FindAllString(currency, -1)

        if len(m) != 1 </span><span class="cov8" title="1">{
                return nil, ErrInvalidCurrencyCode
        }</span>

        <span class="cov8" title="1">currencyBytes := make([]byte, 20)
        copy(currencyBytes[12:], []byte(currency))
        return currencyBytes[:], nil</span>
}

// SerializeIssuedCurrencyAmount serializes the currency field of an issued currency amount to its bytes representation
// from value, currency code, and issuer address in string form (e.g. "USD", "r123456789").
// The currency code can be 3 allowed string characters, or 20 bytes of hex in standard currency format (e.g. with "00" prefix)
// or non-standard currency format (e.g. without "00" prefix)
func serializeIssuedCurrencyAmount(value, currency, issuer string) ([]byte, error) <span class="cov8" title="1">{

        var valBytes []byte
        var err error
        if value == "0" </span><span class="cov0" title="0">{
                valBytes = make([]byte, 8)
                binary.BigEndian.PutUint64(valBytes, uint64(ZeroCurrencyAmountHex))
        }</span> else<span class="cov8" title="1"> {
                valBytes, err = SerializeIssuedCurrencyValue(value) // serialize the value
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">currencyBytes, err := serializeIssuedCurrencyCode(currency) // serialize the currency code

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, issuerBytes, err := addresscodec.DecodeClassicAddressToAccountID(issuer) // decode the issuer address
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // AccountIDs that appear as children of special fields (Amount issuer and PathSet account) are not length-prefixed.
        // So in Amount and PathSet fields, don't use the length indicator 0x14. This is in contrast to the AccountID fields where the length indicator prefix 0x14 is added.

        <span class="cov8" title="1">return append(append(valBytes, currencyBytes...), issuerBytes...), nil</span>
}

// Returns true if this amount is a "native" XRP amount - first bit in first byte set to 0 for native XRP
func isNative(value byte) bool <span class="cov8" title="1">{
        x := value&amp;NotXRPBitMask == 0 // &amp; bitwise operator returns 1 if both first bits are 1, otherwise 0
        return x
}</span>

// Determines if this AmountType is positive - 2nd bit in 1st byte is set to 1 for positive amounts
func isPositive(value byte) bool <span class="cov8" title="1">{
        x := value&amp;0x40 &gt; 0
        return x
}</span>

func containsInvalidIOUCodeCharactersHex(currency []byte) bool <span class="cov8" title="1">{

        r := regexp.MustCompile(IOUCodeRegex) // regex to check if the currency code is valid
        m := r.FindAll(currency, -1)

        return len(m) != 1
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package types

import (
        "encoding/hex"
        "errors"
        "strings"

        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// ErrNoLengthPrefix error is raised when no length prefix size is given.
var ErrNoLengthPrefix error = errors.New("no length prefix size given")

// Blob struct is used for manipulating hexadecimal data.
type Blob struct{}

// FromJson method for Blob converts a hexadecimal string from JSON to a byte array.
func (b *Blob) FromJson(json any) ([]byte, error) <span class="cov8" title="1">{
        // Convert hexadecimal string to byte array.
        // Return an error if the conversion fails.
        v, err := hex.DecodeString(json.(string))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// ToJson method for Blob reads a certain number of bytes from a BinaryParser
// and converts it into a hexadecimal string.
// It returns an error if no length prefix is specified or if the read operation fails.
func (b *Blob) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        // If no length prefix is specified, return an error.
        if opts == nil </span><span class="cov8" title="1">{
                return nil, ErrNoLengthPrefix
        }</span>
        // Read the specified number of bytes.
        // If the read operation fails, return an error.
        <span class="cov8" title="1">val, err := p.ReadBytes(opts[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // Convert the bytes to a hexadecimal string and return it.
        <span class="cov8" title="1">return strings.ToUpper(hex.EncodeToString(val)), nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package errors

// ErrNotValidJson is an error that occurs when the json is not valid.
type ErrNotValidJson struct{}

// Error returns the error message for the ErrNotValidJson error.
func (e *ErrNotValidJson) Error() string <span class="cov8" title="1">{
        return "not a valid json"
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package types

import (
        "encoding/hex"
        "fmt"
        "strings"

        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// ErrInvalidHashLength struct is used when the hash length does not meet the expected value.
type ErrInvalidHashLength struct {
        Expected int
}

type ErrInvalidHashType struct{}

type ErrInvalidHexString struct {
        Err error
}

// Error method for ErrInvalidHashLength formats the error message.
func (e *ErrInvalidHashLength) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid hash length expected length %v", e.Expected)
}</span>

func (e *ErrInvalidHashType) Error() string <span class="cov8" title="1">{
        return "invalid hash type"
}</span>

func (e *ErrInvalidHexString) Error() string <span class="cov8" title="1">{
        return "error decoding hex string: " + e.Err.Error()
}</span>

// hashI interface combines the SerializedType interface and getLength method for hashes.
type hashI interface {
        SerializedType
        getLength() int
}

// hash struct represents a hash with a specific length.
type hash struct {
        Length int
}

// newHash is a constructor for creating a new hash with a specified length.
func newHash(l int) hash <span class="cov8" title="1">{
        return hash{
                Length: l,
        }
}</span>

// getLength method for hash returns the hash's length.
func (h hash) getLength() int <span class="cov8" title="1">{
        return h.Length
}</span>

// FromJson method for hash converts a hexadecimal string from JSON to a byte array.
// It returns an error if the conversion fails or the length of the decoded byte array is not as expected.
func (h hash) FromJson(json any) ([]byte, error) <span class="cov8" title="1">{
        v, ok := json.(string)
        if !ok </span><span class="cov8" title="1">{
                return nil, &amp;ErrInvalidHashType{}
        }</span>
        <span class="cov8" title="1">decoded, err := hex.DecodeString(v)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrInvalidHexString{Err: err}
        }</span>
        <span class="cov8" title="1">if h.getLength() != len(decoded) </span><span class="cov8" title="1">{
                return nil, &amp;ErrInvalidHashLength{Expected: h.getLength()}
        }</span>
        <span class="cov8" title="1">return decoded, nil</span>
}

// ToJson method for hash reads a certain number of bytes from a BinaryParser and converts it into a hexadecimal string.
// It returns an error if the read operation fails.
func (h hash) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        b, err := p.ReadBytes(h.Length)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(hex.EncodeToString(b)), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package types

// Hash128 struct represents a 128-bit hash.
type Hash128 struct {
        hashI
}

// NewHash128 is a constructor for creating a new 128-bit hash.
func NewHash128() *Hash128 <span class="cov8" title="1">{
        return &amp;Hash128{
                newHash(16),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package types

// Hash160 struct represents a 160-bit hash.
type Hash160 struct {
        hashI
}

// NewHash160 is a constructor for creating a new 160-bit hash.
func NewHash160() *Hash160 <span class="cov8" title="1">{
        return &amp;Hash160{
                newHash(20),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package types

// Hash256 struct represents a 256-bit hash.
type Hash256 struct {
        hashI
}

// NewHash256 is a constructor for creating a new 256-bit hash.
func NewHash256() *Hash256 <span class="cov8" title="1">{
        return &amp;Hash256{
                newHash(32),
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package types

import (
        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// Issue represents an XRPL Issue, which is essentially an AccountID.
// It is used to identify the issuer of a currency in the XRPL.
// The FromJson method converts a classic address string to an AccountID byte slice.
// The ToJson method converts an AccountID byte slice back to a classic address string.
// This type is crucial for handling currency issuers in XRPL transactions and ledger entries.
type Issue struct{}

// FromJson parses a classic address string and returns the corresponding AccountID byte slice.
// It uses the addresscodec package to decode the classic address.
// If the input is not a valid classic address, it returns an error.
func (i *Issue) FromJson(json any) ([]byte, error) <span class="cov8" title="1">{
        _, accountID, err := addresscodec.DecodeClassicAddressToAccountID(json.(string))

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return accountID, nil</span>
}

// ToJson converts an AccountID byte slice back to a classic address string.
// It uses the addresscodec package to encode the byte slice.
// If the input is not a valid AccountID byte slice, it returns an error.
func (i *Issue) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                return nil, ErrNoLengthPrefix
        }</span>
        <span class="cov8" title="1">b, err := p.ReadBytes(opts[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return addresscodec.Encode(b, []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package types

import (
        "errors"
        "fmt"

        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

const (
        typeAccount  = 0x01
        typeCurrency = 0x10
        typeIssuer   = 0x20

        pathsetEndByte    = 0x00
        pathSeparatorByte = 0xFF
)

// PathSet type declaration
type PathSet struct{}

// ErrInvalidPathSet is an error that's thrown when an invalid path set is provided.
var ErrInvalidPathSet error = errors.New("invalid type to construct PathSet from. Expected []any of []any")

// FromJson attempts to serialize a path set from a JSON representation of a slice of paths to a byte array.
// It returns the byte array representation of the path set, or an error if the provided json does not represent a valid path set.
func (p PathSet) FromJson(json any) ([]byte, error) <span class="cov0" title="0">{

        if _, ok := json.([]any)[0].([]any); !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidPathSet
        }</span>

        <span class="cov0" title="0">if !isPathSet(json.([]any)) </span><span class="cov0" title="0">{
                return nil, ErrInvalidPathSet
        }</span>

        <span class="cov0" title="0">return newPathSet(json.([]any)), nil</span>
}

// ToJson decodes a path set from a binary representation using a provided binary parser, then translates it to a JSON representation.
// It returns a slice representing the JSON format of the path set, or an error if the path set could not be decoded or if an invalid step is encountered.
func (p PathSet) ToJson(parser interfaces.BinaryParser, opts ...int) (any, error) <span class="cov0" title="0">{
        var pathSet []any

        for parser.HasMore() </span><span class="cov0" title="0">{
                peek, err := parser.Peek()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if peek == pathsetEndByte </span><span class="cov0" title="0">{
                        _, err := parser.ReadByte()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">path, err := parsePath(parser)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if len(path) &gt; 0 </span><span class="cov0" title="0">{
                        for i, step := range path </span><span class="cov0" title="0">{
                                stepMap, ok := step.(map[string]any)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("step is not of type map[string]any")
                                }</span>
                                <span class="cov0" title="0">if _, ok := stepMap["account"]; ok </span><span class="cov0" title="0">{
                                        stepMap["type"] = 1
                                        stepMap["type_hex"] = "0000000000000001"
                                }</span>
                                <span class="cov0" title="0">if _, ok := stepMap["currency"]; ok </span><span class="cov0" title="0">{
                                        stepMap["type"] = 16
                                        stepMap["type_hex"] = "0000000000000010"
                                }</span>
                                <span class="cov0" title="0">path[i] = stepMap</span>
                        }
                        <span class="cov0" title="0">pathSet = append(pathSet, path)</span>
                }
        }

        <span class="cov0" title="0">return pathSet, nil</span>
}

// isPathSet determines if an array represents a valid path set.
// It checks if the array is either empty or if its first element is a valid path step.
func isPathSet(v []any) bool <span class="cov0" title="0">{
        return len(v) == 0 || len(v[0].([]any)) == 0 || isPathStep(v[0].([]any)[0].(map[string]any))
}</span>

// isPathStep determines if a map represents a valid path step.
// It checks if any of the keys "account", "currency" or "issuer" are present in the map.
func isPathStep(v map[string]any) bool <span class="cov8" title="1">{
        return v["account"] != nil || v["currency"] != nil || v["issuer"] != nil
}</span>

// newPathStep creates a path step from a map representation.
// It generates a byte array representation of the path step, encoding account, currency, and issuer information as appropriate.
func newPathStep(v map[string]any) []byte <span class="cov8" title="1">{

        dataType := 0x00
        b := make([]byte, 0)

        if v["account"] != nil </span><span class="cov8" title="1">{
                _, account, _ := addresscodec.DecodeClassicAddressToAccountID(v["account"].(string))
                b = append(b, account...)
                dataType |= typeAccount
        }</span>
        <span class="cov8" title="1">if v["currency"] != nil </span><span class="cov8" title="1">{
                currency, _ := serializeIssuedCurrencyCode(v["currency"].(string))
                b = append(b, currency...)
                dataType |= typeCurrency
        }</span>
        <span class="cov8" title="1">if v["issuer"] != nil </span><span class="cov8" title="1">{
                _, issuer, _ := addresscodec.DecodeClassicAddressToAccountID(v["issuer"].(string))
                b = append(b, issuer...)
                dataType |= typeIssuer
        }</span>

        <span class="cov8" title="1">return append([]byte{byte(dataType)}, b...)</span>
}

// newPath constructs a path from a slice of path steps.
// It generates a byte array representation of the path, encoding each path step in turn.
func newPath(v []any) []byte <span class="cov8" title="1">{
        b := make([]byte, 0)

        for _, step := range v </span><span class="cov8" title="1">{ // for each step in the path (slice of path steps)
                b = append(b, newPathStep(step.(map[string]any))...) // append the path step to the byte array
        }</span>
        <span class="cov8" title="1">return b</span>
}

// newPathSet constructs a path set from a slice of paths.
// It generates a byte array representation of the path set, encoding each path and adding padding and path separators as appropriate.
func newPathSet(v []any) []byte <span class="cov8" title="1">{

        b := make([]byte, 0)
        padding := make([]byte, 20)

        for _, path := range v </span><span class="cov8" title="1">{ // for each path in the path set (slice of paths)
                b = append(b, newPath(path.([]any))...) // append the path to the byte array
                b = append(b, padding...)               // append 20 empty bytes to the byte array between paths
                b = append(b, pathSeparatorByte)        // between each path, append a path separator byte
        }</span>

        <span class="cov8" title="1">b[len(b)-1] = pathsetEndByte // replace last path separator with path set end byte

        return b</span>

}

// parsePathStep decodes a path step from a binary representation using a provided binary parser.
// It returns a map representing the path step, or an error if the path step could not be decoded.
func parsePathStep(parser interfaces.BinaryParser) (map[string]any, error) <span class="cov8" title="1">{
        dataType, err := parser.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">step := make(map[string]any)

        operations := []struct {
                typeKey byte
                key     string
        }{
                {typeAccount, "account"},
                {typeCurrency, "currency"},
                {typeIssuer, "issuer"},
        }

        for _, op := range operations </span><span class="cov8" title="1">{
                if dataType&amp;op.typeKey != 0 </span><span class="cov8" title="1">{
                        bytes, err := parser.ReadBytes(20) // AccountID or Currency size
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if op.typeKey == typeCurrency </span><span class="cov8" title="1">{
                                value, err := deserializeCurrencyCode(bytes)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">step[op.key] = value</span>
                        } else<span class="cov8" title="1"> {
                                value := addresscodec.Encode(bytes, []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength)
                                step[op.key] = value
                        }</span>
                }
        }

        <span class="cov8" title="1">return step, nil</span>
}

// parsePath decodes a path from a binary representation using a provided binary parser.
// It returns a slice representing the path, or an error if the path could not be decoded.
func parsePath(parser interfaces.BinaryParser) ([]any, error) <span class="cov8" title="1">{
        var path []any

        for parser.HasMore() </span><span class="cov8" title="1">{
                peek, err := parser.Peek()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if peek == pathsetEndByte </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">if peek == pathSeparatorByte </span><span class="cov0" title="0">{
                        _, err := parser.ReadByte()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov8" title="1">step, err := parsePathStep(parser)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">path = append(path, step)</span>
        }

        <span class="cov8" title="1">return path, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package types

import (
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// SerializedType is an interface representing any type that can be serialized
// and deserialized to and from JSON.
// The FromJson method takes a JSON value and converts it to a byte slice.
// The ToJson method takes a BinaryParser and optional parameters, and converts
// the serialized byte data back to a JSON value.
type SerializedType interface {
        FromJson(json any) ([]byte, error)
        ToJson(parser interfaces.BinaryParser, opts ...int) (any, error)
}

// GetSerializedType is a function that returns the correct SerializedType instance
// based on the string parameter.
// It creates a new instance of the type described by the parameter, allowing
// the appropriate methods of that type to be called.
// If the input string does not match a known type, the function returns nil.
func GetSerializedType(t string) SerializedType <span class="cov8" title="1">{
        switch t </span>{
        case "UInt8":<span class="cov0" title="0">
                return &amp;UInt8{}</span>
        case "UInt16":<span class="cov8" title="1">
                return &amp;UInt16{}</span>
        case "UInt32":<span class="cov8" title="1">
                return &amp;UInt32{}</span>
        case "UInt64":<span class="cov8" title="1">
                return &amp;UInt64{}</span>
        case "Hash128":<span class="cov0" title="0">
                return NewHash128()</span>
        case "Hash160":<span class="cov8" title="1">
                return NewHash160()</span>
        case "Hash256":<span class="cov8" title="1">
                return NewHash256()</span>
        case "AccountID":<span class="cov8" title="1">
                return &amp;AccountID{}</span>
        case "Amount":<span class="cov0" title="0">
                return &amp;Amount{}</span>
        case "Vector256":<span class="cov0" title="0">
                return &amp;Vector256{}</span>
        case "Blob":<span class="cov8" title="1">
                return &amp;Blob{}</span>
        case "STObject":<span class="cov8" title="1">
                return &amp;STObject{}</span>
        case "STArray":<span class="cov0" title="0">
                return &amp;STArray{}</span>
        case "PathSet":<span class="cov0" title="0">
                return &amp;PathSet{}</span>
        case "XChainBridge":<span class="cov0" title="0">
                return &amp;XChainBridge{}</span>
        case "Issue":<span class="cov0" title="0">
                return &amp;Issue{}</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package types

import (
        "errors"

        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

const (
        ArrayEndMarker  = 0xF1
        ObjectEndMarker = 0xE1
)

// STArray represents an array of STObject instances.
type STArray struct{}

var ErrNotSTObjectInSTArray = errors.New("not STObject in STArray. Array fields must be STObjects")

// FromJson is a method that takes a JSON value (which should be a slice of JSON objects),
// and converts it to a byte slice, representing the serialized form of the STArray.
// It loops through the JSON slice, and for each element, calls the FromJson method
// of an STObject, appending the resulting byte slice to a "sink" slice.
// The method returns an error if the JSON value is not a slice.
func (t *STArray) FromJson(json any) ([]byte, error) <span class="cov8" title="1">{
        if _, ok := json.([]any); !ok </span><span class="cov0" title="0">{
                return nil, ErrNotSTObjectInSTArray
        }</span>

        <span class="cov8" title="1">var sink []byte
        for _, v := range json.([]any) </span><span class="cov8" title="1">{
                st := &amp;STObject{}
                b, err := st.FromJson(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">sink = append(sink, b...)</span>
        }
        <span class="cov8" title="1">sink = append(sink, ArrayEndMarker)

        return sink, nil</span>
}

// ToJson is a method that takes a BinaryParser and optional parameters, and converts
// the serialized byte data back to a JSON value.
// The method loops until the BinaryParser has no more data, and for each loop,
// it calls the ToJson method of an STObject, appending the resulting JSON value to a "value" slice.
func (t *STArray) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        var value []any
        count := 0

        for p.HasMore() </span><span class="cov8" title="1">{

                stObj := make(map[string]any)
                fi, err := p.ReadField()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if count == 0 &amp;&amp; fi.Type != "STObject" </span><span class="cov0" title="0">{
                        return nil, ErrNotSTObjectInSTArray
                }</span> else<span class="cov8" title="1"> if fi.FieldName == "ArrayEndMarker" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">fn := fi.FieldName
                st := GetSerializedType(fi.Type)
                res, err := st.ToJson(p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stObj[fn] = res
                value = append(value, stObj)
                count++</span>
        }
        <span class="cov8" title="1">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package types

import (
        "fmt"
        "sort"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"
        "github.com/Peersyst/xrpl-go/binary-codec/serdes"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// STObject represents a map of serialized field instances, where each key is a field name
// and the associated value is the field's value. This structure allows us to represent nested
// and complex structures of the Ripple protocol.
type STObject struct{}

// FromJson converts a JSON object into a serialized byte slice.
// It works by converting the JSON object into a map of field instances (which include the field definition
// and value), and then serializing each field instance.
// This method returns an error if the JSON input is not a valid object.
func (t *STObject) FromJson(json any) ([]byte, error) <span class="cov8" title="1">{
        s := serdes.NewSerializer()
        if _, ok := json.(map[string]any); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a valid json node")
        }</span>
        <span class="cov8" title="1">fimap, err := createFieldInstanceMapFromJson(json.(map[string]any))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sk := getSortedKeys(fimap)

        for _, v := range sk </span><span class="cov8" title="1">{
                if !v.IsSerialized </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">st := GetSerializedType(v.Type)
                b, err := st.FromJson(fimap[v])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = s.WriteFieldAndValue(v, b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return s.GetSink(), nil</span>
}

// ToJson takes a BinaryParser and optional parameters, and converts the serialized byte data
// back to a JSON value. It will continue parsing until it encounters an end marker for an object
// or an array, or until the parser has no more data.
func (t *STObject) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        m := make(map[string]any)

        for p.HasMore() </span><span class="cov8" title="1">{

                fi, err := p.ReadField()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if fi.FieldName == "ObjectEndMarker" || fi.FieldName == "ArrayEndMarker" </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">st := GetSerializedType(fi.Type)

                var res any
                if fi.IsVLEncoded </span><span class="cov8" title="1">{
                        vlen, err := p.ReadVariableLength()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">res, err = st.ToJson(p, vlen)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                } else<span class="cov8" title="1"> {
                        res, err = st.ToJson(p)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">res, err = enumToStr(fi.FieldName, res)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">m[fi.FieldName] = res</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// nolint
// createFieldInstanceMapFromJson creates a map of field instances from a JSON object.
// Each key-value pair in the JSON object is converted into a field instance, where the key
// represents the field name and the value is the field's value.
//
//lint:ignore U1000 // ignore this for now
func createFieldInstanceMapFromJson(json map[string]any) (map[definitions.FieldInstance]any, error) <span class="cov8" title="1">{
        m := make(map[definitions.FieldInstance]any, len(json))

        for k, v := range json </span><span class="cov8" title="1">{
                fi, err := definitions.Get().GetFieldInstanceByFieldName(k)

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">m[*fi] = v</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// nolint
//
// getSortedKeys is a helper function to sort the keys of a map of field instances based on
// their ordinal values. This is used to ensure that the fields are serialized in the
// correct order.
//
//lint:ignore U1000 // ignore this for now
func getSortedKeys(m map[definitions.FieldInstance]any) []definitions.FieldInstance <span class="cov8" title="1">{
        keys := make([]definitions.FieldInstance, 0, len(m))

        for k := range m </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>

        <span class="cov8" title="1">sort.SliceStable(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                return keys[i].Ordinal &lt; keys[j].Ordinal
        }</span>)
        <span class="cov8" title="1">return keys</span>
}

// enumToStr is a helper function that takes a field name and its associated value,
// and returns a string representation of the value if the field is an enumerated type
// (i.e., TransactionType, TransactionResult, LedgerEntryType).
// If the field is not an enumerated type, the original value is returned.
func enumToStr(fieldType string, value any) (any, error) <span class="cov8" title="1">{
        switch fieldType </span>{
        case "TransactionType":<span class="cov0" title="0">
                return definitions.Get().GetTransactionTypeNameByTransactionTypeCode(int32(value.(int)))</span>
        case "TransactionResult":<span class="cov0" title="0">
                return definitions.Get().GetTransactionResultNameByTransactionResultTypeCode(int32(value.(int)))</span>
        case "LedgerEntryType":<span class="cov8" title="1">
                return definitions.Get().GetLedgerEntryTypeNameByLedgerEntryTypeCode(int32(value.(int)))</span>
        default:<span class="cov8" title="1">
                return value, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package types

import (
        "bytes"
        "encoding/binary"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// UInt16 represents a 16-bit unsigned integer.
type UInt16 struct{}

// FromJson converts a JSON value into a serialized byte slice representing a 16-bit unsigned integer.
// If the input value is a string, it's assumed to be a transaction type or ledger entry type name, and the
// method will attempt to convert it into a corresponding type code. If the conversion fails, an error is returned.
func (u *UInt16) FromJson(value any) ([]byte, error) <span class="cov8" title="1">{

        if _, ok := value.(string); ok </span><span class="cov8" title="1">{
                tc, err := definitions.Get().GetTransactionTypeCodeByTransactionTypeName(value.(string))
                if err != nil </span><span class="cov8" title="1">{
                        tc, err = definitions.Get().GetLedgerEntryTypeCodeByLedgerEntryTypeName(value.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">value = int(tc)</span>
        }

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        err := binary.Write(buf, binary.BigEndian, uint16(value.(int)))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// ToJson takes a BinaryParser and optional parameters, and converts the serialized byte data
// back into a JSON integer value. This method assumes the parser contains data representing
// a 16-bit unsigned integer. If the parsing fails, an error is returned.
func (u *UInt16) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        b, err := p.ReadBytes(2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return int(binary.BigEndian.Uint16(b)), nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package types

import (
        "bytes"
        "encoding/binary"

        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// UInt32 represents a 32-bit unsigned integer.
type UInt32 struct{}

// FromJson converts a JSON value into a serialized byte slice representing a 32-bit unsigned integer.
// The input value is assumed to be an integer. If the serialization fails, an error is returned.
func (u *UInt32) FromJson(value any) ([]byte, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        err := binary.Write(buf, binary.BigEndian, uint32(value.(int)))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// ToJson takes a BinaryParser and optional parameters, and converts the serialized byte data
// back into a JSON integer value. This method assumes the parser contains data representing
// a 32-bit unsigned integer. If the parsing fails, an error is returned.
func (u *UInt32) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        b, err := p.ReadBytes(4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return int(binary.BigEndian.Uint32(b)), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "encoding/hex"
        "errors"
        "regexp"
        "strconv"
        "strings"

        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// UInt64 represents a 64-bit unsigned integer.
type UInt64 struct{}

var ErrInvalidUInt64String error = errors.New("invalid UInt64 string, value should be a string representation of a UInt64")

// FromJson converts a JSON value into a serialized byte slice representing a 64-bit unsigned integer.
// The input value is assumed to be a string representation of an integer. If the serialization fails, an error is returned.
func (u *UInt64) FromJson(value any) ([]byte, error) <span class="cov8" title="1">{

        var buf = new(bytes.Buffer)

        if _, ok := value.(string); !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidUInt64String
        }</span>

        <span class="cov8" title="1">if !isNumeric(value.(string)) </span><span class="cov8" title="1">{
                if hex, err := hex.DecodeString(value.(string)); err == nil </span><span class="cov8" title="1">{
                        buf.Write(hex)
                        return buf.Bytes(), nil
                }</span>
                <span class="cov0" title="0">stringToUint64, err := strconv.ParseUint(value.(string), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">value = stringToUint64
                err = binary.Write(buf, binary.BigEndian, value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return buf.Bytes(), nil</span>
        } else<span class="cov8" title="1"> {
                value = strings.Repeat("0", 16-len(value.(string))) + value.(string) // right justify the string
                decoded, err := hex.DecodeString(value.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">buf.Write(decoded)</span>
        }

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// ToJson takes a BinaryParser and optional parameters, and converts the serialized byte data
// back into a JSON string value. This method assumes the parser contains data representing
// a 64-bit unsigned integer. If the parsing fails, an error is returned.
func (u *UInt64) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        b, err := p.ReadBytes(8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(hex.EncodeToString(b)), nil</span>
}

// isNumeric checks if a string only contains numerical values.
func isNumeric(s string) bool <span class="cov8" title="1">{
        match, _ := regexp.MatchString("^[0-9]+$", s)
        return match
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package types

import (
        "bytes"
        "encoding/binary"

        "github.com/Peersyst/xrpl-go/binary-codec/definitions"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// UInt8 represents an 8-bit unsigned integer.
type UInt8 struct{}

// FromJson converts a JSON value into a serialized byte slice representing an 8-bit unsigned integer.
// If the input value is a string, it's assumed to be a transaction result name, and the method will
// attempt to convert it into a transaction result type code. If the conversion fails, an error is returned.
func (u *UInt8) FromJson(value any) ([]byte, error) <span class="cov8" title="1">{
        if s, ok := value.(string); ok </span><span class="cov0" title="0">{
                tc, err := definitions.Get().GetTransactionResultTypeCodeByTransactionResultName(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">value = tc</span>
        }

        <span class="cov8" title="1">var intValue int

        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                intValue = v</span>
        case int32:<span class="cov0" title="0">
                intValue = int(v)</span>
        }

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        err := binary.Write(buf, binary.BigEndian, uint8(intValue))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// ToJson takes a BinaryParser and optional parameters, and converts the serialized byte data
// back into a JSON integer value. This method assumes the parser contains data representing
// an 8-bit unsigned integer. If the parsing fails, an error is returned.
func (u *UInt8) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        b, err := p.ReadBytes(1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return int(b[0]), nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package types

import (
        "encoding/hex"
        "fmt"
        "strings"

        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

const HashLengthBytes = 32

// ErrInvalidVector256Type represents an error when a Vector256 is constructed from an unexpected type.
type ErrInvalidVector256Type struct {
        Got string
}

// Error implements the error interface, providing a descriptive error message for ErrInvalidVector256Type.
func (e *ErrInvalidVector256Type) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid type to construct Vector256 from. Expected []string, got %v", e.Got)
}</span>

// Vector256 represents a 256 bit vector.
type Vector256 struct{}

// FromJson converts a JSON value into a serialized byte slice representing a Vector256.
// The input value is assumed to be an array of strings representing Hash256 values.
// If the serialization fails, an error is returned.
func (v *Vector256) FromJson(json any) ([]byte, error) <span class="cov0" title="0">{

        if _, ok := json.([]string); !ok </span><span class="cov0" title="0">{
                return nil, &amp;ErrInvalidVector256Type{fmt.Sprintf("%T", json)}
        }</span>

        <span class="cov0" title="0">b, err := vector256FromValue(json.([]string))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return b, nil</span>
}

// vector256FromValue takes a slice of strings representing Hash256 values,
// serializes them, and returns the combined byte slice. If an error occurs during serialization, it is returned.
func vector256FromValue(value []string) ([]byte, error) <span class="cov8" title="1">{
        b := make([]byte, 0)
        for _, s := range value </span><span class="cov8" title="1">{
                hash256, err := NewHash256().FromJson(s)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">b = append(b, hash256...)</span>

        }
        <span class="cov8" title="1">return b, nil</span>
}

// ToJson takes a BinaryParser and optional parameters, and converts the serialized byte data
// back into an array of JSON string values representing Hash256 values.
// If the parsing fails, an error is returned.
func (v *Vector256) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov0" title="0">{

        b, _ := p.ReadBytes(opts[0])
        var value []string

        for i := 0; i &lt; len(b); i += HashLengthBytes </span><span class="cov0" title="0">{
                value = append(value, strings.ToUpper(hex.EncodeToString(b[i:i+HashLengthBytes])))
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package types

import (
        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        "github.com/Peersyst/xrpl-go/binary-codec/types/errors"
        "github.com/Peersyst/xrpl-go/binary-codec/types/interfaces"
)

// ===============================
// Errors
// ===============================

// ErrNotValidXChainBridge is an error that occurs when the
// xchain bridge objectis not valid.
type ErrNotValidXChainBridge struct{}

// Error returns the error message.
func (e *ErrNotValidXChainBridge) Error() string <span class="cov8" title="1">{
        return "not a valid xchain bridge"
}</span>

// ErrReadBytes is an error that occurs when trying to read bytes with a parser.
type ErrReadBytes struct{}

// Error returns the error message.
func (e *ErrReadBytes) Error() string <span class="cov8" title="1">{
        return "read bytes error"
}</span>

// ErrDecodeClassicAddress is an error that occurs
// when trying to decode a classic address.
type ErrDecodeClassicAddress struct{}

// Error returns the error message.
func (e *ErrDecodeClassicAddress) Error() string <span class="cov8" title="1">{
        return "decode classic address error"
}</span>

// ===============================
// XChainBridge
// ===============================

// XChainBridge is a struct that represents an xchain bridge.
type XChainBridge struct{}

// FromJson converts a json XChainBridge object to its byte slice representation.
// It returns an error if the json is not valid or if the classic addresses are not valid.
func (x *XChainBridge) FromJson(json any) ([]byte, error) <span class="cov8" title="1">{
        v, ok := json.(map[string]any)
        if !ok </span><span class="cov8" title="1">{
                return nil, &amp;errors.ErrNotValidJson{}
        }</span>

        <span class="cov8" title="1">if v["LockingChainDoor"] == nil || v["LockingChainIssue"] == nil || v["IssuingChainDoor"] == nil || v["IssuingChainIssue"] == nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrNotValidXChainBridge{}
        }</span>

        <span class="cov8" title="1">_, lockingChainDoor, err := addresscodec.DecodeClassicAddressToAccountID(v["LockingChainDoor"].(string))
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrDecodeClassicAddress{}
        }</span>

        <span class="cov8" title="1">_, lockingChainIssue, err := addresscodec.DecodeClassicAddressToAccountID(v["LockingChainIssue"].(string))
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrDecodeClassicAddress{}
        }</span>

        <span class="cov8" title="1">_, issuingChainDoor, err := addresscodec.DecodeClassicAddressToAccountID(v["IssuingChainDoor"].(string))
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrDecodeClassicAddress{}
        }</span>

        <span class="cov8" title="1">_, issuingChainIssue, err := addresscodec.DecodeClassicAddressToAccountID(v["IssuingChainIssue"].(string))
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrDecodeClassicAddress{}
        }</span>

        <span class="cov8" title="1">bytes := make([]byte, 0, 80)

        bytes = append(bytes, lockingChainDoor...)
        bytes = append(bytes, lockingChainIssue...)
        bytes = append(bytes, issuingChainDoor...)
        bytes = append(bytes, issuingChainIssue...)

        return bytes, nil</span>
}

// ToJson converts a byte slice representation of an XChainBridge object to its json representation.
// It returns an error if the bytes are not valid or if the classic addresses are not valid.
func (x *XChainBridge) ToJson(p interfaces.BinaryParser, opts ...int) (any, error) <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                return nil, ErrNoLengthPrefix
        }</span>

        <span class="cov8" title="1">bytes, err := p.ReadBytes(opts[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ErrReadBytes{}
        }</span>

        <span class="cov8" title="1">json := make(map[string]string)

        json["LockingChainDoor"] = addresscodec.Encode(bytes[:20], []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength)
        json["LockingChainIssue"] = addresscodec.Encode(bytes[20:40], []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength)
        json["IssuingChainDoor"] = addresscodec.Encode(bytes[40:60], []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength)
        json["IssuingChainIssue"] = addresscodec.Encode(bytes[60:80], []byte{addresscodec.AccountAddressPrefix}, addresscodec.AccountAddressLength)

        return json, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package keypairs

import (
        "encoding/hex"
        "fmt"

        "github.com/Peersyst/xrpl-go/pkg/crypto"
)

// -------------------------------------------------------------------------------------------------
// ERRORS
// -------------------------------------------------------------------------------------------------

type CryptoImplementationError struct{}

func (e *CryptoImplementationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintln("not a valid crypto implementation")
}</span>

// -------------------------------------------------------------------------------------------------
// FUNCTIONS
// -------------------------------------------------------------------------------------------------

// GetCryptoImplementationFromKey returns the CryptoImplementation based on the key
func getCryptoImplementationFromKey(k string) CryptoImplementation <span class="cov8" title="1">{
        prefix, err := hex.DecodeString(k[:2])
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if ed25519 := crypto.ED25519(); prefix[0] == ed25519.Prefix() </span><span class="cov8" title="1">{
                return ed25519
        }</span>
        <span class="cov0" title="0">if secp256k1 := crypto.SECP256K1(); prefix[0] == secp256k1.Prefix() </span><span class="cov0" title="0">{
                return secp256k1
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package keypairs

import (
        "crypto/rand"

        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        "github.com/Peersyst/xrpl-go/pkg/random"
)

var r random.Randomizer

const (
        VERIFICATIONMESSAGE = "This test message should verify."
)

func init() <span class="cov8" title="1">{
        r.Reader = rand.Reader
}</span>

func GenerateSeed(entropy string, alg CryptoImplementation) (string, error) <span class="cov8" title="1">{
        var pe []byte
        if entropy == "" </span><span class="cov8" title="1">{
                b, err := r.GenerateBytes(addresscodec.FamilySeedLength)
                pe = b
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        } else<span class="cov8" title="1"> {
                pe = []byte(entropy)[:addresscodec.FamilySeedLength]
        }</span>
        <span class="cov8" title="1">return addresscodec.EncodeSeed(pe, alg)</span>
}

// Derives a keypair from a given seed. Returns a tuple of private key and public key
func DeriveKeypair(seed string, validator bool) (private, public string, err error) <span class="cov8" title="1">{
        ds, alg, err := addresscodec.DecodeSeed(seed)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">private, public, err = alg.DeriveKeypair(ds, validator)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">signature, err := alg.Sign(VERIFICATIONMESSAGE, private)

        if !alg.Validate(VERIFICATIONMESSAGE, public, signature) </span><span class="cov0" title="0">{
                return "", "", &amp;InvalidSignatureError{}
        }</span>
        <span class="cov8" title="1">return</span>
}

func DeriveClassicAddress(pubkey string) (string, error) <span class="cov8" title="1">{
        return addresscodec.EncodeClassicAddressFromPublicKeyHex(pubkey)
}</span>

func Sign(msg, privKey string) (string, error) <span class="cov8" title="1">{
        alg := getCryptoImplementationFromKey(privKey)
        if alg == nil </span><span class="cov0" title="0">{
                return "", &amp;CryptoImplementationError{}
        }</span>
        <span class="cov8" title="1">return alg.Sign(msg, privKey)</span>
}

func Validate(msg, pubKey, sig string) (bool, error) <span class="cov8" title="1">{
        alg := getCryptoImplementationFromKey(pubKey)
        if alg == nil </span><span class="cov0" title="0">{
                return false, &amp;CryptoImplementationError{}
        }</span>
        <span class="cov8" title="1">return alg.Validate(msg, pubKey, sig), nil</span>
}

type InvalidSignatureError struct{}

func (e *InvalidSignatureError) Error() string <span class="cov0" title="0">{
        return "derived keypair did not generate verifiable signature"
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package bigdecimal

import (
        "errors"
        "fmt"
        "math/big"
        "regexp"
        "strconv"
        "strings"
)

const (
        AllowedCharacters = "0123456789.-eE"
        BigDecRegEx       = "-?(?:[0|1-9]\\d*)(?:\\.\\d+)?(?:[eE][+\\-]?\\d+)?"
)

var (
        ErrInvalidCharacter = fmt.Errorf("value contains invalid characters. Only the following are allowed: %q", AllowedCharacters)
        ErrInvalidZeroValue = errors.New("value cannot be zero")
        ErrInvalidScale     = errors.New("scale too large")
)

type BigDecimal struct {
        Scale         int
        Precision     int
        UnscaledValue string
        Sign          int // 1 for negative, 0 for positive
}

func (bd *BigDecimal) GetScaledValue() string <span class="cov8" title="1">{
        unscaled, _ := new(big.Float).SetString(bd.UnscaledValue)

        scalingFactor := new(big.Float).SetFloat64(1)
        for i := 0; i &lt; abs(bd.Scale); i++ </span><span class="cov8" title="1">{
                scalingFactor.Mul(scalingFactor, big.NewFloat(10))
        }</span>

        <span class="cov8" title="1">var scaledValue *big.Float
        if bd.Scale &gt;= 0 </span><span class="cov8" title="1">{
                scaledValue = new(big.Float).Mul(unscaled, scalingFactor)
        }</span> else<span class="cov8" title="1"> {
                scaledValue = new(big.Float).Quo(unscaled, scalingFactor)
        }</span>

        <span class="cov8" title="1">if bd.Sign == 1 </span><span class="cov8" title="1">{
                scaledValue.Neg(scaledValue)
        }</span>
        <span class="cov8" title="1">return strings.TrimSuffix(strings.TrimRight(scaledValue.Text('f', bd.Scale), "0"), ".")</span>
}

func abs(x int) int <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

// Creates a new custom BigDecimal object from a value string
func NewBigDecimal(value string) (bd *BigDecimal, err error) <span class="cov8" title="1">{

        // check if the value string contains only allowed characters
        if !bigDecimalRegEx(value) </span><span class="cov8" title="1">{
                return nil, ErrInvalidCharacter
        }</span>

        <span class="cov8" title="1">v := strings.ToLower(value)
        bd = new(BigDecimal)

        // check if the value is negative and set the sign accordingly
        bd.Sign, v = handleSign(v)

        // check if the value contains the 'e' character and split the string into prefix and suffix accordingly
        p, s, eFound := strings.Cut(v, "e")

        // if the prefix without trailing &amp; leading zeros is empty or only contains a decimal character, return an error
        trimP := strings.Trim(p, "0")
        if trimP == "" || trimP == "." </span><span class="cov8" title="1">{
                return nil, ErrInvalidZeroValue
        }</span>

        // if the value contains the 'e' character, call the appropriate function to get the scale and unscaled value
        <span class="cov8" title="1">if eFound </span><span class="cov8" title="1">{
                bd.Scale, bd.UnscaledValue = getScaleAndUnscaledValWithE(p, s)
        }</span> else<span class="cov8" title="1"> {
                bd.Scale, bd.UnscaledValue = getScaleAndUnscaledValNoE(p, s)
        }</span>

        <span class="cov8" title="1">if bd.UnscaledValue == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidZeroValue
        }</span>

        <span class="cov8" title="1">bd.Precision = len(bd.UnscaledValue)
        return</span>
}

func getScaleAndUnscaledValNoE(p, s string) (sc int, uv string) <span class="cov8" title="1">{

        // check if the value contains a decimal character and split the string into prefix and suffix accordingly
        decP, decS, decFound := strings.Cut(p, ".")
        if decFound </span><span class="cov8" title="1">{
                return valHasDecimal(0, decP, decS)
        }</span> else<span class="cov8" title="1"> {
                return valNoDecimalNoE(0, p, decP)
        }</span>
}

func getScaleAndUnscaledValWithE(p, s string) (sc int, uv string) <span class="cov8" title="1">{
        // check if the value contains a decimal character and split the string into prefix and suffix accordingly
        decP, decS, decFound := strings.Cut(p, ".")
        sc, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ""
        }</span>
        <span class="cov8" title="1">if decFound </span><span class="cov8" title="1">{
                return valHasDecimal(sc, decP, decS)
        }</span> else<span class="cov8" title="1"> {
                return valNoDecimalHasE(sc, p, decP)
        }</span>
}

func valHasDecimal(scale int, decP, decS string) (sc int, uv string) <span class="cov8" title="1">{
        uv = strings.Trim((decP + decS), "0")
        sc = scale - len(strings.TrimRight(decS, "0"))
        if strings.TrimRight(decS, "0") == "" </span><span class="cov8" title="1">{
                sc = scale + len(strings.TrimLeft(decP, "0")) - len(uv)
        }</span>
        <span class="cov8" title="1">return</span>
}

func valNoDecimalNoE(scale int, prefix, decP string) (sc int, uv string) <span class="cov8" title="1">{
        uv = strings.Trim(decP, "0")
        sc = len(prefix) - len(strings.TrimRight(decP, "0"))
        return
}</span>

func valNoDecimalHasE(scale int, prefix, decP string) (sc int, uv string) <span class="cov8" title="1">{
        uv = strings.Trim(prefix, "0")
        sc = scale + len(strings.TrimLeft(prefix, "0")) - len(uv)
        return

}</span>

func handleSign(value string) (int, string) <span class="cov8" title="1">{
        if strings.HasPrefix(value, "-") </span><span class="cov8" title="1">{
                return 1, strings.TrimPrefix(value, "-")
        }</span>
        <span class="cov8" title="1">return 0, value</span>
}

func bigDecimalRegEx(value string) bool <span class="cov8" title="1">{
        r := regexp.MustCompile(BigDecRegEx)
        m := r.FindAllString(value, -1)
        return len(m) == 1
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package crypto

import (
        "encoding/hex"
        "errors"
        "fmt"
        "math/big"
        "strings"
)

// DERHexFromSig converts r and s hex strings to a DER-encoded signature hex string.
// It returns the DER-encoded signature as a hex string and an error if any occurred during the process.
func DERHexFromSig(rHex, sHex string) (string, error) <span class="cov8" title="1">{
        // Helper function to add leading zero if first byte has negative bit enabled
        slice := func(s string) string </span><span class="cov8" title="1">{
                if len(s) &gt; 0 &amp;&amp; (s[0] &gt;= '8' &amp;&amp; s[0] &lt;= 'f') </span><span class="cov8" title="1">{
                        return "00" + s
                }</span>
                <span class="cov8" title="1">return s</span>
        }

        // Helper function to ensure even-length hex string
        <span class="cov8" title="1">ensureEven := func(s string) string </span><span class="cov8" title="1">{
                if len(s)%2 != 0 </span><span class="cov8" title="1">{
                        return "0" + s
                }</span>
                <span class="cov8" title="1">return s</span>
        }

        // Convert hex strings to big.Int
        <span class="cov8" title="1">r, ok := new(big.Int).SetString(rHex, 16)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New("invalid r hex string: " + rHex)
        }</span>
        <span class="cov8" title="1">s, ok := new(big.Int).SetString(sHex, 16)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New("invalid s hex string: " + sHex)
        }</span>

        // Convert r and s to sliced hex strings
        <span class="cov8" title="1">rStr := slice(ensureEven(r.Text(16)))
        sStr := slice(ensureEven(s.Text(16)))

        rLen := len(rStr) / 2
        sLen := len(sStr) / 2

        // Convert lengths to hex
        rLenHex := ensureEven(fmt.Sprintf("%x", rLen))
        sLenHex := ensureEven(fmt.Sprintf("%x", sLen))

        // Calculate total length
        totalLen := rLen + sLen + 4
        totalLenHex := ensureEven(fmt.Sprintf("%x", totalLen))

        // Construct the final hex string
        result := strings.Join([]string{
                "30", totalLenHex,
                "02", rLenHex, rStr,
                "02", sLenHex, sStr,
        }, "")

        return result, nil</span>
}

// parseInt parses an integer from DER-encoded data.
// It returns a *big.Int representing the parsed integer, a byte slice containing the remaining data after parsing,
// and an error if any occurred during parsing.
func parseInt(data []byte) (*big.Int, []byte, error) <span class="cov8" title="1">{
        if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid DER: not enough data")
        }</span>
        <span class="cov8" title="1">if data[0] != 0x02 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid DER: expected integer tag")
        }</span>
        <span class="cov8" title="1">length := int(data[1])
        if len(data) &lt; 2+length </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid DER: not enough data")
        }</span>
        <span class="cov8" title="1">number := new(big.Int).SetBytes(data[2 : 2+length])
        return number, data[2+length:], nil</span>
}

// DERHexToSig converts a DER-encoded signature hex string to r and s byte slices.
// It returns the r and s byte slices and an error if any occurred during the process.
func DERHexToSig(hexSignature string) ([]byte, []byte, error) <span class="cov8" title="1">{
        data, err := hex.DecodeString(hexSignature)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("invalid hex string: %v", err)
        }</span>

        <span class="cov8" title="1">if len(data) &lt; 2 || data[0] != 0x30 </span><span class="cov8" title="1">{
                return nil, nil, errors.New("invalid signature tag")
        }</span>
        <span class="cov8" title="1">if int(data[1]) != len(data)-2 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid signature: incorrect length")
        }</span>

        <span class="cov8" title="1">r, sBytes, err := parseInt(data[2:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid signature: incorrect length")
        }</span>

        <span class="cov8" title="1">s, leftover, err := parseInt(sBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid signature: incorrect length")
        }</span>

        <span class="cov8" title="1">if len(leftover) &gt; 0 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid signature: left bytes after parsing")
        }</span>

        <span class="cov8" title="1">return r.Bytes(), s.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package crypto

import (
        "bytes"
        "crypto/ed25519"
        "encoding/hex"
        "strings"
)

const (
        ed25519Prefix = 0xED
)

type ed25519CryptoAlgorithm CryptoAlgorithm

func ED25519() ed25519CryptoAlgorithm <span class="cov8" title="1">{
        return ed25519CryptoAlgorithm{
                prefix: ed25519Prefix,
        }
}</span>

func (c ed25519CryptoAlgorithm) Prefix() byte <span class="cov0" title="0">{
        return c.prefix
}</span>

func (c ed25519CryptoAlgorithm) FamilySeedPrefix() byte <span class="cov0" title="0">{
        return c.familySeedPrefix
}</span>

func (c ed25519CryptoAlgorithm) DeriveKeypair(decodedSeed []byte, validator bool) (string, string, error) <span class="cov8" title="1">{
        if validator </span><span class="cov8" title="1">{
                return "", "", &amp;ed25519ValidatorError{}
        }</span>
        <span class="cov8" title="1">rawPriv := Sha512Half(decodedSeed)
        pubKey, privKey, err := ed25519.GenerateKey(bytes.NewBuffer(rawPriv))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">pubKey = append([]byte{c.prefix}, pubKey...)
        public := strings.ToUpper(hex.EncodeToString(pubKey))
        privKey = append([]byte{c.prefix}, privKey...)
        private := strings.ToUpper(hex.EncodeToString(privKey[:32+len([]byte{c.prefix})]))
        return private, public, nil</span>
}

func (c ed25519CryptoAlgorithm) Sign(msg, privKey string) (string, error) <span class="cov8" title="1">{
        b, err := hex.DecodeString(privKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">rawPriv := ed25519.NewKeyFromSeed(b[1:])
        signedMsg := ed25519.Sign(rawPriv, []byte(msg))
        return strings.ToUpper(hex.EncodeToString(signedMsg)), nil</span>
}

func (c ed25519CryptoAlgorithm) Validate(msg, pubkey, sig string) bool <span class="cov8" title="1">{
        bp, err := hex.DecodeString(pubkey)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">bs, err := hex.DecodeString(sig)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return ed25519.Verify(ed25519.PublicKey(bp[1:]), []byte(msg), bs)</span>
}

type ed25519ValidatorError struct{}

func (e *ed25519ValidatorError) Error() string <span class="cov8" title="1">{
        return "validator keypairs can not use Ed25519"
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package crypto

import (
        "crypto/sha512"
        "encoding/hex"
        "errors"
        "math/big"
        "strings"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/decred/dcrd/dcrec/secp256k1/v4"
        ecdsa "github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa"
)

const (
        // SECP256K1 prefix - value is 0
        secp256K1Prefix = 0x00
        // SECP256K1 family seed prefix - value is 33
        secp256K1FamilySeedPrefix = 0x21
)

type secp256K1CryptoAlgorithm CryptoAlgorithm

func SECP256K1() secp256K1CryptoAlgorithm <span class="cov8" title="1">{
        return secp256K1CryptoAlgorithm{
                prefix:           secp256K1Prefix,
                familySeedPrefix: secp256K1FamilySeedPrefix,
        }
}</span>

func (c secp256K1CryptoAlgorithm) Prefix() byte <span class="cov0" title="0">{
        return c.prefix
}</span>

func (c secp256K1CryptoAlgorithm) FamilySeedPrefix() byte <span class="cov0" title="0">{
        return c.familySeedPrefix
}</span>

func (c secp256K1CryptoAlgorithm) deriveScalar(bytes []byte, discrim *big.Int) *big.Int <span class="cov8" title="1">{

        order := btcec.S256().N
        for i := 0; i &lt;= 0xffffffff; i++ </span><span class="cov8" title="1">{
                hash := sha512.New()

                hash.Write(bytes)

                if discrim != nil </span><span class="cov8" title="1">{
                        discrimBytes := make([]byte, 4)
                        bytes[0] = byte(uint32(discrim.Uint64()))
                        bytes[1] = byte(uint32(discrim.Uint64()) &gt;&gt; 8)
                        bytes[2] = byte(uint32(discrim.Uint64()) &gt;&gt; 16)
                        bytes[3] = byte(uint32(discrim.Uint64()) &gt;&gt; 24)

                        hash.Write(discrimBytes)
                }</span>

                <span class="cov8" title="1">shiftBytes := make([]byte, 4)
                bytes[0] = byte(uint32(i))
                bytes[1] = byte(uint32(i) &gt;&gt; 8)
                bytes[2] = byte(uint32(i) &gt;&gt; 16)
                bytes[3] = byte(uint32(i) &gt;&gt; 24)

                hash.Write(shiftBytes)

                key := new(big.Int).SetBytes(hash.Sum(nil)[:32])

                if key.Cmp(big.NewInt(0)) &gt; 0 &amp;&amp; key.Cmp(order) &lt; 0 </span><span class="cov8" title="1">{
                        return key
                }</span>
        }
        // This error is practically impossible to reach.
        // The order of the curve describes the (finite) amount of points on the curve.
        <span class="cov0" title="0">panic("impossible unicorn ;)")</span>
}

func (c secp256K1CryptoAlgorithm) DeriveKeypair(seed []byte, validator bool) (string, string, error) <span class="cov8" title="1">{
        curve := btcec.S256()
        order := curve.N

        privateGen := c.deriveScalar(seed, nil)

        if validator </span><span class="cov8" title="1">{
                return "", "", errors.New("validator keypair derivation not supported")
        }</span>

        <span class="cov8" title="1">rootPrivateKey, _ := btcec.PrivKeyFromBytes(privateGen.Bytes())

        derivatedScalar := c.deriveScalar(rootPrivateKey.PubKey().SerializeCompressed(), big.NewInt(0))
        scalarWithPrivateGen := derivatedScalar.Add(derivatedScalar, privateGen)
        privateKey := scalarWithPrivateGen.Mod(scalarWithPrivateGen, order)

        privKeyBytes := privateKey.Bytes()
        private := strings.ToUpper(hex.EncodeToString(privKeyBytes))

        _, pubKey := btcec.PrivKeyFromBytes(privKeyBytes)

        pubKeyBytes := pubKey.SerializeCompressed()

        return "00" + private, strings.ToUpper(hex.EncodeToString(pubKeyBytes)), nil</span>
}

func (c secp256K1CryptoAlgorithm) Sign(msg, privKey string) (string, error) <span class="cov8" title="1">{
        if len(privKey) != 64 &amp;&amp; len(privKey) != 66 </span><span class="cov8" title="1">{
                return "", errors.New("invalid private key")
        }</span>
        <span class="cov8" title="1">if len(msg) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("message is required")
        }</span>

        <span class="cov8" title="1">if len(privKey) == 66 </span><span class="cov8" title="1">{
                privKey = privKey[2:]
        }</span>
        <span class="cov8" title="1">key, err := hex.DecodeString(privKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">secpPrivKey := secp256k1.PrivKeyFromBytes(key)
        sig := ecdsa.Sign(secpPrivKey, Sha512Half([]byte(msg)))

        parsedSig, err := DERHexFromSig(sig.R().String(), sig.S().String())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(parsedSig), nil</span>
}

func (c secp256K1CryptoAlgorithm) Validate(msg, pubkey, sig string) bool <span class="cov8" title="1">{
        // Decode the signature from DERHex to a hex string
        r, s, err := DERHexToSig(sig)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Convert r and s slices to [32]byte arrays
        <span class="cov8" title="1">var rBytes, sBytes [32]byte

        copy(rBytes[32-len(r):], r)
        copy(sBytes[32-len(s):], s)

        ecdsaR := &amp;secp256k1.ModNScalar{}
        ecdsaS := &amp;secp256k1.ModNScalar{}

        ecdsaR.SetBytes(&amp;rBytes)
        ecdsaS.SetBytes(&amp;sBytes)

        parsedSig := ecdsa.NewSignature(ecdsaR, ecdsaS)
        // Hash the message
        hash := Sha512Half([]byte(msg))

        // Decode the pubkey from hex to a byte slice
        pubkeyBytes, err := hex.DecodeString(pubkey)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Verify the signature
        <span class="cov8" title="1">pubKey, err := secp256k1.ParsePubKey(pubkeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return parsedSig.Verify(hash, pubKey)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package crypto

import "crypto/sha512"

// Returns the first 32 bytes of a sha512 hash of a message
func Sha512Half(msg []byte) []byte <span class="cov8" title="1">{
        h := sha512.Sum512(msg)
        return h[:32]
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package crypto

type CryptoAlgorithm struct {
        prefix           uint8
        familySeedPrefix uint8
}

func (c CryptoAlgorithm) Prefix() uint8 <span class="cov0" title="0">{
        return c.prefix
}</span>

func (c CryptoAlgorithm) FamilySeedPrefix() uint8 <span class="cov0" title="0">{
        return c.familySeedPrefix
}</span>

func (c CryptoAlgorithm) DeriveKeypair(decodedSeed []byte, validator bool) (string, string, error) <span class="cov0" title="0">{
        return "", "", nil
}</span>

func (c CryptoAlgorithm) Sign(msg, privKey string) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (c CryptoAlgorithm) Validate(msg, pubkey, sig string) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package maputils

// GetKeys returns the keys of the given map.
func GetKeys(m map[string]interface{}) []string <span class="cov8" title="1">{
        keys := make([]string, 0, len(m))
        for key := range m </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">return keys</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package random

import "io"

type Randomizer struct {
        io.Reader
}

func (r *Randomizer) GenerateBytes(n int) ([]byte, error) <span class="cov8" title="1">{
        b := make([]byte, n)
        _, err := r.Read(b) //nolint
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package typecheck

import (
        "regexp"
        "strconv"
)

// IsString checks if the given interface is a string.
func IsString(str interface{}) bool <span class="cov8" title="1">{
        _, ok := str.(string)
        return ok
}</span>

// IsUint32 checks if the given interface is a uint32.
func IsUint32(num interface{}) bool <span class="cov8" title="1">{
        _, ok := num.(uint32)
        return ok
}</span>

// IsUint64 checks if the given interface is a uint64.
func IsUint64(num interface{}) bool <span class="cov8" title="1">{
        _, ok := num.(uint64)
        return ok
}</span>

// IsUint checks if the given interface is a uint.
func IsUint(num interface{}) bool <span class="cov8" title="1">{
        _, ok := num.(uint)
        return ok
}</span>

// IsInt checks if the given interface is an int.
func IsInt(num interface{}) bool <span class="cov8" title="1">{
        _, ok := num.(int)
        return ok
}</span>

// IsBool checks if the given interface is a bool.
func IsBool(b interface{}) bool <span class="cov8" title="1">{
        _, ok := b.(bool)
        return ok
}</span>

// IsHex checks if the given string is a valid hexadecimal string.
func IsHex(s string) bool <span class="cov8" title="1">{
        // Define a regular expression for a valid hexadecimal string
        var validHexPattern = regexp.MustCompile(`^[0-9a-fA-F]+$`)
        return validHexPattern.MatchString(s)
}</span>

// Checks if the given string is a valid number (Float32).
func IsFloat32(s string) bool <span class="cov8" title="1">{
        _, err := strconv.ParseFloat(s, 32)
        return err == nil
}</span>

// Checks if the given string is a valid number (Float64).
func IsFloat64(s string) bool <span class="cov8" title="1">{
        _, err := strconv.ParseFloat(s, 64)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package currency

import (
        "errors"
        "strconv"
        "strings"
)

const (
        DROPS_PER_XRP          float64 = 1000000
        MAX_FRACTION_LENGTH    uint    = 6
        NATIVE_CURRENCY_SYMBOL string  = "XRP"
)

// Convert an amount in XRP to an amount in drops.
func XrpToDrops(value string) (string, error) <span class="cov8" title="1">{
        if i := strings.IndexByte(value, '.'); i != -1 &amp;&amp; len(value[i+1:]) &gt; int(MAX_FRACTION_LENGTH) </span><span class="cov8" title="1">{
                return "", errors.New("xrp to drops: value has too many decimals")
        }</span>

        <span class="cov8" title="1">xrpFloat, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">dropsFloat := xrpFloat * DROPS_PER_XRP
        return strconv.FormatFloat(dropsFloat, 'f', -1, 64), nil</span>

}

// Convert an amount of drops into an amount of xrp
func DropsToXrp(value string) (string, error) <span class="cov8" title="1">{
        dropUint, err := strconv.ParseUint(value, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">xrpFloat := float64(dropUint) / DROPS_PER_XRP

        return strconv.FormatFloat(xrpFloat, 'f', -1, 64), nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package currency

import (
        "encoding/hex"
        "strings"
)

// CurrencyStringToHex converts a string to a hexadecimal representation
// with trailing zeros up to a length of 40 characters.
// This is to support the non-standard currency codes for the XRPL.
// See https://xrpl.org/docs/references/protocol/data-types/currency-formats#nonstandard-currency-codes
func CurrencyStringToHex(input string) string <span class="cov8" title="1">{
        // non-standard currency codes are for currencies with more than 3 characters
        if len(input) &lt;= 3 </span><span class="cov8" title="1">{
                return input
        }</span>

        // Convert the string to bytes
        <span class="cov8" title="1">bytes := []byte(input)

        // Convert bytes to hexadecimal representation
        hexString := hex.EncodeToString(bytes)

        // Pad end the hex string with trailing zeros up to a length of 40 characters
        hexString = padEnd(hexString, 40, "0")

        return hexString</span>
}

// CurrencyHexToString converts a hexadecimal to a string.
// This functions removes the null bytes from the string which come from the non-standard currency codes for the XRPL.
// See https://xrpl.org/docs/references/protocol/data-types/currency-formats#nonstandard-currency-codes
func CurrencyHexToString(input string) (string, error) <span class="cov8" title="1">{
        // Convert the hexadecimal representation to bytes
        bytes, err := hex.DecodeString(input)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Remove null bytes from the byte slice
        <span class="cov8" title="1">trimmedBytes := bytes[:bytesIndex(bytes, 0)]

        // Convert bytes to string
        str := string(trimmedBytes)

        return str, nil</span>
}

// bytesIndex returns the index of the first occurrence of the given value in the byte slice.
// If the value is not found, it returns the length of the slice.
func bytesIndex(slice []byte, value byte) int <span class="cov8" title="1">{
        for i, v := range slice </span><span class="cov8" title="1">{
                if v == value </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return len(slice)</span>
}

// padEnd pads the string `s` with the character `padChar` on the right until it reaches `length`.
func padEnd(s string, length int, padChar string) string <span class="cov8" title="1">{
        if len(s) &gt;= length </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">padding := strings.Repeat(padChar, length-len(s))
        return s + padding</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package hash

import (
        "encoding/binary"
        "encoding/hex"
        "errors"
        "strings"

        binarycodec "github.com/Peersyst/xrpl-go/binary-codec"
        "github.com/Peersyst/xrpl-go/pkg/crypto"
)

// HashTxBlob hashes a signed transaction blob
// It takes a transaction blob and returns the hash of the signed transaction.
// It returns an error if the transaction blob is invalid.
func HashTxBlob(txBlob string) (string, error) <span class="cov8" title="1">{
        tx, err := binarycodec.Decode(txBlob)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if the transaction has at least one of the required fields
        <span class="cov8" title="1">hasTxnSignature := tx["TxnSignature"] != nil
        hasSigners := tx["Signers"] != nil
        hasSigningPubKey := tx["SigningPubKey"] != nil

        if !hasTxnSignature &amp;&amp; !hasSigners &amp;&amp; !hasSigningPubKey </span><span class="cov8" title="1">{
                return "", errors.New("transaction must have at least one of TxnSignature, Signers, or SigningPubKey")
        }</span>

        // Create a byte slice with the correct capacity
        <span class="cov8" title="1">payload := make([]byte, 4+len(txBlob)/2)

        // Convert TRANSACTION_PREFIX to big-endian bytes
        binary.BigEndian.PutUint32(payload[:4], TRANSACTION_PREFIX)

        // Decode the txBlob into the rest of the payload
        _, err = hex.Decode(payload[4:], []byte(txBlob))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.ToUpper(hex.EncodeToString(crypto.Sha512Half(payload))), nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package ledger

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountRoot struct {
        Account           types.Address
        AccountTxnID      types.Hash256           `json:",omitempty"`
        Balance           types.XRPCurrencyAmount `json:",omitempty"`
        BurnedNFTokens    uint32                  `json:",omitempty"`
        Domain            string                  `json:",omitempty"`
        EmailHash         types.Hash128           `json:",omitempty"`
        Flags             uint64
        LedgerEntryType   LedgerEntryType
        MessageKey        string        `json:",omitempty"`
        MintedNFTokens    uint32        `json:",omitempty"`
        NFTokenMinter     types.Address `json:",omitempty"`
        OwnerCount        uint64
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint64
        RegularKey        types.Address `json:",omitempty"`
        Sequence          uint64
        TicketCount       uint32 `json:",omitempty"`
        TickSize          uint8  `json:",omitempty"`
        TransferRate      uint32 `json:",omitempty"`
        // TODO determine if this is a required field
        //Index             types.Hash256 `json:"index,omitempty"`
}

func (*AccountRoot) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return AccountRootEntry
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package ledger

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type Amendments struct {
        Amendments      []types.Hash256 `json:",omitempty"`
        Flags           uint
        LedgerEntryType LedgerEntryType
        Majorities      []MajorityEntry `json:",omitempty"`
}

func (*Amendments) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return AmendmentsEntry
}</span>

type MajorityEntry struct {
        Majority Majority
}

type Majority struct {
        Amendment types.Hash256
        CloseTime uint
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package ledger

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// An AMM ledger entry describes a single Automated Market Maker (AMM) instance.
// This is always paired with a special AccountRoot entry. https://xrpl.org/docs/references/protocol/ledger-data/ledger-entry-types/amm#amm
//
// Example:
//
//        {
//            "Account" : "rE54zDvgnghAoPopCgvtiqWNq3dU5y836S",
//            "Asset" : {
//              "currency" : "XRP"
//            },
//            "Asset2" : {
//              "currency" : "TST",
//              "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd"
//            },
//            "AuctionSlot" : {
//              "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//              "AuthAccounts" : [
//                  {
//                    "AuthAccount" : {
//                        "Account" : "rMKXGCbJ5d8LbrqthdG46q3f969MVK2Qeg"
//                    }
//                  },
//                  {
//                    "AuthAccount" : {
//                        "Account" : "rBepJuTLFJt3WmtLXYAxSjtBWAeQxVbncv"
//                    }
//                  }
//              ],
//              "DiscountedFee" : 60,
//              "Expiration" : 721870180,
//              "Price" : {
//                  "currency" : "039C99CD9AB0B70B32ECDA51EAAE471625608EA2",
//                  "issuer" : "rE54zDvgnghAoPopCgvtiqWNq3dU5y836S",
//                  "value" : "0.8696263565463045"
//              }
//            },
//            "Flags" : 0,
//            "LPTokenBalance" : {
//              "currency" : "039C99CD9AB0B70B32ECDA51EAAE471625608EA2",
//              "issuer" : "rE54zDvgnghAoPopCgvtiqWNq3dU5y836S",
//              "value" : "71150.53584131501"
//            },
//            "TradingFee" : 600,
//            "VoteSlots" : [
//              {
//                  "VoteEntry" : {
//                    "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//                    "TradingFee" : 600,
//                    "VoteWeight" : 100000
//                  }
//              }
//            ]
//        }
type AMM struct {
        LedgerEntryCommonFields
        // The address of the special account that holds this AMM's assets.
        Account types.Address
        // The definition for one of the two assets this AMM holds. In JSON, this is an object with currency and issuer fields.
        Asset Asset
        // The definition for the other asset this AMM holds. In JSON, this is an object with currency and issuer fields.
        Asset2 Asset
        // Details of the current owner of the auction slot, as an Auction Slot object.
        AuctionSlot AuctionSlot `json:",omitempty"`
        // The total outstanding balance of liquidity provider tokens from this AMM instance.
        // The holders of these tokens can vote on the AMM's trading fee in proportion to their holdings, or redeem the tokens for a share of the AMM's assets which grows with the trading fees collected.
        LPTokenBalance types.CurrencyAmount
        // The percentage fee to be charged for trades against this AMM instance, in units of 1/100,000. The maximum value is 1000, for a 1% fee.
        TradingFee uint16
        // A list of vote objects, representing votes on the pool's trading fee.
        VoteSlots []VoteSlots `json:",omitempty"`
}

// ---------------------------------------------
// Asset Object
// ---------------------------------------------

// The definition for one of the two assets the AMM holds.
// In JSON, this is an object with currency and issuer fields.
type Asset struct {
        Currency string        `json:"currency"`
        Issuer   types.Address `json:"issuer,omitempty"`
}

func (a *Asset) Flatten() map[string]interface{} <span class="cov8" title="1">{
        flattened := make(map[string]interface{})

        if a.Issuer != "" </span><span class="cov8" title="1">{
                flattened["issuer"] = a.Issuer
        }</span>

        <span class="cov8" title="1">if a.Currency != "" </span><span class="cov8" title="1">{
                flattened["currency"] = a.Currency
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

// ---------------------------------------------
// Auction Slot Object
// ---------------------------------------------

// A liquidity provider can bid LP Tokens to claim the auction slot to receive a discount on the trading fee for a 24-hour period.
// The LP tokens that were bid are returned to the AMM.
type AuctionSlot struct {
        // The current owner of this auction slot.
        Account types.Address
        // A list of at most 4 additional accounts that are authorized to trade at the discounted fee for this AMM instance.
        AuthAccounts []AuthAccounts `json:",omitempty"`
        // The trading fee to be charged to the auction owner, in the same format as TradingFee. Normally, this is 1/10 of the normal fee for this AMM.
        DiscountedFee uint32
        // The amount the auction owner paid to win this slot, in LP Tokens.
        Price types.CurrencyAmount
        // The time when this slot expires, in seconds since the Ripple Epoch. https://xrpl.org/docs/references/protocol/data-types/basic-data-types#specifying-time.
        Expiration uint32
}

// ---------------------------------------------
// AuthAccounts Object
// ---------------------------------------------

// A list of up to 4 additional accounts that you allow to trade at the discounted fee.
// This cannot include the address of the transaction sender.
type AuthAccounts struct {
        AuthAccount AuthAccount
}

func (a *AuthAccounts) Flatten() map[string]interface{} <span class="cov8" title="1">{
        flattened := make(map[string]interface{})
        flattened["AuthAccount"] = a.AuthAccount.Flatten()
        return flattened
}</span>

// An additional account that you allow to trade at the discounted fee.
type AuthAccount struct {
        // Authorized account to trade at the discounted fee for this AMM instance.
        Account types.Address
}

func (a *AuthAccount) Flatten() map[string]interface{} <span class="cov8" title="1">{
        flattened := make(map[string]interface{})
        flattened["Account"] = a.Account
        return flattened
}</span>

// ---------------------------------------------
// VoteSlots / Vote Entry Objects
// ---------------------------------------------

// Each entry in the vote_slots array represents one liquidity provider's vote to set the trading fee.
type VoteSlots struct {
        VoteEntry VoteEntry
}

// Represents one liquidity provider's vote to set the trading fee.
type VoteEntry struct {
        Account    types.Address
        TradingFee uint
        VoteWeight uint
}

func (*AMM) EntryType() LedgerEntryType <span class="cov8" title="1">{
        return AMMEntry
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

// The Bridge ledger entry represents a single cross-chain bridge that connects the XRP Ledger with
// another blockchain, such as its sidechain, and enables value in the form of XRP and other tokens (IOUs) to move efficiently between the two blockchains.
// Requires the XChainBridge amendment to be enabled.
// Example:
// ```json
//
//        {
//                "Account": "r3nCVTbZGGYoWvZ58BcxDmiMUU7ChMa1eC",
//                "Flags": 0,
//                "LedgerEntryType": "Bridge",
//                "MinAccountCreateAmount": "2000000000",
//                "OwnerNode": "0",
//                "PreviousTxnID": "67A8A1B36C1B97BE3AAB6B19CB3A3069034877DE917FD1A71919EAE7548E5636",
//                "PreviousTxnLgrSeq": 102,
//                "SignatureReward": "204",
//                "XChainAccountClaimCount": "0",
//                "XChainAccountCreateCount": "0",
//                "XChainBridge": {
//                        "IssuingChainDoor": "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh",
//                        "IssuingChainIssue": {
//                        "currency": "XRP"
//                        },
//                        "LockingChainDoor": "r3nCVTbZGGYoWvZ58BcxDmiMUU7ChMa1eC",
//                        "LockingChainIssue": {
//                        "currency": "XRP"
//                        }
//                },
//                "XChainClaimID": "1",
//                "index": "9F2C9E23343852036AFD323025A8506018ABF9D4DBAA746D61BF1CFB5C297D10"
//        }
//
// ```
type Bridge struct {
        // The account that submitted the XChainCreateBridge transaction on the blockchain.
        Account types.Address
        // The minimum amount, in XRP, required for an XChainAccountCreateCommit transaction.
        // If this isn't present, the XChainAccountCreateCommit transaction will fail.
        // This field can only be present on XRP-XRP bridges.
        MinAccountCreateAmount types.CurrencyAmount `json:",omitempty"`
        // The total amount, in XRP, to be rewarded for providing a signature for cross-chain transfer or for signing for the cross-chain reward. This amount will be split among the signers.
        SignatureReward types.CurrencyAmount
        // A counter used to order the execution of account create transactions.
        // It is incremented every time a XChainAccountCreateCommit transaction is "claimed" on the destination chain.
        // When the "claim" transaction is run on the destination chain, the XChainAccountClaimCount must match the value
        // that the XChainAccountCreateCount had at the time the XChainAccountClaimCount was run on the source chain.
        // This orders the claims so that they run in the same order that the XChainAccountCreateCommit transactions ran on the source chain, to prevent transaction replay.
        XChainAccountClaimCount uint64
        // A counter used to order the execution of account create transactions.
        // It is incremented every time a successful XChainAccountCreateCommit transaction is run for the source chain.
        XChainAccountCreateCount uint64
        // The door accounts and assets of the bridge this object correlates to.
        XChainBridge types.XChainBridge
        // The value of the next XChainClaimID to be created.
        XChainClaimID uint64
}

// EntryType returns the type of the ledger entry.
func (*Bridge) EntryType() LedgerEntryType <span class="cov8" title="1">{
        return BridgeEntry
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

// TODO verify format of SendMax
type Check struct {
        Account           types.Address
        Destination       types.Address
        DestinationNode   string `json:",omitempty"`
        DestinationTag    uint   `json:",omitempty"`
        Expiration        uint   `json:",omitempty"`
        Flags             uint
        InvoiceID         types.Hash256 `json:",omitempty"`
        LedgerEntryType   LedgerEntryType
        OwnerNode         string
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
        SendMax           string
        Sequence          uint
        SourceTag         uint `json:",omitempty"`
}

func (*Check) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return CheckEntry
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package ledger

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type DepositPreauthObj struct {
        Account           types.Address
        Authorize         types.Address
        Flags             uint
        LedgerEntryType   LedgerEntryType
        OwnerNode         string
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
}

func (*DepositPreauthObj) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return DepositPreauthObjEntry
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

// A DID ledger entry holds references to, or data associated with, a single DID.
// Requires the "did" amendment to be enabled.
// Example:
// ```json
//
//        {
//            "Account": "rpfqJrXg5uidNo2ZsRhRY6TiF1cvYmV9Fg",
//            "DIDDocument": "646F63",
//            "Data": "617474657374",
//            "Flags": 0,
//            "LedgerEntryType": "DID",
//            "OwnerNode": "0",
//            "PreviousTxnID": "A4C15DA185E6092DF5954FF62A1446220C61A5F60F0D93B4B09F708778E41120",
//            "PreviousTxnLgrSeq": 4,
//            "URI": "6469645F6578616D706C65",
//            "index": "46813BE38B798B3752CA590D44E7FEADB17485649074403AD1761A2835CE91FF"
//        }
//
// ```
type DID struct {
        // The account that controls the DID.
        Account types.Address
        // The W3C standard DID document associated with the DID.
        // The DIDDocument field isn't checked for validity and is limited to a maximum length of 256 bytes.
        DIDDocument string `json:",omitempty"`
        // The public attestations of identity credentials associated with the DID.
        // The Data field isn't checked for validity and is limited to a maximum length of 256 bytes.
        Data string `json:",omitempty"`
        // The value 0x0049, mapped to the string DID, indicates that this object is a DID object.
        LedgerEntryType string
        // A hint indicating which page of the sender's owner directory links to this entry, in case the directory consists of multiple pages.
        OwnerNode string
        // The identifying hash of the transaction that most recently modified this object.
        PreviousTxnID string
        // The index of the ledger that contains the transaction that most recently modified this object.
        PreviousTxnLgrSeq uint32
        // The Universal Resource Identifier that points to the corresponding DID document or the data associated with the DID.
        // This field can be an HTTP(S) URL or IPFS URI.
        // This field isn't checked for validity and is limited to a maximum length of 256 bytes.
        URI string `json:",omitempty"`
}

// EntryType returns the type of the ledger entry.
func (*DID) EntryType() LedgerEntryType <span class="cov8" title="1">{
        return DIDEntry
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package ledger

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type DirectoryNode struct {
        Flags             uint
        Indexes           []types.Hash256
        IndexNext         string `json:",omitempty"`
        IndexPrevious     string `json:",omitempty"`
        LedgerEntryType   LedgerEntryType
        Owner             types.Address `json:",omitempty"`
        RootIndex         types.Hash256
        TakerGetsCurrency string `json:",omitempty"`
        TakerGetsIssuer   string `json:",omitempty"`
        TakerPaysCurrency string `json:",omitempty"`
        TakerPaysIssuer   string `json:",omitempty"`
}

func (*DirectoryNode) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return DirectoryNodeEntry
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package ledger

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type Escrow struct {
        Account           types.Address
        Amount            types.XRPCurrencyAmount
        CancelAfter       uint   `json:",omitempty"`
        Condition         string `json:",omitempty"`
        Destination       types.Address
        DestinationNode   string `json:",omitempty"`
        DestinationTag    uint   `json:",omitempty"`
        FinishAfter       uint   `json:",omitempty"`
        Flags             uint
        LedgerEntryType   LedgerEntryType
        OwnerNode         string
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
        SourceTag         uint `json:",omitempty"`
}

func (*Escrow) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return EscrowEntry
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package ledger

type FeeSettings struct {
        BaseFee           string
        Flags             uint
        LedgerEntryType   LedgerEntryType
        ReferenceFeeUnits uint
        ReserveBase       uint
        ReserveIncrement  uint
}

func (*FeeSettings) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return FeeSettingsEntry
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type LedgerHashes struct {
        FirstLedgerSequence uint
        Flags               uint
        Hashes              []types.Hash256
        LastLedgerSequence  uint
        LedgerEntryType     LedgerEntryType
}

func (*LedgerHashes) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return LedgerHashesEntry
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package ledger

import (
        "encoding/json"
        "fmt"
)

type LedgerEntryType string

const (
        AccountRootEntry                     LedgerEntryType = "AccountRoot"
        AmendmentsEntry                      LedgerEntryType = "Amendments"
        AMMEntry                             LedgerEntryType = "AMM"
        BridgeEntry                          LedgerEntryType = "Bridge"
        CheckEntry                           LedgerEntryType = "Check"
        DepositPreauthObjEntry               LedgerEntryType = "DepositPreauth"
        DIDEntry                             LedgerEntryType = "DID"
        DirectoryNodeEntry                   LedgerEntryType = "DirectoryNode"
        EscrowEntry                          LedgerEntryType = "Escrow"
        FeeSettingsEntry                     LedgerEntryType = "FeeSettings"
        LedgerHashesEntry                    LedgerEntryType = "LedgerHashes"
        NegativeUNLEntry                     LedgerEntryType = "NegativeUNL"
        NFTokenOfferEntry                    LedgerEntryType = "NFTokenOffer"
        NFTokenPageEntry                     LedgerEntryType = "NFTokenPage"
        OfferEntry                           LedgerEntryType = "Offer"
        OracleEntry                          LedgerEntryType = "Oracle"
        PayChannelEntry                      LedgerEntryType = "PayChannel"
        RippleStateEntry                     LedgerEntryType = "RippleState"
        SignerListEntry                      LedgerEntryType = "SignerList"
        TicketEntry                          LedgerEntryType = "Ticket"
        XChainOwnedClaimIDEntry              LedgerEntryType = "XChainOwnedClaimID"
        XChainOwnedCreateAccountClaimIDEntry LedgerEntryType = "XChainOwnedCreateAccountClaimID"
)

type FlatLedgerObject map[string]interface{}

func (f FlatLedgerObject) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return LedgerEntryType(f["LedgerEntryType"].(string))
}</span>

type LedgerObject interface {
        EntryType() LedgerEntryType
}

func EmptyLedgerObject(t string) (LedgerObject, error) <span class="cov0" title="0">{
        switch LedgerEntryType(t) </span>{
        case AccountRootEntry:<span class="cov0" title="0">
                return &amp;AccountRoot{}, nil</span>
        case AmendmentsEntry:<span class="cov0" title="0">
                return &amp;Amendments{}, nil</span>
        case AMMEntry:<span class="cov0" title="0">
                return &amp;AMM{}, nil</span>
        case BridgeEntry:<span class="cov0" title="0">
                return &amp;Bridge{}, nil</span>
        case CheckEntry:<span class="cov0" title="0">
                return &amp;Check{}, nil</span>
        case DepositPreauthObjEntry:<span class="cov0" title="0">
                return &amp;DepositPreauthObj{}, nil</span>
        case DIDEntry:<span class="cov0" title="0">
                return &amp;DID{}, nil</span>
        case DirectoryNodeEntry:<span class="cov0" title="0">
                return &amp;DirectoryNode{}, nil</span>
        case EscrowEntry:<span class="cov0" title="0">
                return &amp;Escrow{}, nil</span>
        case FeeSettingsEntry:<span class="cov0" title="0">
                return &amp;FeeSettings{}, nil</span>
        case LedgerHashesEntry:<span class="cov0" title="0">
                return &amp;LedgerHashes{}, nil</span>
        case NegativeUNLEntry:<span class="cov0" title="0">
                return &amp;NegativeUNL{}, nil</span>
        case NFTokenOfferEntry:<span class="cov0" title="0">
                return &amp;NFTokenOffer{}, nil</span>
        case NFTokenPageEntry:<span class="cov0" title="0">
                return &amp;NFTokenPage{}, nil</span>
        case OfferEntry:<span class="cov0" title="0">
                return &amp;Offer{}, nil</span>
        case OracleEntry:<span class="cov0" title="0">
                return &amp;Oracle{}, nil</span>
        case PayChannelEntry:<span class="cov0" title="0">
                return &amp;PayChannel{}, nil</span>
        case RippleStateEntry:<span class="cov0" title="0">
                return &amp;RippleState{}, nil</span>
        case SignerListEntry:<span class="cov0" title="0">
                return &amp;SignerList{}, nil</span>
        case TicketEntry:<span class="cov0" title="0">
                return &amp;Ticket{}, nil</span>
        case XChainOwnedClaimIDEntry:<span class="cov0" title="0">
                return &amp;XChainOwnedClaimID{}, nil</span>
        case XChainOwnedCreateAccountClaimIDEntry:<span class="cov0" title="0">
                return &amp;XChainOwnedCreateAccountClaimID{}, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unrecognized LedgerObject type \"%s\"", t)</span>
}

func UnmarshalLedgerObject(data []byte) (LedgerObject, error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">type helper struct {
                LedgerEntryType LedgerEntryType
        }
        var h helper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var o LedgerObject
        switch h.LedgerEntryType </span>{
        case AccountRootEntry:<span class="cov0" title="0">
                o = &amp;AccountRoot{}</span>
        case AmendmentsEntry:<span class="cov0" title="0">
                o = &amp;Amendments{}</span>
        case BridgeEntry:<span class="cov0" title="0">
                o = &amp;Bridge{}</span>
        case CheckEntry:<span class="cov0" title="0">
                o = &amp;Check{}</span>
        case DepositPreauthObjEntry:<span class="cov0" title="0">
                o = &amp;DepositPreauthObj{}</span>
        case DIDEntry:<span class="cov0" title="0">
                o = &amp;DID{}</span>
        case DirectoryNodeEntry:<span class="cov0" title="0">
                o = &amp;DirectoryNode{}</span>
        case EscrowEntry:<span class="cov0" title="0">
                o = &amp;Escrow{}</span>
        case FeeSettingsEntry:<span class="cov0" title="0">
                o = &amp;FeeSettings{}</span>
        case LedgerHashesEntry:<span class="cov0" title="0">
                o = &amp;LedgerHashes{}</span>
        case NegativeUNLEntry:<span class="cov0" title="0">
                o = &amp;NegativeUNL{}</span>
        case NFTokenOfferEntry:<span class="cov0" title="0">
                o = &amp;NFTokenOffer{}</span>
        case NFTokenPageEntry:<span class="cov0" title="0">
                o = &amp;NFTokenPage{}</span>
        case OfferEntry:<span class="cov0" title="0">
                o = &amp;Offer{}</span>
        case OracleEntry:<span class="cov0" title="0">
                o = &amp;Oracle{}</span>
        case PayChannelEntry:<span class="cov0" title="0">
                o = &amp;PayChannel{}</span>
        case RippleStateEntry:<span class="cov0" title="0">
                o = &amp;RippleState{}</span>
        case SignerListEntry:<span class="cov0" title="0">
                o = &amp;SignerList{}</span>
        case TicketEntry:<span class="cov0" title="0">
                o = &amp;Ticket{}</span>
        case XChainOwnedClaimIDEntry:<span class="cov0" title="0">
                o = &amp;XChainOwnedClaimID{}</span>
        case XChainOwnedCreateAccountClaimIDEntry:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported ledger object of type %s", h.LedgerEntryType)</span>
        }
        <span class="cov0" title="0">if err := json.Unmarshal(data, o); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return o, nil</span>

}
</pre>
		
		<pre class="file" id="file56" style="display: none">package ledger

type NegativeUNL struct {
        DisabledValidators  []DisabledValidatorEntry `json:",omitempty"`
        Flags               uint
        LedgerEntryType     LedgerEntryType
        ValidatorToDisable  string `json:",omitempty"`
        ValidatorToReEnable string `json:",omitempty"`
}

func (*NegativeUNL) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return NegativeUNLEntry
}</span>

type DisabledValidatorEntry struct {
        DisabledValidator DisabledValidator
}

type DisabledValidator struct {
        FirstLedgerSequence uint
        PublicKey           string
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package ledger

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenOffer struct {
        Amount            types.CurrencyAmount
        Destination       types.Address `json:",omitempty"`
        Expiration        uint          `json:",omitempty"`
        Flags             uint
        LedgerEntryType   LedgerEntryType
        NFTokenID         types.Hash256
        NFTokenOfferNode  string `json:",omitempty"`
        Owner             types.Address
        OwnerNode         string `json:",omitempty"`
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
}

func (*NFTokenOffer) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return NFTokenOfferEntry

}</span>

func (n *NFTokenOffer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type nftHelper struct {
                Amount            json.RawMessage
                Destination       types.Address
                Expiration        uint
                Flags             uint
                LedgerEntryType   LedgerEntryType
                NFTokenID         types.Hash256
                NFTokenOfferNode  string
                Owner             types.Address
                OwnerNode         string
                PreviousTxnID     types.Hash256
                PreviousTxnLgrSeq uint
        }
        var h nftHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*n = NFTokenOffer{
                Destination:       h.Destination,
                Expiration:        h.Expiration,
                Flags:             h.Flags,
                LedgerEntryType:   h.LedgerEntryType,
                NFTokenID:         h.NFTokenID,
                NFTokenOfferNode:  h.NFTokenOfferNode,
                Owner:             h.Owner,
                OwnerNode:         h.OwnerNode,
                PreviousTxnID:     h.PreviousTxnID,
                PreviousTxnLgrSeq: h.PreviousTxnLgrSeq,
        }
        amnt, err := types.UnmarshalCurrencyAmount(h.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">n.Amount = amnt
        return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type NFTokenPage struct {
        LedgerEntryType   LedgerEntryType
        NextPageMin       types.Hash256 `json:",omitempty"`
        PreviousPageMin   types.Hash256 `json:",omitempty"`
        PreviousTxnID     types.Hash256 `json:",omitempty"`
        PreviousTxnLgrSeq uint          `json:",omitempty"`
        NFTokens          []types.NFToken
}

func (*NFTokenPage) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return NFTokenPageEntry
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package ledger

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type OfferFlags uint

const (
        PassiveOffer OfferFlags = 0x00010000
        SellOffer    OfferFlags = 0x00020000
)

type Offer struct {
        Account           types.Address
        BookDirectory     types.Hash256
        BookNode          string
        Expiration        uint `json:",omitempty"`
        Flags             OfferFlags
        LedgerEntryType   LedgerEntryType
        OwnerNode         string
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
        Sequence          uint
        TakerPays         types.CurrencyAmount
        TakerGets         types.CurrencyAmount
}

func (*Offer) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return OfferEntry
}</span>

func (o *Offer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type offerHelper struct {
                Account           types.Address
                BookDirectory     types.Hash256
                BookNode          string
                Expiration        uint
                Flags             OfferFlags
                LedgerEntryType   LedgerEntryType
                OwnerNode         string
                PreviousTxnID     types.Hash256
                PreviousTxnLgrSeq uint
                Sequence          uint
                TakerPays         json.RawMessage
                TakerGets         json.RawMessage
        }
        var h offerHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*o = Offer{
                Account:           h.Account,
                BookDirectory:     h.BookDirectory,
                BookNode:          h.BookNode,
                Expiration:        h.Expiration,
                Flags:             h.Flags,
                LedgerEntryType:   h.LedgerEntryType,
                OwnerNode:         h.OwnerNode,
                PreviousTxnID:     h.PreviousTxnID,
                PreviousTxnLgrSeq: h.PreviousTxnLgrSeq,
                Sequence:          h.Sequence,
        }
        pays, err := types.UnmarshalCurrencyAmount(h.TakerPays)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">gets, err := types.UnmarshalCurrencyAmount(h.TakerGets)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.TakerPays = pays
        o.TakerGets = gets
        return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

// A PriceData object represents the price information for a token pair.
type PriceData struct {
        // The primary asset in a trading pair. Any valid identifier, such as a stock symbol,
        // bond CUSIP, or currency code is allowed.
        BaseAsset string
        // The quote asset in a trading pair. The quote asset denotes the
        //price of one unit of the base asset.
        QuoteAsset string
        // The asset price after applying the Scale precision level. It's not included if
        // the last update transaction didn't include the BaseAsset/QuoteAsset pair.
        AssetPrice uint64 `json:",omitempty"`
        // The scaling factor to apply to an asset price. For example, if Scale is 6 and original price is 0.155,
        //then the scaled price is 155000. Valid scale ranges are 0-10.
        //It's not included if the last update transaction didn't include the BaseAsset/QuoteAsset pair.
        Scale uint8 `json:",omitempty"`
}

// An Oracle ledger entry holds data associated with a single price oracle object.
// Requires PriceOracle amendment.
// Example:
// ```json
//
//        {
//          "LedgerEntryType": "Oracle",
//          "Owner": "rNZ9m6AP9K7z3EVg6GhPMx36V4QmZKeWds",
//          "Provider": "70726F7669646572",
//          "AssetClass": "63757272656E6379",
//          "PriceDataSeries": [
//            {
//              "PriceData": {
//                "BaseAsset": "XRP",
//                "QuoteAsset": "USD",
//                "AssetPrice": 740,
//                "Scale": 3,
//              }
//            },
//          ],
//          "LastUpdateTime": 1724871860,
//          "PreviousTxnID": "C53ECF838647FA5A4C780377025FEC7999AB4182590510CA461444B207AB74A9",
//          "PreviousTxnLgrSeq": 3675418
//        }
//
// ```
type Oracle struct {
        // The XRPL account with update and delete privileges for the oracle.
        // It's recommended to set up multi-signing on this account.
        Owner types.Address
        // An arbitrary value that identifies an oracle provider, such as Chainlink, Band, or DIA.
        // This field is a string, up to 256 ASCII hex encoded characters (0x20-0x7E).
        Provider string
        // An array of up to 10 PriceData objects, each representing the price information for a token pair.
        //More than five PriceData objects require two owner reserves.
        PriceDataSeries []PriceData
        // The time the data was last updated, represented in Unix time.
        LastUpdateTime uint32
        // An optional Universal Resource Identifier to reference price data off-chain.
        //This field is limited to 256 bytes.
        URI string `json:",omitempty"`
        // Describes the type of asset, such as "currency", "commodity", or "index". This field is a string,
        // up to 16 ASCII hex encoded characters (0x20-0x7E).
        AssetClass string
        // A hint indicating which page of the oracle owner's owner directory links to this entry,
        // in case the directory consists of multiple pages.
        OwnerNode uint64
        // The hash of the previous transaction that modified this entry.
        PreviousTxnID string
        // The ledger index that this object was most recently modified or created in.
        PreviousTxnLgrSeq uint32
}

// EntryType returns the type of the ledger entry.
func (*Oracle) EntryType() LedgerEntryType <span class="cov8" title="1">{
        return OracleEntry
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type PayChannel struct {
        Account           types.Address
        Amount            types.XRPCurrencyAmount
        Balance           types.XRPCurrencyAmount
        CancelAfter       uint `json:",omitempty"`
        Destination       types.Address
        DestinationTag    uint   `json:",omitempty"`
        DestinationNode   string `json:",omitempty"`
        Expiration        uint   `json:",omitempty"`
        Flags             uint
        LedgerEntryType   LedgerEntryType
        OwnerNode         string
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
        PublicKey         string
        SettleDelay       uint
        SourceTag         uint `json:",omitempty"`
}

func (*PayChannel) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return PayChannelEntry
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

// TODO flags

type RippleState struct {
        Balance           types.IssuedCurrencyAmount
        Flags             uint
        HighLimit         types.IssuedCurrencyAmount
        HighNode          string
        HighQualityIn     uint `json:",omitempty"`
        HighQualityOut    uint `json:",omitempty"`
        LedgerEntryType   LedgerEntryType
        LowLimit          types.IssuedCurrencyAmount
        LowNode           string
        LowQualityIn      uint `json:",omitempty"`
        LowQualityOut     uint `json:",omitempty"`
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
}

func (*RippleState) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return RippleStateEntry
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type SignerListFlags uint32

const (
        LsfOneOwnerCount SignerListFlags = 0x00010000
)

type SignerList struct {
        LedgerEntryType   LedgerEntryType
        Flags             SignerListFlags
        PreviousTxnID     string
        PreviousTxnLgrSeq uint64
        OwnerNode         string
        SignerEntries     []SignerEntryWrapper
        SignerListID      uint64
        SignerQuorum      uint64
}

type SignerEntryWrapper struct {
        SignerEntry SignerEntry
}

type SignerEntry struct {
        Account       types.Address
        SignerWeight  uint64
        WalletLocator types.Hash256 `json:",omitempty"`
}

func (*SignerList) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return SignerListEntry
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type Ticket struct {
        Account           types.Address
        Flags             uint
        LedgerEntryType   LedgerEntryType
        OwnerNode         string
        PreviousTxnID     types.Hash256
        PreviousTxnLgrSeq uint
        TicketSequence    uint
}

func (*Ticket) EntryType() LedgerEntryType <span class="cov0" title="0">{
        return TicketEntry
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type XChainClaimProofSig struct {
        // The amount to claim in the XChainCommit transaction on the destination chain.
        Amount types.CurrencyAmount
        // The account that should receive this signer's share of the SignatureReward.
        AttestationRewardAccount types.Address
        // The account on the door account's signer list that is signing the transaction.
        AttestationSignerAccount types.Address
        // The destination account for the funds on the destination chain.
        Destination types.Address `json:",omitempty"`
        // The public key used to verify the signature.
        PublicKey string
        // A boolean representing the chain where the event occurred.
        WasLockingChainSend uint8
}

type XChainClaimAttestation struct {
        // An attestation from one witness server.
        XChainClaimProofSig XChainClaimProofSig
}

// An XChainOwnedClaimID object represents one cross-chain transfer of value and includes information of the account on
// the source chain that locks or burns the funds on the source chain.
// The XChainOwnedClaimID object must be acquired on the destination chain before submitting a XChainCommit on the source chain.
// Its purpose is to prevent transaction replay attacks and is also used as a place to collect attestations from witness servers.
// An XChainCreateClaimID transaction is used to create a new XChainOwnedClaimID. The ledger object is destroyed when the funds are successfully claimed on the destination chain.
// Example:
// ```json
//
//        {
//          "Account": "rBW1U7J9mEhEdk6dMHEFUjqQ7HW7WpaEMi",
//          "Flags": 0,
//          "OtherChainSource": "r9oXrvBX5aDoyMGkoYvzazxDhYoWFUjz8p",
//          "OwnerNode": "0",
//          "PreviousTxnID": "1CFD80E9CF232B8EED62A52857DE97438D12230C06496932A81DEFA6E66070A6",
//          "PreviousTxnLgrSeq": 58673,
//          "SignatureReward": "100",
//          "XChainBridge": {
//            "IssuingChainDoor": "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh",
//            "IssuingChainIssue": {
//              "currency": "XRP"
//            },
//            "LockingChainDoor": "rMAXACCrp3Y8PpswXcg3bKggHX76V3F8M4",
//            "LockingChainIssue": {
//              "currency": "XRP"
//            }
//          },
//          "XChainClaimAttestations": [
//            {
//              "XChainClaimProofSig": {
//                "Amount": "1000000",
//                "AttestationRewardAccount": "rfgjrgEJGDxfUY2U8VEDs7BnB1jiH3ofu6",
//                "AttestationSignerAccount": "rfsxNxZ6xB1nTPhTMwQajNnkCxWG8B714n",
//                "Destination": "rBW1U7J9mEhEdk6dMHEFUjqQ7HW7WpaEMi",
//                "PublicKey": "025CA526EF20567A50FEC504589F949E0E3401C13EF76DD5FD1CC2850FA485BD7B",
//                "WasLockingChainSend": 1
//              }
//            },
//            {
//              "XChainClaimProofSig": {
//                "Amount": "1000000",
//                "AttestationRewardAccount": "rUUL1tP523M8KimERqVS7sxb1tLLmpndyv",
//                "AttestationSignerAccount": "rEg5sHxZVTNwRL3BAdMwJatkmWDzHMmzDF",
//                "Destination": "rBW1U7J9mEhEdk6dMHEFUjqQ7HW7WpaEMi",
//                "PublicKey": "03D40434A6843638681E2F215310EBC4131AFB12EA85985DA073183B732525F7C9",
//                "WasLockingChainSend": 1
//              },
//            }
//          ],
//          "XChainClaimID": "b5",
//          "LedgerEntryType": "XChainOwnedClaimID",
//          "LedgerIndex": "20B136D7BF6D2E3D610E28E3E6BE09F5C8F4F0241BBF6E2D072AE1BACB1388F5"
//        }
//
// ```
type XChainOwnedClaimID struct {
        // The account that owns this object.
        Account types.Address
        //         The ledger index is a hash of a unique prefix for XChainOwnedClaimIDs,
        // the actual XChainClaimID value, and the fields in XChainBridge.
        LedgerIndex string
        // The account that must send the corresponding XChainCommit on the source chain. The destination may be specified
        // in the XChainCommit transaction, which means that if the OtherChainSource isn't specified, another account can
        //try to specify a different destination and steal the funds. This also allows tracking only a single set of signatures,
        //since we know which account will send the XChainCommit transaction.
        OtherChainSource types.Address
        // The total amount to pay the witness servers for their signatures. It must be at least the value of SignatureReward in the Bridge ledger object.
        SignatureReward types.CurrencyAmount
        // The door accounts and assets of the bridge this object correlates to.
        XChainBridge types.XChainBridge
        // Attestations collected from the witness servers. This includes the parameters needed to recreate the message
        // that was signed, including the amount, which chain (locking or issuing), optional destination, and reward account for that signature.
        XChainClaimAttestations []XChainClaimAttestation
        //The unique sequence number for a cross-chain transfer.
        XChainClaimID uint64
}

// EntryType returns the type of the ledger entry.
func (*XChainOwnedClaimID) EntryType() LedgerEntryType <span class="cov8" title="1">{
        return XChainOwnedClaimIDEntry
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package ledger

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type XChainCreateAccountProofSig struct {
        // The amount committed by the XChainAccountCreateCommit transaction on the source chain.
        Amount types.CurrencyAmount
        // The account that should receive this signer's share of the SignatureReward.
        AttestationRewardAccount types.Address
        // The account on the door account's signer list that is signing the transaction.
        AttestationSignerAccount types.Address
        // The destination account for the funds on the destination chain.
        Destination types.Address
        // The public key used to verify the signature.
        PublicKey string
        // A boolean representing the chain where the event occurred.
        WasLockingChainSend uint8
}

type XChainCreateAccountAttestation struct {
        // An attestation from one witness server.
        XChainCreateAccountProofSig XChainCreateAccountProofSig
}

// The XChainOwnedCreateAccountClaimID ledger object is used to collect attestations for creating an
// account via a cross-chain transfer.
// It is created when an XChainAddAccountCreateAttestation transaction adds a signature attesting to
// a XChainAccountCreateCommit transaction and the XChainAccountCreateCount is greater than or equal
// to the current XChainAccountClaimCount on the Bridge ledger object.
// The ledger object is destroyed when all the attestations have been received and the funds have transferred to the new account.
// Example:
// ```json
//
//        {
//          "LedgerEntryType": "XChainOwnedCreateAccountClaimID",
//          "LedgerIndex": "5A92F6ED33FDA68FB4B9FD140EA38C056CD2BA9673ECA5B4CEF40F2166BB6F0C",
//          "Account": "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh",
//          "XChainAccountCreateCount": "66",
//          "XChainBridge": {
//            "IssuingChainDoor": "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh",
//            "IssuingChainIssue": {
//              "currency": "XRP"
//            },
//            "LockingChainDoor": "rMAXACCrp3Y8PpswXcg3bKggHX76V3F8M4",
//            "LockingChainIssue": {
//              "currency": "XRP"
//            }
//          },
//          "XChainCreateAccountAttestations": [
//            {
//              "XChainCreateAccountProofSig": {
//                "Amount": "20000000",
//                "AttestationRewardAccount": "rMtYb1vNdeMDpD9tA5qSFm8WXEBdEoKKVw",
//                "AttestationSignerAccount": "rL8qTrAvZ8Q1o1H9H9Ahpj3xjgmRvFLvJ3",
//                "Destination": "rBW1U7J9mEhEdk6dMHEFUjqQ7HW7WpaEMi",
//                "PublicKey": "021F7CC4033EFBE5E8214B04D1BAAEC14808DC6C02F4ACE930A8EF0F5909B0C438",
//                "SignatureReward": "100",
//                "WasLockingChainSend": 1
//              }
//            }
//          ]
//        }
//
// ```
type XChainOwnedCreateAccountClaimID struct {
        // The account that owns this object.
        Account types.Address
        // The ledger index is a hash of a unique prefix for XChainOwnedCreateAccountClaimIDs,
        // the actual XChainAccountClaimCount value, and the fields in XChainBridge.
        LedgerIndex string
        // An integer that determines the order that accounts created through cross-chain
        // transfers must be performed. Smaller numbers must execute before larger numbers.
        XChainAccountCreateCount uint64
        // The door accounts and assets of the bridge this object correlates to.
        XChainBridge types.XChainBridge
        // Attestations collected from the witness servers. This includes the parameters needed to recreate the message
        // that was signed, including the amount, destination, signature reward amount, and reward account for that
        // signature. With the exception of the reward account, all signatures must sign the message created with common parameters.
        XChainCreateAccountAttestations []XChainCreateAccountAttestation
}

func (x *XChainOwnedCreateAccountClaimID) EntryType() LedgerEntryType <span class="cov8" title="1">{
        return XChainOwnedCreateAccountClaimIDEntry
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package account

import (
        "encoding/json"
        "errors"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountChannelsRequest struct {
        Account            types.Address          `json:"account"`
        DestinationAccount types.Address          `json:"destination_account,omitempty"`
        LedgerIndex        common.LedgerSpecifier `json:"ledger_index,omitempty"`
        LedgerHash         common.LedgerHash      `json:"ledger_hash,omitempty"`
        Limit              int                    `json:"limit,omitempty"`
        Marker             any                    `json:"marker,omitempty"`
}

func (*AccountChannelsRequest) Method() string <span class="cov0" title="0">{
        return "account_channels"
}</span>

// Validate method to be added to each request struct
func (a *AccountChannelsRequest) Validate() error <span class="cov8" title="1">{
        if a.Account == "" </span><span class="cov8" title="1">{
                return errors.New("no account ID specified")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *AccountChannelsRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type acrHelper struct {
                Account            types.Address     `json:"account"`
                DestinationAccount types.Address     `json:"destination_account"`
                LedgerIndex        json.RawMessage   `json:"ledger_index,omitempty"`
                LedgerHash         common.LedgerHash `json:"ledger_hash,omitempty"`
                Limit              int               `json:"limit,omitempty"`
                Marker             any               `json:"marker,omitempty"`
        }
        var h acrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountChannelsRequest{
                Account:            h.Account,
                DestinationAccount: h.DestinationAccount,
                LedgerHash:         h.LedgerHash,
                Limit:              h.Limit,
                Marker:             h.Marker,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountCurrenciesRequest struct {
        Account     types.Address          `json:"account"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Strict      bool                   `json:"strict,omitempty"`
}

func (*AccountCurrenciesRequest) Method() string <span class="cov0" title="0">{
        return "account_currencies"
}</span>

func (r *AccountCurrenciesRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type acrHelper struct {
                Account     types.Address     `json:"account"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                Strict      bool              `json:"strict,omitempty"`
        }
        var h acrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountCurrenciesRequest{
                Account:    h.Account,
                LedgerHash: h.LedgerHash,
                Strict:     h.Strict,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountInfoRequest struct {
        Account     types.Address          `json:"account"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        Queue       bool                   `json:"queue,omitempty"`
        SignerList  bool                   `json:"signer_list,omitempty"`
        Strict      bool                   `json:"strict,omitempty"`
}

func (*AccountInfoRequest) Method() string <span class="cov0" title="0">{
        return "account_info"
}</span>

func (*AccountInfoRequest) Validate() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *AccountInfoRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type airHelper struct {
                Account     types.Address     `json:"account"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                Queue       bool              `json:"queue,omitempty"`
                SignerList  bool              `json:"signer_list,omitempty"`
                Strict      bool              `json:"strict,omitempty"`
        }
        var h airHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountInfoRequest{
                Account:    h.Account,
                LedgerHash: h.LedgerHash,
                Queue:      h.Queue,
                SignerList: h.SignerList,
                Strict:     h.Strict,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountLinesRequest struct {
        Account     types.Address          `json:"account"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Peer        types.Address          `json:"peer,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
        Marker      any                    `json:"marker,omitempty"`
}

func (*AccountLinesRequest) Method() string <span class="cov0" title="0">{
        return "account_lines"
}</span>

func (*AccountLinesRequest) Validate() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *AccountLinesRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type alrHelper struct {
                Account     types.Address     `json:"account"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                Peer        types.Address     `json:"peer,omitempty"`
                Limit       int               `json:"limit,omitempty"`
                Marker      any               `json:"marker,omitempty"`
        }
        var h alrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountLinesRequest{
                Account:    h.Account,
                LedgerHash: h.LedgerHash,
                Peer:       h.Peer,
                Limit:      h.Limit,
                Marker:     h.Marker,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountNFTsRequest struct {
        Account     types.Address          `json:"account"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
        Marker      any                    `json:"marker,omitempty"`
}

func (*AccountNFTsRequest) Method() string <span class="cov0" title="0">{
        return "account_nfts"
}</span>

func (r *AccountNFTsRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type anrHelper struct {
                Account     types.Address     `json:"account"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                Limit       int               `json:"limit,omitempty"`
                Marker      any               `json:"marker,omitempty"`
        }
        var h anrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountNFTsRequest{
                Account:    h.Account,
                LedgerHash: h.LedgerHash,
                Limit:      h.Limit,
                Marker:     h.Marker,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountObjectType string

const (
        CheckObject          AccountObjectType = "check"
        DepositPreauthObject AccountObjectType = "deposit_preauth"
        EscrowObject         AccountObjectType = "escrow"
        NFTOfferObject       AccountObjectType = "nft_offer"
        OfferObject          AccountObjectType = "offer"
        PaymentChannelObject AccountObjectType = "payment_channel"
        SignerListObject     AccountObjectType = "signer_list"
        StateObject          AccountObjectType = "state"
        TicketObject         AccountObjectType = "ticket"
)

type AccountObjectsRequest struct {
        Account              types.Address          `json:"account"`
        Type                 AccountObjectType      `json:"type,omitempty"`
        DeletionBlockersOnly bool                   `json:"deletion_blockers_only,omitempty"`
        LedgerHash           common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex          common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Limit                int                    `json:"limit,omitempty"`
        Marker               any                    `json:"marker,omitempty"`
}

func (*AccountObjectsRequest) Method() string <span class="cov0" title="0">{
        return "account_objects"
}</span>

// TODO: Implement
func (*AccountObjectsRequest) Validate() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *AccountObjectsRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type aorHelper struct {
                Account              types.Address     `json:"account"`
                Type                 AccountObjectType `json:"type,omitempty"`
                DeletionBlockersOnly bool              `json:"deletion_blockers_only,omitempty"`
                LedgerHash           common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex          json.RawMessage   `json:"ledger_index,omitempty"`
                Limit                int               `json:"limit,omitempty"`
                Marker               any               `json:"marker,omitempty"`
        }
        var h aorHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountObjectsRequest{
                Account:              h.Account,
                Type:                 h.Type,
                DeletionBlockersOnly: h.DeletionBlockersOnly,
                LedgerHash:           h.LedgerHash,
                Limit:                h.Limit,
                Marker:               h.Marker,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountOffersRequest struct {
        Account     types.Address          `json:"account"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
        Marker      any                    `json:"marker,omitempty"`
        Strict      bool                   `json:"strict,omitempty"`
}

func (*AccountOffersRequest) Method() string <span class="cov0" title="0">{
        return "account_offers"
}</span>

func (r *AccountOffersRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type aorHelper struct {
                Account     types.Address     `json:"account"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                Limit       int               `json:"limit,omitempty"`
                Marker      any               `json:"marker,omitempty"`
                Strict      bool              `json:"strict,omitempty"`
        }
        var h aorHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = AccountOffersRequest{
                Account:    h.Account,
                LedgerHash: h.LedgerHash,
                Limit:      h.Limit,
                Marker:     h.Marker,
                Strict:     h.Strict,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountTransactionsRequest struct {
        Account        types.Address          `json:"account"`
        LedgerIndexMin int                    `json:"ledger_index_min,omitempty"`
        LedgerIndexMax int                    `json:"ledger_index_max,omitempty"`
        LedgerHash     common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex    common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Binary         bool                   `json:"binary,omitempty"`
        Forward        bool                   `json:"forward,omitempty"`
        Limit          int                    `json:"limit,omitempty"`
        Marker         any                    `json:"marker,omitempty"`
}

func (*AccountTransactionsRequest) Method() string <span class="cov0" title="0">{
        return "account_tx"
}</span>

func (r *AccountTransactionsRequest) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type atrHelper struct {
                Account        types.Address     `json:"account"`
                LedgerIndexMin int               `json:"ledger_index_min,omitempty"`
                LedgerIndexMax int               `json:"ledger_index_max,omitempty"`
                LedgerHash     common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex    json.RawMessage   `json:"ledger_index,omitempty"`
                Binary         bool              `json:"binary,omitempty"`
                Forward        bool              `json:"forward,omitempty"`
                Limit          int               `json:"limit,omitempty"`
                Marker         any               `json:"marker,omitempty"`
        }
        var h atrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*r = AccountTransactionsRequest{
                Account:        h.Account,
                LedgerIndexMin: h.LedgerIndexMin,
                LedgerIndexMax: h.LedgerIndexMax,
                LedgerHash:     h.LedgerHash,
                Binary:         h.Binary,
                Forward:        h.Forward,
                Limit:          h.Limit,
                Marker:         h.Marker,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package account

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type OfferResultFlags uint

type OfferResult struct {
        Flags      OfferResultFlags     `json:"flags"`
        Sequence   uint                 `json:"seq"`
        TakerGets  types.CurrencyAmount `json:"taker_gets"`
        TakerPays  types.CurrencyAmount `json:"taker_pays"`
        Quality    string               `json:"quality"`
        Expiration uint                 `json:"expiration,omitempty"`
}

func (r *OfferResult) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type orHelper struct {
                Flags      OfferResultFlags `json:"flags"`
                Sequence   uint             `json:"seq"`
                TakerGets  json.RawMessage  `json:"taker_gets"`
                TakerPays  json.RawMessage  `json:"taker_pays"`
                Quality    string           `json:"quality"`
                Expiration uint             `json:"expiration,omitempty"`
        }
        var h orHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = OfferResult{
                Flags:      h.Flags,
                Sequence:   h.Sequence,
                Quality:    h.Quality,
                Expiration: h.Expiration,
        }

        var gets, pays types.CurrencyAmount
        var err error
        gets, err = types.UnmarshalCurrencyAmount(h.TakerGets)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pays, err = types.UnmarshalCurrencyAmount(h.TakerPays)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r.TakerGets = gets
        r.TakerPays = pays
        return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package data

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
)

type CanDeleteRequest struct {
        CanDelete common.LedgerSpecifier `json:"can_delete,omitempty"`
}

func (*CanDeleteRequest) Method() string <span class="cov0" title="0">{
        return "can_delete"
}</span>

func (r *CanDeleteRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type cdHelper struct {
                CanDelete json.RawMessage `json:"can_delete"`
        }
        var h cdHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.CanDelete, err = common.UnmarshalLedgerSpecifier(h.CanDelete)

        return err</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package data

type CrawlShardsRequest struct {
        PublicKey bool `json:"public_key,omitempty"`
        Limit     int  `json:"limit,omitempty"`
}

func (*CrawlShardsRequest) Method() string <span class="cov0" title="0">{
        return "crawl_shards"
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package data

import "github.com/Peersyst/xrpl-go/xrpl/queries/common"

type DownloadShardRequest struct {
        Shards []ShardDescriptor `json:"shards"`
}

type ShardDescriptor struct {
        Index common.LedgerIndex `json:"index"`
        URL   string             `json:"url"`
}

func (*DownloadShardRequest) Method() string <span class="cov0" title="0">{
        return "download_shard"
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package data

import "github.com/Peersyst/xrpl-go/xrpl/queries/common"

type LedgerCleanerRequest struct {
        Ledger     common.LedgerIndex `json:"ledger,omitempty"`
        MaxLedger  common.LedgerIndex `json:"max_ledger,omitempty"`
        MinLedger  common.LedgerIndex `json:"min_ledger,omitempty"`
        Full       bool               `json:"full,omitempty"`
        FixTxns    bool               `json:"fix_txns,omitempty"`
        CheckNodes bool               `json:"check_nodes,omitempty"`
        Stop       bool               `json:"stop,omitempty"`
}

func (*LedgerCleanerRequest) Method() string <span class="cov0" title="0">{
        return "ledger_cleaner"
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package data

import "github.com/Peersyst/xrpl-go/xrpl/queries/common"

type LedgerRequestRequest struct {
        LedgerIndex common.LedgerIndex `json:"ledger_index,omitempty"`
        LedgerHash  common.LedgerHash  `json:"ledger_hash,omitempty"`
}

func (*LedgerRequest) Method() string <span class="cov0" title="0">{
        return "ledger_request"
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package data

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/queries/ledger"
)

type LedgerRequestResponse struct {
        LedgerHeader  *ledger.LedgerHeader `json:"ledger,omitempty"`
        LedgerRequest *LedgerRequest       `json:"-"`
        Acquiring     *LedgerRequest       `json:"acquiring,omitempty"`
}

type LedgerRequest struct {
        Hash                    common.LedgerHash `json:"hash,omitempty"`
        HaveHeader              bool              `json:"have_header"`
        HaveState               bool              `json:"have_state,omitempty"`
        HaveTransactions        bool              `json:"have_transactions,omitempty"`
        NeededStateHashes       []string          `json:"needed_state_hashes,omitempty"`
        NeededTransactionHashes []string          `json:"needed_transaction_hashes,omitempty"`
        Peers                   int               `json:"peers"`
        Timeouts                int               `json:"timeouts"`
}

func (r LedgerRequestResponse) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type rHelper LedgerRequestResponse
        data := make(map[string]interface{})
        h := rHelper(r)

        first, err := json.Marshal(h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(first, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if r.LedgerRequest != nil </span><span class="cov8" title="1">{
                second, err := json.Marshal(r.LedgerRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err = json.Unmarshal(second, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return json.Marshal(data)</span>
}

func (r *LedgerRequestResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type rHelper LedgerRequestResponse
        h := rHelper(*r)
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Acquiring = h.Acquiring
        r.LedgerHeader = h.LedgerHeader
        if r.Acquiring == nil &amp;&amp; r.LedgerHeader == nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal(data, &amp;(r.LedgerRequest)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package data

type LogLevelRequest struct {
        Severity  string `json:"severity,omitempty"`
        Partition string `json:"partition,omitempty"`
}

func (*LogLevelRequest) Method() string <span class="cov0" title="0">{
        return "log_level"
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package data

type LogrotateRequest struct {
}

func (*LogrotateRequest) Method() string <span class="cov0" title="0">{
        return "logrotate"
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package data

type NodeToShardRequest struct {
        Action string `json:"action"`
}

func (*NodeToShardRequest) Method() string <span class="cov0" title="0">{
        return "node_to_shard"
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package key

type ValidationCreateRequest struct {
        Secret string `json:"secret,omitempty"`
}

func (*ValidationCreateRequest) Method() string <span class="cov0" title="0">{
        return "validation_create"
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package key

type WalletProposeRequest struct {
        KeyType    string `json:"key_type,omitempty"`
        Passphrase string `json:"passphrase,omitempty"`
        Seed       string `json:"seed,omitempty"`
        SeedHex    string `json:"seed_hex,omitempty"`
}

func (*WalletProposeRequest) Method() string <span class="cov0" title="0">{
        return "wallet_propose"
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package peer

type ConnectRequest struct {
        IP   string `json:"ip"`
        Port int    `json:"port,omitempty"`
}

func (*ConnectRequest) Method() string <span class="cov0" title="0">{
        return "connect"
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package peer

type PeerReservationAddRequest struct {
        PublicKey   string `json:"public_key"`
        Description string `json:"description,omitempty"`
}

func (*PeerReservationAddRequest) Method() string <span class="cov0" title="0">{
        return "peer_reservations_add"
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package peer

type PeerReservationDelRequest struct {
        PublicKey string `json:"public_key"`
}

func (*PeerReservationDelRequest) Method() string <span class="cov0" title="0">{
        return "peer_reservations_del"
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package peer

type PeerReservationsListRequest struct {
}

func (*PeerReservationsListRequest) Method() string <span class="cov0" title="0">{
        return "peer_reservations_list"
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package peer

type PeersRequest struct {
}

func (*PeersRequest) Method() string <span class="cov0" title="0">{
        return "peers"
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package server

type LedgerAcceptRequest struct {
}

func (*LedgerAcceptRequest) Method() string <span class="cov0" title="0">{
        return "leder_accept"
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package server

type StopRequest struct {
}

func (*StopRequest) Method() string <span class="cov0" title="0">{
        return "stop"
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package signing

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type SignForRequest struct {
        Account    types.Address               `json:"account"`
        TxJson     transaction.FlatTransaction `json:"tx_json"`
        Secret     string                      `json:"secret,omitempty"`
        Seed       string                      `json:"seed,omitempty"`
        SeedHex    string                      `json:"seed_hex,omitempty"`
        Passphrase string                      `json:"passphrase,omitempty"`
        KeyType    string                      `json:"key_type,omitempty"`
}

func (*SignForRequest) Method() string <span class="cov0" title="0">{
        return "sign_for"
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package signing

import "github.com/Peersyst/xrpl-go/xrpl/transaction"

type SignRequest struct {
        TxJson     transaction.FlatTransaction `json:"tx_json"`
        Secret     string                      `json:"secret,omitempty"`
        Seed       string                      `json:"seed,omitempty"`
        SeedHex    string                      `json:"seed_hex,omitempty"`
        Passphrase string                      `json:"passphrase,omitempty"`
        KeyType    string                      `json:"key_type,omitempty"`
        Offline    bool                        `json:"offline,omitempty"`
        BuildPath  bool                        `json:"build_path,omitempty"`
        FeeMultMax int                         `json:"fee_mult_max,omitempty"`
        FeeDivMax  int                         `json:"fee_div_max,omitempty"`
}

func (*SignRequest) Method() string <span class="cov0" title="0">{
        return "sign"
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package status

type ConsensusInfoRequest struct {
}

func (*ConsensusInfoRequest) Method() string <span class="cov0" title="0">{
        return "consensus_info"
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package status

type FeatureRequest struct {
        Feature string `json:"feature,omitempty"`
        Vetoed  bool   `json:"vetoed,omitempty"`
}

func (*FeatureRequest) Method() string <span class="cov0" title="0">{
        return "feature"
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package status

type FetchInfoRequest struct {
        Clear bool `json:"clear"`
}

func (*FetchInfoRequest) Method() string <span class="cov0" title="0">{
        return "fetch_info"
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package status

type GetCountsRequest struct {
        MinCount int `json:"min_count,omitempty"`
}

func (*GetCountsRequest) Method() string <span class="cov0" title="0">{
        return "get_counts"
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package status

type ValidatorInfoRequest struct {
}

func (*ValidatorInfoRequest) Method() string <span class="cov0" title="0">{
        return "validator_info"
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package status

type ValidatorListSitesRequest struct {
}

func (*ValidatorListSitesRequest) Method() string <span class="cov0" title="0">{
        return "validator_list_sites"
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package status

type ValidatorsRequest struct {
}

func (*ValidatorsRequest) Method() string <span class="cov0" title="0">{
        return "validators"
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package channel

import (
        "fmt"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type ChannelAuthorizeRequest struct {
        ChannelID  string                  `json:"channel_id"`
        Secret     string                  `json:"secret,omitempty"`
        Seed       string                  `json:"seed,omitempty"`
        SeedHex    string                  `json:"seed_hex,omitempty"`
        Passphrase string                  `json:"passphrase,omitempty"`
        KeyType    string                  `json:"key_type,omitempty"`
        Amount     types.XRPCurrencyAmount `json:"amount"`
}

func (*ChannelAuthorizeRequest) Method() string <span class="cov0" title="0">{
        return "channel_authorize"
}</span>

// do not allow secrets to be printed
func (c *ChannelAuthorizeRequest) Format(s fmt.State, v rune) <span class="cov0" title="0">{
        type fHelper struct {
                ChannelID string                  `json:"channel_id"`
                KeyType   string                  `json:"key_type,omitempty"`
                Amount    types.XRPCurrencyAmount `json:"amount"`
        }
        h := fHelper{
                ChannelID: c.ChannelID,
                KeyType:   c.KeyType,
                Amount:    c.Amount,
        }
        fmt.Fprintf(s, "%"+string(v), h)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package channel

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type ChannelVerifyRequest struct {
        Amount    types.XRPCurrencyAmount `json:"amount"`
        ChannelID string                  `json:"channel_id"`
        PublicKey string                  `json:"public_key"`
        Signature string                  `json:"signature"`
}

func (*ChannelVerifyRequest) Method() string <span class="cov0" title="0">{
        return "channel_verify"
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package clio

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
)

type LedgerRequest struct {
        LedgerHash   common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex  common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Full         bool                   `json:"full"`
        Accounts     bool                   `json:"accounts"`
        Transactions bool                   `json:"transactions"`
        Expand       bool                   `json:"expand"`
        OwnerFunds   bool                   `json:"owner_funds"`
        Binary       bool                   `json:"binary"`
        Queue        bool                   `json:"queue"`
        Diff         bool                   `json:"diff"`
}

func (*LedgerRequest) Method() string <span class="cov0" title="0">{
        return "ledger"
}</span>

func (r *LedgerRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type lrHelper struct {
                LedgerHash   common.LedgerHash `json:"ledger_hash"`
                LedgerIndex  json.RawMessage   `json:"ledger_index"`
                Full         bool              `json:"full"`
                Accounts     bool              `json:"accounts"`
                Transactions bool              `json:"transactions"`
                Expand       bool              `json:"expand"`
                OwnerFunds   bool              `json:"owner_funds"`
                Binary       bool              `json:"binary"`
                Queue        bool              `json:"queue"`
                Diff         bool              `json:"diff"`
        }
        var h lrHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = LedgerRequest{
                LedgerHash:   h.LedgerHash,
                Accounts:     h.Accounts,
                Full:         h.Full,
                Transactions: h.Transactions,
                Expand:       h.Expand,
                OwnerFunds:   h.OwnerFunds,
                Binary:       h.Binary,
                Queue:        h.Queue,
                Diff:         h.Diff,
        }
        r.LedgerIndex, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package clio

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTInfoRequest struct {
        NFTokenID   types.NFTokenID        `json:"nft_id"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
}

func (*NFTInfoRequest) Method() string <span class="cov0" title="0">{
        return "nft_info"
}</span>

func (r *NFTInfoRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type nirHelper struct {
                NFTokenID   types.NFTokenID   `json:"nft_id"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
        }
        var h nirHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = NFTInfoRequest{
                NFTokenID:  h.NFTokenID,
                LedgerHash: h.LedgerHash,
        }
        r.LedgerIndex, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        return err</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package clio

type ServerInfoRequest struct {
}

func (*ServerInfoRequest) Method() string <span class="cov0" title="0">{
        return "server_info"
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package common

import (
        "encoding/json"
        "fmt"
        "strconv"
)

type LedgerSpecifier interface {
        Ledger() string
}

func UnmarshalLedgerSpecifier(data []byte) (LedgerSpecifier, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">switch data[0] </span>{
        case '"':<span class="cov8" title="1">
                var s string
                if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">switch s </span>{
                case CURRENT.Ledger():<span class="cov8" title="1">
                        return CURRENT, nil</span>
                case VALIDATED.Ledger():<span class="cov8" title="1">
                        return VALIDATED, nil</span>
                case CLOSED.Ledger():<span class="cov8" title="1">
                        return CLOSED, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("decoding LedgerTitle: invalid string %s", s)</span>
        default:<span class="cov8" title="1">
                var i LedgerIndex
                if err := json.Unmarshal(data, &amp;i); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return i, nil</span>
        }
}

type LedgerIndex uint32

func (l LedgerIndex) Ledger() string <span class="cov0" title="0">{
        return strconv.FormatUint(uint64(l), 10)
}</span>

func (l LedgerIndex) Uint32() uint32 <span class="cov0" title="0">{
        return uint32(l)
}</span>

func (l LedgerIndex) Int() int <span class="cov8" title="1">{
        return int(l)
}</span>

type LedgerTitle string

const (
        CURRENT   LedgerTitle = "current"
        VALIDATED LedgerTitle = "validated"
        CLOSED    LedgerTitle = "closed"
)

func (l LedgerTitle) Ledger() string <span class="cov8" title="1">{
        return string(l)
}</span>

type LedgerHash string
</pre>
		
		<pre class="file" id="file109" style="display: none">package ledger

type LedgerClosedRequest struct {
}

func (*LedgerClosedRequest) Method() string <span class="cov0" title="0">{
        return "ledger_closed"
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package ledger

type LedgerCurrentRequest struct {
}

func (*LedgerCurrentRequest) Method() string <span class="cov0" title="0">{
        return "ledger_current"
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package ledger

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
)

type LedgerDataRequest struct {
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Binary      bool                   `json:"binary,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
        Marker      any                    `json:"marker,omitempty"`
        Type        ledger.LedgerEntryType `json:"type,omitempty"`
}

func (r *LedgerDataRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type ldrHelper struct {
                LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage        `json:"ledger_index,omitempty"`
                Binary      bool                   `json:"binary,omitempty"`
                Limit       int                    `json:"limit,omitempty"`
                Marker      any                    `json:"marker,omitempty"`
                Type        ledger.LedgerEntryType `json:"type,omitempty"`
        }
        var h ldrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = LedgerDataRequest{
                LedgerHash: h.LedgerHash,
                Binary:     h.Binary,
                Limit:      h.Limit,
                Marker:     h.Marker,
                Type:       h.Type,
        }
        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i

        return nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package ledger

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type LedgerEntryRequest struct {
        Binary         bool                   `json:"binary,omitempty"`
        LedgerHash     common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex    common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Index          string                 `json:"index,omitempty"`
        AccountRoot    types.Address          `json:"account_root,omitempty"`
        Directory      EntryRequestOrString   `json:"directory,omitempty"`
        Offer          EntryRequestOrString   `json:"offer,omitempty"`
        RippleState    EntryRequestOrString   `json:"ripple_state,omitempty"`
        Check          string                 `json:"check,omitempty"`
        Escrow         EntryRequestOrString   `json:"escrow,omitempty"`
        PaymentChannel string                 `json:"payment_channel,omitempty"`
        DepositPreauth EntryRequestOrString   `json:"deposit_preauth,omitempty"`
        Ticket         EntryRequestOrString   `json:"ticket,omitempty"`
}

type EntryRequestOrString interface {
        LedgerEntryRequestField()
}

type EntryString string

func (EntryString) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

type DirectoryEntryReq struct {
        SubIndex uint   `json:"sub_index,omitempty"`
        DirRoot  string `json:"dir_root,omitempty"`
        Owner    string `json:"owner,omitempty"`
}

func (*DirectoryEntryReq) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

type OfferEntryReq struct {
        Account types.Address `json:"account"`
        Seq     uint          `json:"seq"`
}

func (*OfferEntryReq) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

type RippleStateEntryReq struct {
        Accounts []types.Address `json:"accounts"`
        Currency string          `json:"currency"`
}

func (*RippleStateEntryReq) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

type EscrowEntryReq struct {
        Owner types.Address `json:"owner"`
        Seq   uint          `json:"seq"`
}

func (*EscrowEntryReq) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

type DepositPreauthEntryReq struct {
        Owner      types.Address `json:"owner"`
        Authorized types.Address `json:"authorized"`
}

func (*DepositPreauthEntryReq) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

type TicketEntryReq struct {
        Account   types.Address `json:"account"`
        TicketSeq int           `json:"ticket_seq"`
}

func (*TicketEntryReq) LedgerEntryRequestField() {<span class="cov0" title="0">}</span>

func parseEntryRequestField(data []byte, target EntryRequestOrString) (EntryRequestOrString, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if data[0] == '"' </span><span class="cov0" title="0">{
                var s EntryString
                err := json.Unmarshal(data, &amp;s)
                return s, err
        }</span>
        <span class="cov8" title="1">err := json.Unmarshal(data, target)
        return target, err</span>
}

func (r *LedgerEntryRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type lerHelper struct {
                Binary         bool              `json:"binary,omitempty"`
                LedgerHash     common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex    json.RawMessage   `json:"ledger_index,omitempty"`
                Index          string            `json:"index,omitempty"`
                AccountRoot    types.Address     `json:"account_root,omitempty"`
                Directory      json.RawMessage   `json:"directory,omitempty"`
                Offer          json.RawMessage   `json:"offer,omitempty"`
                RippleState    json.RawMessage   `json:"ripple_state,omitempty"`
                Check          string            `json:"check,omitempty"`
                Escrow         json.RawMessage   `json:"escrow,omitempty"`
                PaymentChannel string            `json:"payment_channel,omitempty"`
                DepositPreauth json.RawMessage   `json:"deposit_preauth,omitempty"`
                Ticket         json.RawMessage   `json:"ticket,omitempty"`
        }
        var h lerHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = LedgerEntryRequest{
                Binary:         h.Binary,
                LedgerHash:     h.LedgerHash,
                Index:          h.Index,
                AccountRoot:    h.AccountRoot,
                Check:          h.Check,
                PaymentChannel: h.PaymentChannel,
        }
        r.LedgerIndex, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Directory, err = parseEntryRequestField(h.Directory, &amp;DirectoryEntryReq{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Offer, err = parseEntryRequestField(h.Offer, &amp;OfferEntryReq{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.RippleState, err = parseEntryRequestField(h.RippleState, &amp;RippleStateEntryReq{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Escrow, err = parseEntryRequestField(h.Escrow, &amp;EscrowEntryReq{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.DepositPreauth, err = parseEntryRequestField(h.DepositPreauth, &amp;DepositPreauthEntryReq{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.Ticket, err = parseEntryRequestField(h.Ticket, &amp;TicketEntryReq{})

        return err</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package ledger

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
)

type LedgerRequest struct {
        LedgerHash   common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex  common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Full         bool                   `json:"full,omitempty"`
        Accounts     bool                   `json:"accounts,omitempty"`
        Transactions bool                   `json:"transactions,omitempty"`
        OwnerFunds   bool                   `json:"owner_funds,omitempty"`
        Binary       bool                   `json:"binary,omitempty"`
        Queue        bool                   `json:"queue,omitempty"`
        Type         ledger.LedgerEntryType `json:"type,omitempty"`
}

func (*LedgerRequest) Method() string <span class="cov0" title="0">{
        return "ledger"
}</span>

// TODO: Implement
func (*LedgerRequest) Validate() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *LedgerRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type lrHelper struct {
                LedgerHash   common.LedgerHash      `json:"ledger_hash,omitempty"`
                LedgerIndex  json.RawMessage        `json:"ledger_index,omitempty"`
                Full         bool                   `json:"full,omitempty"`
                Accounts     bool                   `json:"accounts,omitempty"`
                Transactions bool                   `json:"transactions,omitempty"`
                OwnerFunds   bool                   `json:"owner_funds,omitempty"`
                Binary       bool                   `json:"binary,omitempty"`
                Queue        bool                   `json:"queue,omitempty"`
                Type         ledger.LedgerEntryType `json:"type,omitempty"`
        }
        var h lrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = LedgerRequest{
                LedgerHash:   h.LedgerHash,
                Full:         h.Full,
                Accounts:     h.Accounts,
                Transactions: h.Transactions,
                OwnerFunds:   h.OwnerFunds,
                Binary:       h.Binary,
                Queue:        h.Queue,
                Type:         h.Type,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type BookOffersRequest struct {
        TakerGets   types.IssuedCurrencyAmount `json:"taker_gets"`
        TakerPays   types.IssuedCurrencyAmount `json:"taker_pays"`
        LedgerHash  common.LedgerHash          `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier     `json:"ledger_index,omitempty"`
        Limit       int                        `json:"limit,omitempty"`
        Taker       types.Address              `json:"taker,omitempty"`
}

func (*BookOffersRequest) Method() string <span class="cov0" title="0">{
        return "book_offers"
}</span>

func (r *BookOffersRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type borHelper struct {
                TakerGets   types.IssuedCurrencyAmount `json:"taker_gets"`
                TakerPays   types.IssuedCurrencyAmount `json:"taker_pays"`
                LedgerHash  common.LedgerHash          `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage            `json:"ledger_index,omitempty"`
                Limit       int                        `json:"limit,omitempty"`
                Taker       types.Address              `json:"taker,omitempty"`
        }
        var h borHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = BookOffersRequest{
                TakerGets:  h.TakerGets,
                TakerPays:  h.TakerPays,
                LedgerHash: h.LedgerHash,
                Limit:      h.Limit,
                Taker:      h.Taker,
        }
        var i common.LedgerSpecifier
        i, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type BookOffersResponse struct {
        LedgerCurrentIndex common.LedgerIndex `json:"ledger_current_index,omitempty"`
        LedgerIndex        common.LedgerIndex `json:"ledger_index,omitempty"`
        LedgerHash         common.LedgerHash  `json:"ledger_hash,omitempty"`
        Offers             []BookOffer        `json:"offers"`
}

type BookOffer struct {
        ledger.Offer
        OwnerFunds      string               `json:"owner_funds,omitempty"`
        TakerGetsFunded types.CurrencyAmount `json:"taker_gets_funded,omitempty"`
        TakerPaysFunded types.CurrencyAmount `json:"taker_pays_funded,omitempty"`
        Quality         string               `json:"quality,omitempty"`
}

func (o *BookOffer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type boHelper struct {
                OwnerFunds      string          `json:"offer_funds,omitempty"`
                TakerGetsFunded json.RawMessage `json:"taker_gets_funded,omitempty"`
                TakerPaysFunded json.RawMessage `json:"taker_pays_funded,omitempty"`
                Quality         string          `json:"quality,omitempty"`
        }
        var h boHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var offer ledger.Offer
        err = json.Unmarshal(data, &amp;offer)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*o = BookOffer{
                Offer:      offer,
                OwnerFunds: h.OwnerFunds,
                Quality:    h.Quality,
        }
        var g, p types.CurrencyAmount
        g, err = types.UnmarshalCurrencyAmount(h.TakerGetsFunded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.TakerGetsFunded = g
        p, err = types.UnmarshalCurrencyAmount(h.TakerPaysFunded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.TakerPaysFunded = p

        return nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type DepositAuthorizedRequest struct {
        SourceAccount      types.Address          `json:"source_account"`
        DestinationAccount types.Address          `json:"destination_account"`
        LedgerHash         common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex        common.LedgerSpecifier `json:"ledger_index,omitempty"`
}

func (*DepositAuthorizedRequest) Method() string <span class="cov0" title="0">{
        return "deposit_authorized"
}</span>

func (r *DepositAuthorizedRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type darHelper struct {
                SourceAccount      types.Address     `json:"source_account"`
                DestinationAccount types.Address     `json:"destination_account"`
                LedgerHash         common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex        json.RawMessage   `json:"ledger_index,omitempty"`
        }
        var h darHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = DepositAuthorizedRequest{
                SourceAccount:      h.SourceAccount,
                DestinationAccount: h.DestinationAccount,
                LedgerHash:         h.LedgerHash,
        }
        var spec common.LedgerSpecifier
        spec, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = spec
        return nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenBuyOffersRequest struct {
        NFTokenID   types.NFTokenID        `json:"nft_id"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
        Marker      any                    `json:"marker,omitempty"`
}

func (*NFTokenBuyOffersRequest) Method() string <span class="cov0" title="0">{
        return "nft_buy_offers"
}</span>

func (r *NFTokenBuyOffersRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type borHelper struct {
                NFTokenID   types.NFTokenID   `json:"nft_id"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                Limit       int               `json:"limit,omitempty"`
                Marker      any               `json:"marker,omitempty"`
        }
        var h borHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = NFTokenBuyOffersRequest{
                NFTokenID:  h.NFTokenID,
                LedgerHash: h.LedgerHash,
                Limit:      h.Limit,
                Marker:     h.Marker,
        }
        var i common.LedgerSpecifier
        i, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenOffer struct {
        Amount            types.CurrencyAmount `json:"amount"`
        Flags             uint                 `json:"flags"`
        NFTokenOfferIndex string               `json:"nft_offer_index"`
        Owner             types.Address        `json:"owner"`
}

func (o *NFTokenOffer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type ntoHelper struct {
                Amount            json.RawMessage `json:"amount"`
                Flags             uint            `json:"flags"`
                NFTokenOfferIndex string          `json:"nft_offer_index"`
                Owner             types.Address   `json:"owner"`
        }
        var h ntoHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*o = NFTokenOffer{
                Flags:             h.Flags,
                NFTokenOfferIndex: h.NFTokenOfferIndex,
                Owner:             h.Owner,
        }
        var c types.CurrencyAmount
        c, err = types.UnmarshalCurrencyAmount(h.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.Amount = c

        return nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenSellOffersRequest struct {
        NFTokenID   types.NFTokenID        `json:"nft_id"`
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
        Marker      any                    `json:"marker,omitempty"`
}

func (*NFTokenSellOffersRequest) Method() string <span class="cov0" title="0">{
        return "nft_sell_offers"
}</span>

func (r *NFTokenSellOffersRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type borHelper struct {
                NFTokenID   types.NFTokenID   `json:"nft_id"`
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                Limit       int               `json:"limit,omitempty"`
                Marker      any               `json:"marker,omitempty"`
        }
        var h borHelper
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = NFTokenSellOffersRequest{
                NFTokenID:  h.NFTokenID,
                LedgerHash: h.LedgerHash,
                Limit:      h.Limit,
                Marker:     h.Marker,
        }
        var i common.LedgerSpecifier
        i, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type PathSubCommand string

const (
        CREATE PathSubCommand = "create"
        CLOSE  PathSubCommand = "close"
        STATUS PathSubCommand = "status"
)

type PathFindRequest struct {
        Subcommand         PathSubCommand         `json:"subcommand"`
        SourceAccount      types.Address          `json:"source_account,omitempty"`
        DestinationAccount types.Address          `json:"destination_account,omitempty"`
        DestinationAmount  types.CurrencyAmount   `json:"destination_amount,omitempty"`
        SendMax            types.CurrencyAmount   `json:"send_max,omitempty"`
        Paths              []transaction.PathStep `json:"paths,omitempty"`
}

func (*PathFindRequest) Method() string <span class="cov0" title="0">{
        return "path_find"
}</span>

func (r *PathFindRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type pfrHelper struct {
                Subcommand         PathSubCommand         `json:"subcommand"`
                SourceAccount      types.Address          `json:"source_account,omitempty"`
                DestinationAccount types.Address          `json:"destination_account,omitempty"`
                DestinationAmount  json.RawMessage        `json:"destination_amount,omitempty"`
                SendMax            json.RawMessage        `json:"send_max,omitempty"`
                Paths              []transaction.PathStep `json:"paths,omitempty"`
        }
        var h pfrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = PathFindRequest{
                Subcommand:         h.Subcommand,
                SourceAccount:      h.SourceAccount,
                DestinationAccount: h.DestinationAccount,
                Paths:              h.Paths,
        }

        var dest, max types.CurrencyAmount
        var err error
        dest, err = types.UnmarshalCurrencyAmount(h.DestinationAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.DestinationAmount = dest

        max, err = types.UnmarshalCurrencyAmount(h.SendMax)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.SendMax = max

        return nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type PathFindResponse struct {
        Alternatives       []PathAlternative    `json:"alternatives"`
        DestinationAccount types.Address        `json:"destination_account"`
        DestinationAmount  types.CurrencyAmount `json:"destination_amount"`
        SourceAccount      types.Address        `json:"source_account"`
        FullReply          bool                 `json:"full_reply"`
        Closed             bool                 `json:"closed,omitempty"`
        Status             bool                 `json:"status,omitempty"`
}

func (r *PathFindResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type pfrHelper struct {
                Alternatives       []PathAlternative `json:"alternatives"`
                DestinationAccount types.Address     `json:"destination_account"`
                DestinationAmount  json.RawMessage   `json:"destination_amount"`
                SourceAccount      types.Address     `json:"source_account"`
                FullReply          bool              `json:"full_reply"`
                Closed             bool              `json:"closed,omitempty"`
                Status             bool              `json:"status,omitempty"`
        }
        var h pfrHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = PathFindResponse{
                Alternatives:       h.Alternatives,
                DestinationAccount: h.DestinationAccount,
                SourceAccount:      h.SourceAccount,
                FullReply:          h.FullReply,
                Closed:             h.Closed,
                Status:             h.Status,
        }

        dst, err := types.UnmarshalCurrencyAmount(h.DestinationAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.DestinationAmount = dst

        return nil</span>
}

type PathAlternative struct {
        PathsComputed     [][]transaction.PathStep `json:"paths_computed"`
        SourceAmount      types.CurrencyAmount     `json:"source_amount"`
        DestinationAmount types.CurrencyAmount     `json:"destination_amount,omitempty"`
}

func (p *PathAlternative) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type paHelper struct {
                PathsComputed     [][]transaction.PathStep `json:"paths_computed"`
                SourceAmount      json.RawMessage          `json:"source_amount"`
                DestinationAmount json.RawMessage          `json:"destination_amount,omitempty"`
        }
        var h paHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.PathsComputed = h.PathsComputed

        var src, dst types.CurrencyAmount
        var err error

        src, err = types.UnmarshalCurrencyAmount(h.SourceAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.SourceAmount = src

        dst, err = types.UnmarshalCurrencyAmount(h.DestinationAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.DestinationAmount = dst

        return nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package path

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type RipplePathFindRequest struct {
        SourceAccount      types.Address                `json:"source_account"`
        DestinationAccount types.Address                `json:"destination_account"`
        DestinationAmount  types.CurrencyAmount         `json:"destination_amount"`
        SendMax            types.CurrencyAmount         `json:"send_max,omitempty"`
        SourceCurrencies   []types.IssuedCurrencyAmount `json:"source_currencies,omitempty"`
        LedgerHash         common.LedgerHash            `json:"ledger_hash,omitempty"`
        LedgerIndex        common.LedgerSpecifier       `json:"ledger_index,omitempty"`
}

func (*RipplePathFindRequest) Method() string <span class="cov0" title="0">{
        return "ripple_path_find"
}</span>

func (r *RipplePathFindRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type rpfHelper struct {
                SourceAccount      types.Address                `json:"source_account"`
                DestinationAccount types.Address                `json:"destination_account"`
                DestinationAmount  json.RawMessage              `json:"destination_amount"`
                SendMax            json.RawMessage              `json:"send_max,omitempty"`
                SourceCurrencies   []types.IssuedCurrencyAmount `json:"source_currencies,omitempty"`
                LedgerHash         common.LedgerHash            `json:"ledger_hash,omitempty"`
                LedgerIndex        json.RawMessage              `json:"ledger_index,omitempty"`
        }
        var h rpfHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*r = RipplePathFindRequest{
                SourceAccount:      h.SourceAccount,
                DestinationAccount: h.DestinationAccount,
                SourceCurrencies:   h.SourceCurrencies,
                LedgerHash:         h.LedgerHash,
        }
        var dst, max types.CurrencyAmount
        var err error

        dst, err = types.UnmarshalCurrencyAmount(h.DestinationAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.DestinationAmount = dst

        max, err = types.UnmarshalCurrencyAmount(h.SendMax)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.SendMax = max

        var i common.LedgerSpecifier
        i, err = common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.LedgerIndex = i
        return nil</span>

}
</pre>
		
		<pre class="file" id="file123" style="display: none">package server

type FeeRequest struct {
}

func (*FeeRequest) Method() string <span class="cov0" title="0">{
        return "fee"
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package server

type ManifestRequest struct {
        PublicKey string `json:"public_key"`
}

func (*ManifestRequest) Method() string <span class="cov0" title="0">{
        return "manifest"
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">package server

type ServerInfoRequest struct {
}

func (*ServerInfoRequest) Method() string <span class="cov0" title="0">{
        return "server_info"
}</span>

// TODO: Implement
func (*ServerInfoRequest) Validate() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">package server

type ServerStateRequest struct {
}

func (*ServerStateRequest) Method() string <span class="cov0" title="0">{
        return "server_state"
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package subscribe

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type SubscribeRequest struct {
        Streams          []string             `json:"streams,omitempty"`
        Accounts         []types.Address      `json:"accounts,omitempty"`
        AccountsProposed []types.Address      `json:"accounts_proposed,omitempty"`
        Books            []SubscribeOrderBook `json:"books,omitempty"`
        Url              string               `json:"url,omitempty"`
        UrlUsername      string               `json:"url_username,omitempty"`
        UrlPassword      string               `json:"url_password,omitempty"`
}

func (*SubscribeRequest) Method() string <span class="cov0" title="0">{
        return "subscribe"
}</span>

type SubscribeOrderBook struct {
        TakerGets types.IssuedCurrencyAmount `json:"taker_gets"`
        TakerPays types.IssuedCurrencyAmount `json:"taker_pays"`
        Taker     types.Address              `json:"taker"`
        Snapshot  bool                       `json:"snapshot,omitempty"`
        Both      bool                       `json:"both,omitempty"`
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package subscribe

import "github.com/Peersyst/xrpl-go/xrpl/transaction/types"

type UnsubscribeRequest struct {
        Streams          []string               `json:"streams,omitempty"`
        Accounts         []types.Address        `json:"accounts,omitempty"`
        AccountsProposed []types.Address        `json:"accounts_proposed,omitempty"`
        Books            []UnsubscribeOrderBook `json:"books,omitempty"`
}

func (*UnsubscribeRequest) Method() string <span class="cov0" title="0">{
        return "unsubscribe"
}</span>

type UnsubscribeOrderBook struct {
        TakerGets types.IssuedCurrencyAmount `json:"taker_gets"`
        TakerPays types.IssuedCurrencyAmount `json:"taker_pays"`
        Both      bool                       `json:"both,omitempty"`
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package transaction

import "github.com/Peersyst/xrpl-go/xrpl/transaction"

type SubmitMultisignedRequest struct {
        Tx       transaction.FlatTransaction `json:"tx_json"`
        FailHard bool                        `json:"fail_hard"`
}

func (*SubmitMultisignedRequest) Method() string <span class="cov0" title="0">{
        return "submit_multisigned"
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package transaction

import "errors"

type SubmitRequest struct {
        TxBlob   string `json:"tx_blob"`
        FailHard bool   `json:"fail_hard,omitempty"`
}

func (*SubmitRequest) Method() string <span class="cov0" title="0">{
        return "submit"
}</span>

func (req *SubmitRequest) Validate() error <span class="cov0" title="0">{
        if req.TxBlob == "" </span><span class="cov0" title="0">{
                return errors.New("no TxBlob defined")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package transaction

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
)

type TransactionEntryRequest struct {
        LedgerHash  common.LedgerHash      `json:"ledger_hash,omitempty"`
        LedgerIndex common.LedgerSpecifier `json:"ledger_index,omitempty"`
        TxHash      string                 `json:"tx_hash"`
}

func (*TransactionEntryRequest) Method() string <span class="cov0" title="0">{
        return "transaction_entry"
}</span>

func (t *TransactionEntryRequest) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type terHelper struct {
                LedgerHash  common.LedgerHash `json:"ledger_hash,omitempty"`
                LedgerIndex json.RawMessage   `json:"ledger_index,omitempty"`
                TxHash      string            `json:"tx_hash"`
        }
        var h terHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*t = TransactionEntryRequest{
                LedgerHash: h.LedgerHash,
                TxHash:     h.TxHash,
        }

        i, err := common.UnmarshalLedgerSpecifier(h.LedgerIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">t.LedgerIndex = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package transaction

import "github.com/Peersyst/xrpl-go/xrpl/queries/common"

type TxRequest struct {
        Transaction string             `json:"transaction"`
        Binary      bool               `json:"binary,omitempty"`
        MinLedger   common.LedgerIndex `json:"min_ledger,omitempty"`
        MaxLedger   common.LedgerIndex `json:"max_ledger,omitempty"`
}

func (*TxRequest) Method() string <span class="cov0" title="0">{
        return "tx"
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package utility

type PingRequest struct{}

func (*PingRequest) Method() string <span class="cov0" title="0">{
        return "ping"
}</span>

func (*PingRequest) Validate() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package utility

type RandomRequest struct{}

func (*RandomRequest) Method() string <span class="cov0" title="0">{
        return "random"
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package rpc

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        requests "github.com/Peersyst/xrpl-go/xrpl/queries/transactions"
        jsoniter "github.com/json-iterator/go"
)

type JsonRpcClient struct {
        Config *JsonRpcConfig
}

type JsonRpcClientError struct {
        ErrorString string
}

func (e *JsonRpcClientError) Error() string <span class="cov8" title="1">{
        return e.ErrorString
}</span>

var ErrIncorrectId = errors.New("incorrect id")

func NewJsonRpcClient(cfg *JsonRpcConfig) *JsonRpcClient <span class="cov8" title="1">{
        return &amp;JsonRpcClient{
                Config: cfg,
        }
}</span>

// satisfy the Client interface
func (c *JsonRpcClient) SendRequest(reqParams JsonRpcXRPLRequest) (JsonRpcXRPLResponse, error) <span class="cov8" title="1">{

        err := reqParams.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">body, err := CreateRequest(reqParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodPost, c.Config.Url, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // add timeout context to prevent hanging
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
        defer cancel()
        req = req.WithContext(ctx)

        req.Header = c.Config.Headers

        var response *http.Response

        response, err = c.Config.HTTPClient.Do(req)
        if err != nil || response == nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // allow client to reuse persistant connection
        <span class="cov8" title="1">defer response.Body.Close()

        // Check for service unavailable response and retry if so
        if response.StatusCode == 503 </span><span class="cov8" title="1">{

                maxRetries := 3
                backoffDuration := 1 * time.Second

                for i := 0; i &lt; maxRetries; i++ </span><span class="cov8" title="1">{
                        time.Sleep(backoffDuration)

                        // Make request again after waiting
                        response, err = c.Config.HTTPClient.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if response.StatusCode != 503 </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // Increase backoff duration for the next retry
                        <span class="cov8" title="1">backoffDuration *= 2</span>
                }

                <span class="cov8" title="1">if response.StatusCode == 503 </span><span class="cov8" title="1">{
                        // Return service unavailable error here after retry 3 times
                        return nil, &amp;JsonRpcClientError{ErrorString: "Server is overloaded, rate limit exceeded"}
                }</span>

        }

        <span class="cov8" title="1">var jr JsonRpcResponse
        jr, err = CheckForError(response)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;jr, nil</span>
}

func (c *JsonRpcClient) SubmitTransactionBlob(txBlob string, failHard bool) (JsonRpcXRPLResponse, error) <span class="cov0" title="0">{
        submitRequest := &amp;requests.SubmitRequest{
                TxBlob:   txBlob,
                FailHard: failHard,
        }

        response, error := c.SendRequest(submitRequest)

        return response, error
}</span>

// CreateRequest formats the parameters and method name ready for sending request
// Params will have been serialised if required and added to request struct before being passed to this method
func CreateRequest(reqParams JsonRpcXRPLRequest) ([]byte, error) <span class="cov8" title="1">{

        var body JsonRpcRequest

        body = JsonRpcRequest{
                Method: reqParams.Method(),
                // each param object will have a struct with json serialising tags
                Params: [1]interface{}{reqParams},
        }

        // Omit the Params field if method doesn't require any
        paramBytes, err := jsoniter.Marshal(body.Params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">paramString := string(paramBytes)
        if strings.Compare(paramString, "[{}]") == 0 </span><span class="cov8" title="1">{
                // need to remove params field from the body if it is empty
                body = JsonRpcRequest{
                        Method: reqParams.Method(),
                }

                jsonBytes, err := jsoniter.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return jsonBytes, nil</span>
        }

        <span class="cov8" title="1">jsonBytes, err := jsoniter.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal JSON-RPC request for method %s with parameters %+v: %w", reqParams.Method(), reqParams, err)
        }</span>

        <span class="cov8" title="1">return jsonBytes, nil</span>
}

// CheckForError reads the http response and formats the error if it exists
func CheckForError(res *http.Response) (JsonRpcResponse, error) <span class="cov8" title="1">{

        var jr JsonRpcResponse

        b, err := io.ReadAll(res.Body)
        if err != nil || b == nil </span><span class="cov0" title="0">{
                return jr, err
        }</span>

        // In case a different error code is returned
        <span class="cov8" title="1">if res.StatusCode != 200 </span><span class="cov8" title="1">{
                return jr, &amp;JsonRpcClientError{ErrorString: string(b)}
        }</span>

        <span class="cov8" title="1">jDec := json.NewDecoder(bytes.NewReader(b))
        jDec.UseNumber()
        err = jDec.Decode(&amp;jr)
        if err != nil </span><span class="cov0" title="0">{
                return jr, err
        }</span>

        // result will have 'error' if error response
        <span class="cov8" title="1">if _, ok := jr.Result["error"]; ok </span><span class="cov8" title="1">{
                return jr, &amp;JsonRpcClientError{ErrorString: jr.Result["error"].(string)}
        }</span>

        <span class="cov8" title="1">return jr, nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package rpc

import (
        "errors"
        "net/http"
        "strings"
        "time"
)

var ErrEmptyUrl = errors.New("empty port and IP provided")

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

type JsonRpcConfig struct {
        HTTPClient HTTPClient
        Url        string
        Headers    map[string][]string
}

type JsonRpcConfigOpt func(c *JsonRpcConfig)

func WithHttpClient(cl HTTPClient) JsonRpcConfigOpt <span class="cov8" title="1">{
        return func(c *JsonRpcConfig) </span><span class="cov8" title="1">{
                c.HTTPClient = cl
        }</span>
}

func NewJsonRpcConfig(url string, opts ...JsonRpcConfigOpt) (*JsonRpcConfig, error) <span class="cov8" title="1">{

        // validate a url has been passed in
        if len(url) == 0 </span><span class="cov8" title="1">{
                return nil, ErrEmptyUrl
        }</span>
        // add slash if doesn't already end with one
        <span class="cov8" title="1">if !strings.HasSuffix(url, "/") </span><span class="cov8" title="1">{
                url += "/"
        }</span>

        <span class="cov8" title="1">cfg := &amp;JsonRpcConfig{
                HTTPClient: &amp;http.Client{Timeout: time.Duration(1) * time.Second}, // default timeout value - allow custom timme out?
                Url:        url,
                Headers: map[string][]string{
                        "Content-Type": {"application/json"},
                },
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(cfg)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package rpc

import (
        "github.com/Peersyst/xrpl-go/xrpl/currency"
        "github.com/Peersyst/xrpl-go/xrpl/queries/account"
        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/queries/ledger"
        "github.com/Peersyst/xrpl-go/xrpl/queries/server"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

func (r *JsonRpcClient) GetAccountChannels(req *account.AccountChannelsRequest) (*account.AccountChannelsResponse, error) <span class="cov0" title="0">{
        res, err := r.SendRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var acr account.AccountChannelsResponse
        err = res.GetResult(&amp;acr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;acr, nil</span>
}

// GetAccountInfo retrieves information about an account on the XRP Ledger.
// It takes an AccountInfoRequest as input and returns an AccountInfoResponse,
// along with the raw XRPL response and any error encountered.
func (r *JsonRpcClient) GetAccountInfo(req *account.AccountInfoRequest) (*account.AccountInfoResponse, error) <span class="cov0" title="0">{
        res, err := r.SendRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var air account.AccountInfoResponse
        err = res.GetResult(&amp;air)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;air, nil</span>
}

// GetAccountObjects retrieves a list of objects owned by an account on the XRP Ledger.
// It takes an AccountObjectsRequest as input and returns an AccountObjectsResponse,
// along with any error encountered.
func (r *JsonRpcClient) GetAccountObjects(req *account.AccountObjectsRequest) (*account.AccountObjectsResponse, error) <span class="cov0" title="0">{
        res, err := r.SendRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var acr account.AccountObjectsResponse
        err = res.GetResult(&amp;acr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;acr, nil</span>
}

// GetAccountLines retrieves the lines associated with an account on the XRP Ledger.
// It takes an AccountLinesRequest as input and returns an AccountLinesResponse,
// along with any error encountered.
func (r *JsonRpcClient) GetAccountLines(req *account.AccountLinesRequest) (*account.AccountLinesResponse, error) <span class="cov0" title="0">{
        res, err := r.SendRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var alr account.AccountLinesResponse
        err = res.GetResult(&amp;alr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;alr, nil</span>
}

// GetXrpBalance retrieves the XRP balance of a given account address.
// It returns the balance as a string in XRP (not drops) and any error encountered.
func (r *JsonRpcClient) GetXrpBalance(address string) (string, error) <span class="cov0" title="0">{
        res, err := r.GetAccountInfo(&amp;account.AccountInfoRequest{
                Account: types.Address(address),
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">xrpBalance, err := currency.DropsToXrp(res.AccountData.Balance.String())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return xrpBalance, nil</span>
}

// Returns the index of the most recently validated ledger.
func (r *JsonRpcClient) GetLedgerIndex() (*common.LedgerIndex, error) <span class="cov0" title="0">{
        res, err := r.SendRequest(&amp;ledger.LedgerRequest{
                LedgerIndex: common.LedgerTitle("validated"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var lr ledger.LedgerResponse
        err = res.GetResult(&amp;lr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;lr.LedgerIndex, nil</span>
}

// GetServerInfo retrieves information about the server.
// It takes a ServerInfoRequest as input and returns a ServerInfoResponse,
// along with any error encountered.
func (r *JsonRpcClient) GetServerInfo(req *server.ServerInfoRequest) (*server.ServerInfoResponse, error) <span class="cov0" title="0">{
        res, err := r.SendRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var sir server.ServerInfoResponse
        err = res.GetResult(&amp;sir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sir, nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package rpc

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction"
        "github.com/mitchellh/mapstructure"
)

type JsonRpcResponse struct {
        Result    AnyJson               `json:"result"`
        Warning   string                `json:"warning,omitempty"`
        Warnings  []XRPLResponseWarning `json:"warnings,omitempty"`
        Forwarded bool                  `json:"forwarded,omitempty"`
}

type XRPLResponseWarning struct {
        Id      int    `json:"id"`
        Message string `json:"message"`
        Details any    `json:"details,omitempty"`
}

type AnyJson transaction.FlatTransaction

type ApiWarning struct {
        Id      int         `json:"id"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
}

func (r JsonRpcResponse) GetResult(v any) error <span class="cov8" title="1">{
        dec, err := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{TagName: "json",
                Result: &amp;v, DecodeHook: mapstructure.TextUnmarshallerHookFunc()})

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = dec.Decode(r.Result)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type JsonRpcXRPLResponse interface {
        GetResult(v any) error
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package transaction

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type AccountDelete struct {
        BaseTx
        Destination    types.Address
        DestinationTag uint `json:",omitempty"`
}

func (*AccountDelete) TxType() TxType <span class="cov0" title="0">{
        return AccountDeleteTx
}</span>

// TODO: Implement flatten
func (s *AccountDelete) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package transaction

import (
        "errors"

        "github.com/Peersyst/xrpl-go/pkg/typecheck"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

const (
        //
        // Account Set Flags
        //
        // Require a destination tag to send transactions to this account.
        asfRequireDest uint = 1
        // Require authorization for users to hold balances issued by this address.
        // Can only be enabled if the address has no trust lines connected to it.
        asfRequireAuth uint = 2
        // XRP should not be sent to this account.
        asfDisallowXRP uint = 3
        // Disallow use of the master key pair. Can only be enabled if the account
        // has configured another way to sign transactions, such as a Regular Key or a
        // Signer List.
        asfDisableMaster uint = 4
        // Track the ID of this account's most recent transaction. Required for
        // AccountTxnID.
        asfAccountTxnID uint = 5
        // Permanently give up the ability to freeze individual trust lines or
        // disable Global Freeze. This flag can never be disabled after being enabled.
        asfNoFreeze uint = 6
        // Freeze all assets issued by this account.
        asfGlobalFreeze uint = 7
        // Enable rippling on this account's trust lines by default.
        asfDefaultRipple uint = 8
        // Enable Deposit Authorization on this account.
        asfDepositAuth uint = 9
        // Allow another account to mint and burn tokens on behalf of this account.
        asfAuthorizedNFTokenMinter uint = 10
        // asf 11 is reserved for Hooks amendment
        // Disallow other accounts from creating incoming NFTOffers
        asfDisallowIncomingNFTokenOffer uint = 12
        // Disallow other accounts from creating incoming Checks
        asfDisallowIncomingCheck uint = 13
        // Disallow other accounts from creating incoming Payment Channels
        asfDisallowIncomingPayChan uint = 14
        // Disallow other accounts from creating incoming TrustLines
        asfDisallowIncomingTrustLine uint = 15
        // Permanently gain the ability to claw back issued IOUs
        asfAllowTrustLineClawback uint = 16

        //
        // Transaction Flags
        //
        // The same as SetFlag: asfRequireDest.
        tfRequireDestTag uint = 65536 // 0x00010000
        // The same as ClearFlag: asfRequireDestTag.
        tfOptionalDestTag uint = 131072 // 0x00020000
        // The same as SetFlag: asfRequireAuth.
        tfRequireAuth uint = 262144 // 0x00040000
        // The same as ClearFlag: asfRequireAuth.
        tfOptionalAuth uint = 524288 // 0x00080000
        // The same as SetFlag: asfDisallowXRP.
        tfDisallowXRP uint = 1048576 // 0x00100000
        // The same as ClearFlag: asfDisallowXRP.
        tfAllowXRP uint = 2097152 // 0x00200000
)

// An AccountSet transaction modifies the properties of an account in the XRP
// Ledger.
type AccountSet struct {
        BaseTx
        // ClearFlag: asfRequireDestTag, asfOptionalDestTag, asfRequireAuth, asfOptionalAuth, asfDisallowXRP, asfAllowXRP
        ClearFlag uint `json:",omitempty"`
        // The domain that owns this account, as a string of hex representing the.
        // ASCII for the domain in lowercase.
        Domain string `json:",omitempty"`
        // Hash of an email address to be used for generating an avatar image.
        EmailHash types.Hash128 `json:",omitempty"`
        //Public key for sending encrypted messages to this account.
        MessageKey string `json:",omitempty"`
        // Sets an alternate account that is allowed to mint NFTokens on this
        // account's behalf using NFTokenMint's `Issuer` field.
        NFTokenMinter string `json:",omitempty"`
        // Integer flag to enable for this account.
        SetFlag uint `json:",omitempty"`
        // The fee to charge when users transfer this account's issued currencies,
        // represented as billionths of a unit. Cannot be more than 2000000000 or less
        // than 1000000000, except for the special case 0 meaning no fee.
        TransferRate uint `json:",omitempty"`
        // Tick size to use for offers involving a currency issued by this address.
        // The exchange rates of those offers is rounded to this many significant
        // digits. Valid values are 3 to 15 inclusive, or 0 to disable.
        TickSize      uint8         `json:",omitempty"`
        WalletLocator types.Hash256 `json:",omitempty"`
        WalletSize    uint          `json:",omitempty"`
}

// TxType returns the type of the transaction (AccountSet).
func (*AccountSet) TxType() TxType <span class="cov0" title="0">{
        return AccountSetTx
}</span>

// Flatten returns the flattened map of the AccountSet transaction.
func (s *AccountSet) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := s.BaseTx.Flatten()

        flattened["TransactionType"] = "AccountSet"

        if s.ClearFlag != 0 </span><span class="cov8" title="1">{
                flattened["ClearFlag"] = int(s.ClearFlag)
        }</span>
        <span class="cov8" title="1">if s.Domain != "" </span><span class="cov8" title="1">{
                flattened["Domain"] = s.Domain
        }</span>
        <span class="cov8" title="1">if s.EmailHash != "" </span><span class="cov8" title="1">{
                flattened["EmailHash"] = s.EmailHash.String()
        }</span>
        <span class="cov8" title="1">if s.MessageKey != "" </span><span class="cov8" title="1">{
                flattened["MessageKey"] = s.MessageKey
        }</span>
        <span class="cov8" title="1">if s.NFTokenMinter != "" </span><span class="cov0" title="0">{
                flattened["NFTokenMinter"] = s.NFTokenMinter
        }</span>
        <span class="cov8" title="1">if s.SetFlag != 0 </span><span class="cov8" title="1">{
                flattened["SetFlag"] = int(s.SetFlag)
        }</span>
        <span class="cov8" title="1">if s.TransferRate != 0 </span><span class="cov8" title="1">{
                flattened["TransferRate"] = int(s.TransferRate)
        }</span>
        <span class="cov8" title="1">if s.TickSize != 0 </span><span class="cov8" title="1">{
                flattened["TickSize"] = int(s.TickSize)
        }</span>
        <span class="cov8" title="1">if s.WalletLocator != "" </span><span class="cov0" title="0">{
                flattened["WalletLocator"] = s.WalletLocator.String()
        }</span>
        <span class="cov8" title="1">if s.WalletSize != 0 </span><span class="cov0" title="0">{
                flattened["WalletSize"] = int(s.WalletSize)
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

// SetRequireDestTag sets the require destination tag flag.
func (s *AccountSet) SetRequireDestTag() <span class="cov8" title="1">{
        s.Flags |= tfRequireDestTag
}</span>

// SetRequireAuth sets the require auth flag.
func (s *AccountSet) SetRequireAuth() <span class="cov8" title="1">{
        s.Flags |= tfRequireAuth
}</span>

// SetDisallowXRP sets the disallow XRP flag.
func (s *AccountSet) SetDisallowXRP() <span class="cov8" title="1">{
        s.Flags |= tfDisallowXRP
}</span>

// SetOptionalDestTag sets the optional destination tag flag.
func (s *AccountSet) SetOptionalDestTag() <span class="cov8" title="1">{
        s.Flags |= tfOptionalDestTag
}</span>

// SetOptionalAuth sets the optional auth flag.
func (s *AccountSet) SetOptionalAuth() <span class="cov0" title="0">{
        s.Flags |= tfOptionalAuth
}</span>

// SetAllowXRP sets the allow XRP flag.
func (s *AccountSet) SetAllowXRP() <span class="cov0" title="0">{
        s.Flags |= tfAllowXRP
}</span>

// SetAsfRequireDest sets the require destination tag flag.
func (s *AccountSet) SetAsfRequireDest() <span class="cov0" title="0">{
        s.SetFlag = asfRequireDest
}</span>

// ClearAsfRequireDest clears the require destination tag flag.
func (s *AccountSet) ClearAsfRequireDest() <span class="cov0" title="0">{
        s.ClearFlag = asfRequireDest
}</span>

// SetAsfRequireAuth sets the require authorization flag.
func (s *AccountSet) SetAsfRequireAuth() <span class="cov0" title="0">{
        s.SetFlag = asfRequireAuth
}</span>

// ClearAsfRequireAuth clears the require authorization flag.
func (s *AccountSet) ClearAsfRequireAuth() <span class="cov0" title="0">{
        s.ClearFlag = asfRequireAuth
}</span>

// SetAsfDisallowXRP sets the disallow XRP flag.
func (s *AccountSet) SetAsfDisallowXRP() <span class="cov0" title="0">{
        s.SetFlag = asfDisallowXRP
}</span>

// ClearAsfDisallowXRP clears the disallow XRP flag.
func (s *AccountSet) ClearAsfDisallowXRP() <span class="cov0" title="0">{
        s.ClearFlag = asfDisallowXRP
}</span>

// SetAsfDisableMaster sets the disable master key flag.
func (s *AccountSet) SetAsfDisableMaster() <span class="cov0" title="0">{
        s.SetFlag = asfDisableMaster
}</span>

// ClearAsfDisableMaster clears the disable master key flag.
func (s *AccountSet) ClearAsfDisableMaster() <span class="cov0" title="0">{
        s.ClearFlag = asfDisableMaster
}</span>

// SetAsfAccountTxnID sets the account transaction ID flag.
func (s *AccountSet) SetAsfAccountTxnID() <span class="cov0" title="0">{
        s.SetFlag = asfAccountTxnID
}</span>

// ClearAsfAccountTxnID clears the account transaction ID flag.
func (s *AccountSet) ClearAsfAccountTxnID() <span class="cov0" title="0">{
        s.ClearFlag = asfAccountTxnID
}</span>

// SetAsfNoFreeze sets the no freeze flag.
func (s *AccountSet) SetAsfNoFreeze() <span class="cov0" title="0">{
        s.SetFlag = asfNoFreeze
}</span>

// ClearAsfNoFreeze clears the no freeze flag.
func (s *AccountSet) ClearAsfNoFreeze() <span class="cov0" title="0">{
        s.ClearFlag = asfNoFreeze
}</span>

// SetAsfGlobalFreeze sets the global freeze flag.
func (s *AccountSet) SetAsfGlobalFreeze() <span class="cov0" title="0">{
        s.SetFlag = asfGlobalFreeze
}</span>

// ClearAsfGlobalFreeze clears the global freeze flag.
func (s *AccountSet) ClearAsfGlobalFreeze() <span class="cov0" title="0">{
        s.ClearFlag = asfGlobalFreeze
}</span>

// SetAsfDefaultRipple sets the default ripple flag.
func (s *AccountSet) SetAsfDefaultRipple() <span class="cov0" title="0">{
        s.SetFlag = asfDefaultRipple
}</span>

// ClearAsfDefaultRipple clears the default ripple flag.
func (s *AccountSet) ClearAsfDefaultRipple() <span class="cov0" title="0">{
        s.ClearFlag = asfDefaultRipple
}</span>

// SetAsfDepositAuth sets the deposit authorization flag.
func (s *AccountSet) SetAsfDepositAuth() <span class="cov0" title="0">{
        s.SetFlag = asfDepositAuth
}</span>

// ClearAsfDepositAuth clears the deposit authorization flag.
func (s *AccountSet) ClearAsfDepositAuth() <span class="cov0" title="0">{
        s.ClearFlag = asfDepositAuth
}</span>

// SetAsfAuthorizedNFTokenMinter sets the authorized NFToken minter flag.
func (s *AccountSet) SetAsfAuthorizedNFTokenMinter() <span class="cov0" title="0">{
        s.SetFlag = asfAuthorizedNFTokenMinter
}</span>

// ClearAsfAuthorizedNFTokenMinter clears the authorized NFToken minter flag.
func (s *AccountSet) ClearAsfAuthorizedNFTokenMinter() <span class="cov0" title="0">{
        s.ClearFlag = asfAuthorizedNFTokenMinter
}</span>

// SetAsfDisallowIncomingNFTokenOffer sets the disallow incoming NFToken offer flag.
func (s *AccountSet) SetAsfDisallowIncomingNFTokenOffer() <span class="cov0" title="0">{
        s.SetFlag = asfDisallowIncomingNFTokenOffer
}</span>

// ClearAsfDisallowIncomingNFTokenOffer clears the disallow incoming NFToken offer flag.
func (s *AccountSet) ClearAsfDisallowIncomingNFTokenOffer() <span class="cov0" title="0">{
        s.ClearFlag = asfDisallowIncomingNFTokenOffer
}</span>

// SetAsfDisallowIncomingCheck sets the disallow incoming check flag.
func (s *AccountSet) SetAsfDisallowIncomingCheck() <span class="cov0" title="0">{
        s.SetFlag = asfDisallowIncomingCheck
}</span>

// ClearAsfDisallowIncomingCheck clears the disallow incoming check flag.
func (s *AccountSet) ClearAsfDisallowIncomingCheck() <span class="cov0" title="0">{
        s.ClearFlag = asfDisallowIncomingCheck
}</span>

// SetAsfDisallowIncomingPayChan sets the disallow incoming payment channel flag.
func (s *AccountSet) SetAsfDisallowIncomingPayChan() <span class="cov0" title="0">{
        s.SetFlag = asfDisallowIncomingPayChan
}</span>

// ClearAsfDisallowIncomingPayChan clears the disallow incoming payment channel flag.
func (s *AccountSet) ClearAsfDisallowIncomingPayChan() <span class="cov0" title="0">{
        s.ClearFlag = asfDisallowIncomingPayChan
}</span>

// SetAsfDisallowIncomingTrustLine sets the disallow incoming trust line flag.
func (s *AccountSet) SetAsfDisallowIncomingTrustLine() <span class="cov0" title="0">{
        s.SetFlag = asfDisallowIncomingTrustLine
}</span>

// ClearAsfDisallowIncomingTrustLine clears the disallow incoming trust line flag.
func (s *AccountSet) ClearAsfDisallowIncomingTrustLine() <span class="cov0" title="0">{
        s.ClearFlag = asfDisallowIncomingTrustLine
}</span>

// SetAsfAllowTrustLineClawback sets the allow trust line clawback flag.
func (s *AccountSet) SetAsfAllowTrustLineClawback() <span class="cov0" title="0">{
        s.SetFlag = asfAllowTrustLineClawback
}</span>

// ClearAsfAllowTrustLineClawback clears the allow trust line clawback flag.
func (s *AccountSet) ClearAsfAllowTrustLineClawback() <span class="cov0" title="0">{
        s.ClearFlag = asfAllowTrustLineClawback
}</span>

// Tick size to use for offers involving a currency issued by this address.
// The exchange rates of those offers is rounded to this many significant digits.
// Valid values are 3 to 15 inclusive, or 0 to disable.
const MIN_TICK_SIZE = 3
const MAX_TICK_SIZE = 15

// Validate the AccountSet transaction fields.
func (s *AccountSet) Validate() (bool, error) <span class="cov8" title="1">{
        flatten := s.Flatten()

        // validate the base transaction
        _, err := s.BaseTx.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "ClearFlag", typecheck.IsInt)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "Domain", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "EmailHash", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "MessageKey", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "SetFlag", typecheck.IsInt)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "TransferRate", typecheck.IsInt)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "TickSize", typecheck.IsInt)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "NFTokenMinter", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "WalletLocator", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flatten, "WalletSize", typecheck.IsInt)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // check if SetFlag is within the valid range
        <span class="cov8" title="1">if s.SetFlag != 0 </span><span class="cov8" title="1">{
                if s.SetFlag &lt; asfRequireDest || s.SetFlag &gt; asfAllowTrustLineClawback </span><span class="cov8" title="1">{
                        return false, errors.New("accountSet: SetFlag must be an integer between asfRequireDest (1) and asfAllowTrustLineClawback (16)")
                }</span>
        }

        // check if TickSize is within the valid range
        <span class="cov8" title="1">if s.TickSize != 0 &amp;&amp; (s.TickSize &lt; MIN_TICK_SIZE || s.TickSize &gt; MAX_TICK_SIZE) </span><span class="cov8" title="1">{
                return false, errors.New("accountSet: TickSize must be between 3 and 15")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package transaction

import (
        "errors"

        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        ledger "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// Bid on an Automated Market Maker's (AMM's) auction slot. If you win, you can trade against the AMM at a discounted fee until you are outbid or 24 hours have passed.
// If you are outbid before 24 hours have passed, you are refunded part of the cost of your bid based on how much time remains.
// If the AMM's trading fee is zero, you can still bid, but the auction slot provides no benefit unless the trading fee changes.
// You bid using the AMM's LP Tokens; the amount of a winning bid is returned to the AMM, decreasing the outstanding balance of LP Tokens.
// https://xrpl.org/docs/references/protocol/transactions/types/ammbid
//
// Example:
//
//        {
//            "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//            "Asset" : {
//                "currency" : "XRP"
//            },
//            "Asset2" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd"
//            },
//            "AuthAccounts" : [
//                {
//                  "AuthAccount" : {
//                      "Account" : "rMKXGCbJ5d8LbrqthdG46q3f969MVK2Qeg"
//                  }
//                },
//                {
//                  "AuthAccount" : {
//                      "Account" : "rBepJuTLFJt3WmtLXYAxSjtBWAeQxVbncv"
//                  }
//                }
//            ],
//            "BidMax" : {
//                "currency" : "039C99CD9AB0B70B32ECDA51EAAE471625608EA2",
//                "issuer" : "rE54zDvgnghAoPopCgvtiqWNq3dU5y836S",
//                "value" : "100"
//            },
//            "Fee" : "10",
//            "Flags" : 2147483648,
//            "Sequence" : 9,
//            "TransactionType" : "AMMBid"
//        }
type AMMBid struct {
        BaseTx
        // The definition for one of the assets in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset ledger.Asset
        // The definition for the other asset in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset2 ledger.Asset
        // Pay at least this amount for the slot. Setting this value higher makes it harder for others to outbid you. If omitted, pay the minimum necessary to win the bid.
        BidMin types.CurrencyAmount `json:",omitempty"`
        // Pay at most this amount for the slot. If the cost to win the bid is higher than this amount, the transaction fails. If omitted, pay as much as necessary to win the bid.
        BidMax types.CurrencyAmount `json:",omitempty"`
        // A list of up to 4 additional accounts that you allow to trade at the discounted fee. This cannot include the address of the transaction sender. Each of these objects should be an Auth Account object.
        AuthAccounts []ledger.AuthAccounts `json:",omitempty"`
}

func (*AMMBid) TxType() TxType <span class="cov8" title="1">{
        return AMMBidTx
}</span>

func (a *AMMBid) Flatten() FlatTransaction <span class="cov8" title="1">{
        // Add BaseTx fields
        flattened := a.BaseTx.Flatten()

        // Add AMMBid-specific fields
        flattened["TransactionType"] = "AMMBid"

        flattened["Asset"] = a.Asset.Flatten()

        flattened["Asset2"] = a.Asset2.Flatten()

        if a.BidMin != nil </span><span class="cov8" title="1">{
                flattened["BidMin"] = a.BidMin.Flatten()
        }</span>

        <span class="cov8" title="1">if a.BidMax != nil </span><span class="cov8" title="1">{
                flattened["BidMax"] = a.BidMax.Flatten()
        }</span>

        <span class="cov8" title="1">if len(a.AuthAccounts) &gt; 0 </span><span class="cov8" title="1">{
                authAccountsFlattened := make([]map[string]interface{}, 0)

                for _, authAccount := range a.AuthAccounts </span><span class="cov8" title="1">{
                        authAccountsFlattened = append(authAccountsFlattened, authAccount.Flatten())
                }</span>

                <span class="cov8" title="1">flattened["AuthAccounts"] = authAccountsFlattened</span>
        }

        <span class="cov8" title="1">return flattened</span>
}

func (a *AMMBid) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := a.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset2); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if a.Asset.Currency == "XRP" &amp;&amp; a.Asset2.Currency == "XRP" </span><span class="cov8" title="1">{
                return false, errors.New("at least one of the assets must be non-XRP")
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.BidMin, "BidMin", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.BidMax, "BidMax", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := validateAuthAccounts(a.AuthAccounts); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// Validate the AuthAccounts field.
func validateAuthAccounts(authAccounts []ledger.AuthAccounts) (bool, error) <span class="cov8" title="1">{
        if len(authAccounts) &gt; 4 </span><span class="cov8" title="1">{
                return false, errors.New("authAccounts: AuthAccounts should have at most 4 AuthAccount objects")
        }</span>

        <span class="cov8" title="1">for _, authAccounts := range authAccounts </span><span class="cov8" title="1">{
                if ok := addresscodec.IsValidClassicAddress(authAccounts.AuthAccount.Account.String()); !ok </span><span class="cov8" title="1">{
                        return false, errors.New("authAccounts: Account is not a valid classic address")
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package transaction

import (
        "fmt"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// The maximum value is 1000, indicating a 1% fee. The minimum value is 0. https://xrpl.org/docs/references/protocol/transactions/types/ammcreate#ammcreate-fields
const AMM_MAX_TRADING_FEE = 1000

type AMMCreate struct {
        BaseTx
        // The first of the two assets to fund this AMM with. This must be a positive amount.
        Amount types.CurrencyAmount
        // The second of the two assets to fund this AMM with. This must be a positive amount.
        Amount2 types.CurrencyAmount
        // The fee to charge for trades against this AMM instance, in units of 1/100,000; a value of 1 is equivalent to 0.001%. The maximum value is 1000, indicating a 1% fee. The minimum value is 0.
        TradingFee uint16
}

func (*AMMCreate) TxType() TxType <span class="cov8" title="1">{
        return AMMCreateTx
}</span>

func (s *AMMCreate) Flatten() FlatTransaction <span class="cov8" title="1">{
        // Add BaseTx fields
        flattened := s.BaseTx.Flatten()

        // Add AMMCreate-specific fields
        flattened["TransactionType"] = "AMMCreate"

        if s.Amount != nil </span><span class="cov8" title="1">{
                flattened["Amount"] = s.Amount.Flatten()
        }</span>

        <span class="cov8" title="1">if s.Amount2 != nil </span><span class="cov8" title="1">{
                flattened["Amount2"] = s.Amount2.Flatten()
        }</span>

        <span class="cov8" title="1">flattened["TradingFee"] = s.TradingFee

        return flattened</span>
}

func (a *AMMCreate) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := a.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.Amount, "Amount", true); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.Amount2, "Amount2", true); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if a.TradingFee &gt; AMM_MAX_TRADING_FEE </span><span class="cov8" title="1">{
                return false, fmt.Errorf("trading fee is too high, max value is %d", AMM_MAX_TRADING_FEE)
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package transaction

import (
        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
)

// Delete an empty Automated Market Maker (AMM) instance that could not be fully deleted automatically.
// Normally, an AMMWithdraw transaction automatically deletes an AMM and all associated ledger entries when it withdraws all the assets from the AMM's pool.
// However, if there are too many trust lines to the AMM account to remove in one transaction, it may stop before fully removing the AMM.
// Similarly, an AMMDelete transaction removes up to a maximum of 512 trust lines; it may take several AMMDelete transactions to delete all the trust lines and the associated AMM.
// In all cases, only the last such transaction deletes the AMM and AccountRoot ledger entries.
//
// Example:
//
// ```json
//
//        {
//            "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//            "Asset" : {
//                "currency" : "XRP"
//            },
//            "Asset2" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd"
//            },
//            "Fee" : "10",
//            "Flags" : 0,
//            "Sequence" : 9,
//            "TransactionType" : "AMMDelete"
//        }
//
// ```
type AMMDelete struct {
        BaseTx
        // The definition for one of the assets in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset ledger.Asset
        // The definition for the other asset in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset2 ledger.Asset
}

func (*AMMDelete) TxType() TxType <span class="cov8" title="1">{
        return AMMDeleteTx
}</span>

func (a *AMMDelete) Flatten() FlatTransaction <span class="cov8" title="1">{
        // Add BaseTx fields
        flattened := a.BaseTx.Flatten()

        // Add AMMDelete-specific fields
        flattened["TransactionType"] = "AMMDelete"

        flattened["Asset"] = a.Asset.Flatten()

        flattened["Asset2"] = a.Asset2.Flatten()
        return flattened
}</span>

func (a *AMMDelete) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := a.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset2); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package transaction

import (
        "errors"

        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// Deposit funds into an Automated Market Maker (AMM) instance and receive the AMM's liquidity provider tokens (LP Tokens) in exchange.
// You can deposit one or both of the assets in the AMM's pool.
// If successful, this transaction creates a trust line to the AMM Account (limit 0) to hold the LP Tokens.
//
// Example:
//
// ```json
//
//        {
//            "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//            "Amount" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd",
//                "value" : "2.5"
//            },
//            "Amount2" : "30000000",
//            "Asset" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd"
//            },
//            "Asset2" : {
//                "currency" : "XRP"
//            },
//            "Fee" : "10",
//            "Flags" : 1048576,
//            "Sequence" : 7,
//            "TransactionType" : "AMMDeposit"
//        }
//
// ```
type AMMDeposit struct {
        BaseTx
        // The definition for one of the assets in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset ledger.Asset
        // The definition for the other asset in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset2 ledger.Asset
        // The amount of one asset to deposit to the AMM. If present, this must match the type of one of the assets (tokens or XRP) in the AMM's pool.
        Amount types.CurrencyAmount `json:",omitempty"`
        // The amount of another asset to add to the AMM. If present, this must match the type of the other asset in the AMM's pool and cannot be the same asset as Amount.
        Amount2 types.CurrencyAmount `json:",omitempty"`
        // The maximum effective price, in the deposit asset, to pay for each LP Token received.
        EPrice types.CurrencyAmount `json:",omitempty"`
        // How many of the AMM's LP Tokens to buy.
        LPTokenOut types.CurrencyAmount `json:",omitempty"`
        // Submit a vote for the AMM's trading fee, in units of 1/100,000; a value of 1 is equivalent to 0.001%. The maximum value is 1000, indicating a 1% fee.
        TradingFee uint16 `json:",omitempty"`
}

// ****************************
// AMMDeposit Flags
// ****************************

// You must specify exactly one of these flags, plus any global flags.
const (
        // Perform a special double-asset deposit to an AMM with an empty pool.
        tfTwoAssetIfEmpty uint = 8388608
)

// Perform a double-asset deposit and receive the specified amount of LP Tokens.
func (a *AMMDeposit) SetLPTokentFlag() <span class="cov8" title="1">{
        a.Flags |= tfLPToken
}</span>

// Perform a single-asset deposit with a specified amount of the asset to deposit.
func (a *AMMDeposit) SetSingleAssetFlag() <span class="cov8" title="1">{
        a.Flags |= tfSingleAsset
}</span>

// Perform a double-asset deposit with specified amounts of both assets.
func (a *AMMDeposit) SetTwoAssetFlag() <span class="cov8" title="1">{
        a.Flags |= tfTwoAsset
}</span>

// Perform a single-asset deposit and receive the specified amount of LP Tokens.
func (a *AMMDeposit) SetOneAssetLPTokenFlag() <span class="cov8" title="1">{
        a.Flags |= tfOneAssetLPToken
}</span>

// Perform a single-asset deposit with a specified effective price.
func (a *AMMDeposit) SetLimitLPTokenFlag() <span class="cov8" title="1">{
        a.Flags |= tfLimitLPToken
}</span>

// Perform a special double-asset deposit to an AMM with an empty pool.
func (a *AMMDeposit) SetTwoAssetIfEmptyFlag() <span class="cov8" title="1">{
        a.Flags |= tfTwoAssetIfEmpty
}</span>

func (*AMMDeposit) TxType() TxType <span class="cov8" title="1">{
        return AMMDepositTx
}</span>

func (a *AMMDeposit) Flatten() FlatTransaction <span class="cov8" title="1">{

        // Add BaseTx fields
        flattened := a.BaseTx.Flatten()

        // Add AMMDeposit-specific fields
        flattened["TransactionType"] = "AMMDeposit"

        flattened["Asset"] = a.Asset.Flatten()
        flattened["Asset2"] = a.Asset2.Flatten()

        if a.Amount != nil </span><span class="cov8" title="1">{
                flattened["Amount"] = a.Amount.Flatten()
        }</span>

        <span class="cov8" title="1">if a.Amount2 != nil </span><span class="cov8" title="1">{
                flattened["Amount2"] = a.Amount2.Flatten()
        }</span>

        <span class="cov8" title="1">if a.EPrice != nil </span><span class="cov8" title="1">{
                flattened["EPrice"] = a.EPrice.Flatten()
        }</span>

        <span class="cov8" title="1">if a.LPTokenOut != nil </span><span class="cov8" title="1">{
                flattened["LPTokenOut"] = a.LPTokenOut.Flatten()
        }</span>

        <span class="cov8" title="1">if a.TradingFee != 0 </span><span class="cov8" title="1">{
                flattened["TradingFee"] = a.TradingFee
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

func (a *AMMDeposit) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := a.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset2); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if a.Amount2 != nil &amp;&amp; a.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("ammDeposit: must set Amount with Amount2")
        }</span> else<span class="cov8" title="1"> if a.EPrice != nil &amp;&amp; a.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("ammDeposit: must set Amount with EPrice")
        }</span> else<span class="cov8" title="1"> if a.LPTokenOut == nil &amp;&amp; a.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("ammDeposit:  must set at least LPTokenOut or Amount")
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.Amount, "Amount", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.Amount2, "Amount", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.EPrice, "EPrice", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package transaction

import (
        "errors"

        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
)

// Vote on the trading fee for an Automated Market Maker instance. Up to 8 accounts can vote in proportion to the amount of the AMM's LP Tokens they hold.
// Each new vote re-calculates the AMM's trading fee based on a weighted average of the votes.
//
// Example:
//
// ```json
//
//        {
//            "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//            "Asset" : {
//                "currency" : "XRP"
//            },
//            "Asset2" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd"
//            },
//            "Fee" : "10",
//            "Flags" : 2147483648,
//            "Sequence" : 8,
//            "TradingFee" : 600,
//            "TransactionType" : "AMMVote"
//        }
//
// ```
type AMMVote struct {
        BaseTx
        // The definition for one of the assets in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset ledger.Asset
        // The definition for the other asset in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset2 ledger.Asset
        // The proposed fee to vote for, in units of 1/100,000; a value of 1 is equivalent to 0.001%. The maximum value is 1000, indicating a 1% fee.
        TradingFee uint16
}

// TxType returns the type of the transaction (AMMVote).
func (*AMMVote) TxType() TxType <span class="cov8" title="1">{
        return AMMVoteTx
}</span>

// Flatten returns the flattened map of the AMMVote transaction.
func (a *AMMVote) Flatten() FlatTransaction <span class="cov8" title="1">{
        // Add BaseTx fields
        flattened := a.BaseTx.Flatten()

        // Add AMMDelete-specific fields
        flattened["TransactionType"] = "AMMVote"
        flattened["Asset"] = a.Asset.Flatten()
        flattened["Asset2"] = a.Asset2.Flatten()
        flattened["TradingFee"] = a.TradingFee

        return flattened
}</span>

// Validates the AMMVote struct and make sure all the fields are correct.
func (a *AMMVote) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := a.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset2); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if a.TradingFee &gt; 1000 </span><span class="cov8" title="1">{
                return false, errors.New("tradingFee must be less than or equal to 1000")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package transaction

import (
        "errors"

        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// Withdraw assets from an Automated Market Maker (AMM) instance by returning the AMM's liquidity provider tokens (LP Tokens).
//
// # Example
//
// ```json
//
//        {
//            "Account" : "rJVUeRqDFNs2xqA7ncVE6ZoAhPUoaJJSQm",
//            "Amount" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd",
//                "value" : "5"
//            },
//            "Amount2" : "50000000",
//            "Asset" : {
//                "currency" : "TST",
//                "issuer" : "rP9jPyP5kyvFRb6ZiRghAGw5u8SGAmU4bd"
//            },
//            "Asset2" : {
//                "currency" : "XRP"
//            },
//            "Fee" : "10",
//            "Flags" : 1048576,
//            "Sequence" : 10,
//            "TransactionType" : "AMMWithdraw"
//        }
//
// / ```
type AMMWithdraw struct {
        BaseTx
        // The definition for one of the assets in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset ledger.Asset
        // The definition for the other asset in the AMM's pool. In JSON, this is an object with currency and issuer fields (omit issuer for XRP).
        Asset2 ledger.Asset
        // The amount of one asset to withdraw from the AMM. This must match the type of one of the assets (tokens or XRP) in the AMM's pool.
        Amount types.CurrencyAmount `json:",omitempty"`
        // The amount of another asset to withdraw from the AMM. If present, this must match the type of the other asset in the AMM's pool and cannot be the same type as Amount.
        Amount2 types.CurrencyAmount `json:",omitempty"`
        // The minimum effective price, in LP Token returned, to pay per unit of the asset to withdraw.
        EPrice types.CurrencyAmount `json:",omitempty"`
        // How many of the AMM's LP Tokens to redeem.
        LPTokenIn types.IssuedCurrencyAmount `json:",omitempty"`
}

// ****************************
// AMMWithdraw Flags
// ****************************

const (
        // Perform a double-asset withdrawal returning all your LP Tokens.
        tfWithdrawAll uint = 131072
        // Perform a single-asset withdrawal returning all of your LP Tokens.
        tfOneAssetWithdrawAll uint = 262144
)

// Perform a double-asset withdrawal and receive the specified amount of LP Tokens.
func (a *AMMWithdraw) SetLPTokentFlag() <span class="cov8" title="1">{
        a.Flags |= tfLPToken
}</span>

// Perform a double-asset withdrawal returning all your LP Tokens.
func (a *AMMWithdraw) SetWithdrawAllFlag() <span class="cov8" title="1">{
        a.Flags |= tfWithdrawAll
}</span>

// Perform a single-asset withdrawal returning all of your LP Tokens.
func (a *AMMWithdraw) SetOneAssetWithdrawAllFlag() <span class="cov8" title="1">{
        a.Flags |= tfOneAssetWithdrawAll
}</span>

// Perform a single-asset withdrawal with a specified amount of the asset to withdrawal.
func (a *AMMWithdraw) SetSingleAssetFlag() <span class="cov8" title="1">{
        a.Flags |= tfSingleAsset
}</span>

// Perform a double-asset withdrawal with specified amounts of both assets.
func (a *AMMWithdraw) SetTwoAssetFlag() <span class="cov8" title="1">{
        a.Flags |= tfTwoAsset
}</span>

// Perform a single-asset withdrawal and receive the specified amount of LP Tokens.
func (a *AMMWithdraw) SetOneAssetLPTokenFlag() <span class="cov8" title="1">{
        a.Flags |= tfOneAssetLPToken
}</span>

// Perform a single-asset withdrawal with a specified effective price.
func (a *AMMWithdraw) SetLimitLPTokenFlag() <span class="cov8" title="1">{
        a.Flags |= tfLimitLPToken
}</span>

// TxType returns the type of the transaction (AMMWithdraw).
func (*AMMWithdraw) TxType() TxType <span class="cov8" title="1">{
        return AMMWithdrawTx
}</span>

// Flatten returns the flattened map of the AMMWithdraw transaction.
func (a *AMMWithdraw) Flatten() FlatTransaction <span class="cov8" title="1">{
        // Add BaseTx fields
        flattened := a.BaseTx.Flatten()

        // Add AMMWithdraw-specific fields
        flattened["TransactionType"] = "AMMWithdraw"

        flattened["Asset"] = a.Asset.Flatten()
        flattened["Asset2"] = a.Asset2.Flatten()

        if a.Amount != nil </span><span class="cov8" title="1">{
                flattened["Amount"] = a.Amount.Flatten()
        }</span>
        <span class="cov8" title="1">if a.Amount2 != nil </span><span class="cov8" title="1">{
                flattened["Amount2"] = a.Amount2.Flatten()
        }</span>
        <span class="cov8" title="1">if a.EPrice != nil </span><span class="cov8" title="1">{
                flattened["EPrice"] = a.EPrice.Flatten()
        }</span>
        <span class="cov8" title="1">if !a.LPTokenIn.IsZero() </span><span class="cov8" title="1">{
                flattened["LPTokenIn"] = a.LPTokenIn.Flatten()
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

// Validates the AMMWithdraw struct and make sure all the fields are correct.
func (a *AMMWithdraw) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := a.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAsset(a.Asset2); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if a.Amount2 != nil &amp;&amp; a.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("ammWithdraw: must set Amount with Amount2")
        }</span> else<span class="cov8" title="1"> if a.EPrice != nil &amp;&amp; a.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("ammWithdraw: must set Amount with EPrice")
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.Amount, "Amount", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.Amount2, "Amount2", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(a.EPrice, "EPrice", false); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsIssuedCurrency(a.LPTokenIn); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package transaction

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type CheckCancel struct {
        BaseTx
        CheckID types.Hash256
}

// TODO: Implement flatten
func (*CheckCancel) TxType() TxType <span class="cov0" title="0">{
        return CheckCancelTx
}</span>

func (s *CheckCancel) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file147" style="display: none">package transaction
=======
		<pre class="file" id="file143" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type CheckCash struct {
        BaseTx
        CheckID    types.Hash256
        Amount     types.CurrencyAmount `json:",omitempty"`
        DeliverMin types.CurrencyAmount `json:",omitempty"`
}

func (*CheckCash) TxType() TxType <span class="cov0" title="0">{
        return CheckCashTx
}</span>

// TODO: Implement flatten
func (s *CheckCash) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>

func (tx *CheckCash) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type ccHelper struct {
                BaseTx
                CheckID    types.Hash256
                Amount     json.RawMessage `json:",omitempty"`
                DeliverMin json.RawMessage `json:",omitempty"`
        }
        var h ccHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*tx = CheckCash{
                BaseTx:  h.BaseTx,
                CheckID: h.CheckID,
        }

        var amount, min types.CurrencyAmount
        var err error
        amount, err = types.UnmarshalCurrencyAmount(h.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">min, err = types.UnmarshalCurrencyAmount(h.DeliverMin)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx.Amount = amount
        tx.DeliverMin = min
        return nil</span>

}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file148" style="display: none">package transaction
=======
		<pre class="file" id="file144" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type CheckCreate struct {
        BaseTx
        Destination    types.Address
        SendMax        types.CurrencyAmount
        DestinationTag uint          `json:",omitempty"`
        Expiration     uint          `json:",omitempty"`
        InvoiceID      types.Hash256 `json:",omitempty"`
}

func (*CheckCreate) TxType() TxType <span class="cov0" title="0">{
        return CheckCreateTx
}</span>

// TODO: Implement flatten
func (s *CheckCreate) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>

func (c *CheckCreate) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type ccHelper struct {
                BaseTx
                Destination    types.Address
                SendMax        json.RawMessage
                DestinationTag uint          `json:",omitempty"`
                Expiration     uint          `json:",omitempty"`
                InvoiceID      types.Hash256 `json:",omitempty"`
        }
        var h ccHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*c = CheckCreate{
                BaseTx:         h.BaseTx,
                Destination:    h.Destination,
                DestinationTag: h.DestinationTag,
                Expiration:     h.Expiration,
                InvoiceID:      h.InvoiceID,
        }

        max, err := types.UnmarshalCurrencyAmount(h.SendMax)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">c.SendMax = max

        return nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file149" style="display: none">package transaction
=======
		<pre class="file" id="file145" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"
        "errors"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// Requires the Clawback amendment.
// Claw back tokens issued by your account.
// Clawback is disabled by default. To use clawback, you must send an AccountSet transaction to enable the Allow Trust Line Clawback setting.
// An issuer with any existing tokens cannot enable Clawback. You can only enable Allow Trust Line Clawback if you have a completely empty owner directory,
// meaning you must do so before you set up any trust lines, offers, escrows, payment channels, checks, or signer lists. After you enable Clawback,
// it cannot reverted: the account permanently gains the ability to claw back issued assets on trust lines.
type Clawback struct {
        // Base transaction fields
        BaseTx

        // Indicates the amount being clawed back, as well as the counterparty from which the amount is being clawed back.
        // The quantity to claw back, in the value sub-field, must not be zero. If this is more than the current balance,
        // the transaction claws back the entire balance. The sub-field issuer within Amount represents the token holder's
        // account ID, rather than the issuer's.
        Amount types.CurrencyAmount
}

func (*Clawback) TxType() TxType <span class="cov0" title="0">{
        return ClawbackTx
}</span>

func (s *Clawback) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := s.BaseTx.Flatten()

        flattened["TransactionType"] = "Clawback"

        if s.Amount != nil </span><span class="cov8" title="1">{
                flattened["Amount"] = s.Amount.Flatten()
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

// UnmarshalJSON unmarshals the JSON data into a Clawback struct.
func (c *Clawback) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Define a helper struct to hold the unmarshaled data
        type cHelper struct {
                BaseTx
                Amount json.RawMessage
        }

        var h cHelper

        // Unmarshal the JSON data into the helper struct
        err := json.Unmarshal(data, &amp;h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Assign the values from the helper struct to the Clawback struct
        <span class="cov8" title="1">*c = Clawback{
                BaseTx: h.BaseTx,
        }

        // Unmarshal the Amount field into a CurrencyAmount struct
        var amount types.CurrencyAmount
        amount, err = types.UnmarshalCurrencyAmount(h.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Assign the unmarshaled CurrencyAmount to the Clawback struct
        <span class="cov8" title="1">c.Amount = amount

        return nil</span>
}

// Validates the Clawback struct.
func (c *Clawback) Validate() (bool, error) <span class="cov8" title="1">{
        // validate the base transaction
        _, err := c.BaseTx.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // check if the field Amount is set
        <span class="cov8" title="1">if c.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("clawback: missing field Amount")
        }</span>

        // check if the Amount is a valid currency amount
        <span class="cov8" title="1">if ok, _ := IsIssuedCurrency(c.Amount); !ok </span><span class="cov8" title="1">{
                return false, errors.New("clawback: invalid Amount")
        }</span>

        // check if Account is not the same as the issuer
        <span class="cov8" title="1">if c.Account.String() == c.Amount.Flatten().(map[string]interface{})["issuer"] </span><span class="cov8" title="1">{
                return false, errors.New("clawback: Account and Amount.issuer cannot be the same")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file150" style="display: none">package transaction
=======
		<pre class="file" id="file146" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type DepositPreauth struct {
        BaseTx
        Authorize   types.Address `json:",omitempty"`
        Unauthorize types.Address `json:",omitempty"`
}

func (*DepositPreauth) TxType() TxType <span class="cov0" title="0">{
        return DepositPreauthTx
}</span>

// TODO: Implement flatten
func (s *DepositPreauth) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file151" style="display: none">package transaction
=======
		<pre class="file" id="file147" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type EscrowCancel struct {
        BaseTx
        Owner         types.Address
        OfferSequence uint
}

func (*EscrowCancel) TxType() TxType <span class="cov0" title="0">{
        return EscrowCancelTx
}</span>

// TODO: Implement flatten
func (s *EscrowCancel) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file152" style="display: none">package transaction
=======
		<pre class="file" id="file148" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type EscrowCreate struct {
        BaseTx
        Amount         types.XRPCurrencyAmount
        Destination    types.Address
        CancelAfter    uint   `json:",omitempty"`
        FinishAfter    uint   `json:",omitempty"`
        Condition      string `json:",omitempty"`
        DestinationTag uint   `json:",omitempty"`
}

func (*EscrowCreate) TxType() TxType <span class="cov0" title="0">{
        return EscrowCreateTx
}</span>

// TODO: Implement flatten
func (s *EscrowCreate) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file153" style="display: none">package transaction
=======
		<pre class="file" id="file149" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type EscrowFinish struct {
        BaseTx
        Owner         types.Address
        OfferSequence uint
        Condition     string `json:",omitempty"`
        Fulfillment   string `json:",omitempty"`
}

func (*EscrowFinish) TxType() TxType <span class="cov0" title="0">{
        return EscrowFinishTx
}</span>

// TODO: Implement flatten
func (s *EscrowFinish) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file154" style="display: none">package transaction
=======
		<pre class="file" id="file150" style="display: none">package transaction
>>>>>>> v1.x.x

import "math/big"

// Perform bitwise AND (&amp;) to check if a flag is enabled within Flags (as a number).
// @param Flags - A number that represents flags enabled.
// @param checkFlag - A specific flag to check if it's enabled within Flags.
// @returns True if checkFlag is enabled within Flags.
func IsFlagEnabled(flags uint, checkFlag uint) bool <span class="cov8" title="1">{
        flagsBigInt := new(big.Int).SetUint64(uint64(flags))
        checkFlagBigInt := new(big.Int).SetUint64(uint64(checkFlag))
        return new(big.Int).And(flagsBigInt, checkFlagBigInt).Cmp(checkFlagBigInt) == 0
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file155" style="display: none">package transaction
=======
		<pre class="file" id="file151" style="display: none">package transaction
>>>>>>> v1.x.x

var _ Tx = (*FlatTransaction)(nil)

type FlatTransaction map[string]interface{}

func (f FlatTransaction) TxType() TxType <span class="cov0" title="0">{
        txType, ok := f["TransactionType"].(string)
        if !ok </span><span class="cov0" title="0">{
                return TxType("")
        }</span>
        <span class="cov0" title="0">return TxType(txType)</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file156" style="display: none">package transaction
=======
		<pre class="file" id="file152" style="display: none">package transaction
>>>>>>> v1.x.x

type MemoWrapper struct {
        Memo Memo
}

type Memo struct {
        MemoData   string `json:",omitempty"`
        MemoFormat string `json:",omitempty"`
        MemoType   string `json:",omitempty"`
}

func (mw *MemoWrapper) Flatten() map[string]interface{} <span class="cov8" title="1">{
        if mw.Memo != (Memo{}) </span><span class="cov8" title="1">{
                flattened := make(map[string]interface{})
                flattened["Memo"] = mw.Memo.Flatten()
                return flattened
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Memo) Flatten() map[string]interface{} <span class="cov8" title="1">{
        flattened := make(map[string]interface{})

        if m.MemoData != "" </span><span class="cov8" title="1">{
                flattened["MemoData"] = m.MemoData
        }</span>

        <span class="cov8" title="1">if m.MemoFormat != "" </span><span class="cov8" title="1">{
                flattened["MemoFormat"] = m.MemoFormat
        }</span>

        <span class="cov8" title="1">if m.MemoType != "" </span><span class="cov8" title="1">{
                flattened["MemoType"] = m.MemoType
        }</span>

        <span class="cov8" title="1">return flattened</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file157" style="display: none">package transaction
=======
		<pre class="file" id="file153" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenAcceptOffer struct {
        BaseTx
        NFTokenSellOffer types.Hash256        `json:",omitempty"`
        NFTokenBuyOffer  types.Hash256        `json:",omitempty"`
        NFTokenBrokerFee types.CurrencyAmount `json:",omitempty"`
}

func (*NFTokenAcceptOffer) TxType() TxType <span class="cov0" title="0">{
        return NFTokenAcceptOfferTx
}</span>

func (n *NFTokenAcceptOffer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type naoHelper struct {
                BaseTx
                NFTokenSellOffer types.Hash256   `json:",omitempty"`
                NFTokenBuyOffer  types.Hash256   `json:",omitempty"`
                NFTokenBrokerFee json.RawMessage `json:",omitempty"`
        }
        var h naoHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*n = NFTokenAcceptOffer{
                BaseTx:           h.BaseTx,
                NFTokenSellOffer: h.NFTokenSellOffer,
                NFTokenBuyOffer:  h.NFTokenBuyOffer,
        }

        fee, err := types.UnmarshalCurrencyAmount(h.NFTokenBrokerFee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">n.NFTokenBrokerFee = fee
        return nil</span>
}

// TODO: Implement flatten
func (s *NFTokenAcceptOffer) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file158" style="display: none">package transaction
=======
		<pre class="file" id="file154" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenBurn struct {
        BaseTx
        NFTokenID types.NFTokenID
        Owner     types.Address `json:",omitempty"`
}

func (*NFTokenBurn) TxType() TxType <span class="cov0" title="0">{
        return NFTokenBurnTx
}</span>

// TODO: Implement flatten
func (s *NFTokenBurn) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file159" style="display: none">package transaction
=======
		<pre class="file" id="file155" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenCancelOffer struct {
        BaseTx
        NFTokenOffers []types.Hash256
}

func (*NFTokenCancelOffer) TxType() TxType <span class="cov0" title="0">{
        return NFTokenCancelOfferTx
}</span>

// TODO: Implement flatten
func (s *NFTokenCancelOffer) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file160" style="display: none">package transaction
=======
		<pre class="file" id="file156" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenCreateOffer struct {
        BaseTx
        Owner       types.Address `json:",omitempty"`
        NFTokenID   types.NFTokenID
        Amount      types.CurrencyAmount
        Expiration  uint          `json:",omitempty"`
        Destination types.Address `json:",omitempty"`
}

func (*NFTokenCreateOffer) TxType() TxType <span class="cov0" title="0">{
        return NFTokenCreateOfferTx
}</span>

// TODO: Implement flatten
func (s *NFTokenCreateOffer) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>

func (n *NFTokenCreateOffer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type ncoHelper struct {
                BaseTx
                Owner       types.Address `json:",omitempty"`
                NFTokenID   types.NFTokenID
                Amount      json.RawMessage
                Expiration  uint          `json:",omitempty"`
                Destination types.Address `json:",omitempty"`
        }
        var h ncoHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*n = NFTokenCreateOffer{
                BaseTx:      h.BaseTx,
                Owner:       h.Owner,
                NFTokenID:   h.NFTokenID,
                Expiration:  h.Expiration,
                Destination: h.Destination,
        }

        amount, err := types.UnmarshalCurrencyAmount(h.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">n.Amount = amount
        return nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file161" style="display: none">package transaction
=======
		<pre class="file" id="file157" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type NFTokenMint struct {
        BaseTx
        NFTokenTaxon uint
        Issuer       types.Address    `json:",omitempty"`
        TransferFee  uint16           `json:",omitempty"`
        URI          types.NFTokenURI `json:",omitempty"`
}

func (*NFTokenMint) TxType() TxType <span class="cov0" title="0">{
        return NFTokenMintTx
}</span>

// TODO: Implement flatten
func (s *NFTokenMint) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file162" style="display: none">package transaction
=======
		<pre class="file" id="file158" style="display: none">package transaction
>>>>>>> v1.x.x

import "errors"

// An OfferCancel transaction removes an Offer object from the XRP Ledger.
//
// Example:
//
// ```json
//
//        {
//            "TransactionType": "OfferCancel",
//            "Account": "ra5nK24KXen9AHvsdFTKHSANinZseWnPcX",
//            "Fee": "12",
//            "Flags": 0,
//            "LastLedgerSequence": 7108629,
//            "OfferSequence": 6,
//            "Sequence": 7
//        }
//
// ```
type OfferCancel struct {
        BaseTx
        // The sequence number (or Ticket number) of a previous OfferCreate transaction.
        // If specified, cancel any offer object in the ledger that was created by that transaction. It is not considered an error if the offer specified does not exist.
        OfferSequence uint32
}

func (*OfferCancel) TxType() TxType <span class="cov8" title="1">{
        return OfferCancelTx
}</span>

<<<<<<< HEAD
// TODO: Implement flatten
func (s *OfferCancel) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file163" style="display: none">package transaction

import (
        "encoding/json"

        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type OfferCreate struct {
        BaseTx
        Expiration    uint `json:",omitempty"`
        OfferSequence uint `json:",omitempty"`
        TakerGets     types.CurrencyAmount
        TakerPays     types.CurrencyAmount
}

func (*OfferCreate) TxType() TxType <span class="cov0" title="0">{
        return OfferCreateTx
=======
// Flatten returns the flattened map of the OfferCancel transaction.
func (o *OfferCancel) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := o.BaseTx.Flatten()
        flattened["OfferSequence"] = o.OfferSequence
        return flattened
>>>>>>> v1.x.x
}</span>

// Validates the OfferCancel struct and makes sure all fields are correct.
func (o *OfferCancel) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := o.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if o.OfferSequence == 0 </span><span class="cov8" title="1">{
                return false, errors.New("offerCancel: OfferSequence is required")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package transaction

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// An OfferCreate transaction places an Offer in the decentralized exchange.
//
// Example:
//
// ```json
//
//        {
//            "TransactionType": "OfferCreate",
//            "Account": "ra5nK24KXen9AHvsdFTKHSANinZseWnPcX",
//            "Fee": "12",
//            "Flags": 0,
//            "LastLedgerSequence": 7108682,
//            "Sequence": 8,
//            "TakerGets": "6000000",
//            "TakerPays": {
//              "currency": "GKO",
//              "issuer": "ruazs5h1qEsqpke88pcqnaseXdm6od2xc",
//              "value": "2"
//            }
//        }
//
// ```
type OfferCreate struct {
        BaseTx
        // (Optional) Time after which the Offer is no longer active, in seconds since the Ripple Epoch.
        Expiration uint `json:",omitempty"`
        // (Optional) An Offer to delete first, specified in the same way as OfferCancel.
        OfferSequence uint `json:",omitempty"`
        // The amount and type of currency being sold.
        TakerGets types.CurrencyAmount
        // The amount and type of currency being bought.
        TakerPays types.CurrencyAmount
}

// **********************************
// OfferCreate Flags
// **********************************

const (
        // tfPassive indicates that the offer is passive, meaning it does not consume offers that exactly match it, and instead waits to be consumed by an offer that exactly matches it.
        tfPassive uint = 65536
        // Treat the Offer as an Immediate or Cancel order. The Offer never creates an Offer object in the ledger: it only trades as much as it can by consuming existing Offers at the time the transaction is processed. If no Offers match, it executes "successfully" without trading anything. In this case, the transaction still uses the result code tesSUCCESS.
        tfImmediateOrCancel uint = 131072
        // Treat the offer as a Fill or Kill order. The Offer never creates an Offer object in the ledger, and is canceled if it cannot be fully filled at the time of execution. By default, this means that the owner must receive the full TakerPays amount; if the tfSell flag is enabled, the owner must be able to spend the entire TakerGets amount instead.
        tfFillOrKill uint = 262144
        // tfSell indicates that the offer is selling, not buying.
        tfSell uint = 524288
)

// tfPassive indicates that the offer is passive, meaning it does not consume offers that exactly match it, and instead waits to be consumed by an offer that exactly matches it.
func (o *OfferCreate) SetPassiveFlag() <span class="cov8" title="1">{
        o.Flags |= tfPassive
}</span>

// Treat the Offer as an Immediate or Cancel order. The Offer never creates an Offer object in the ledger: it only trades as much as it can by consuming existing Offers at the time the transaction is processed. If no Offers match, it executes "successfully" without trading anything. In this case, the transaction still uses the result code tesSUCCESS.
func (o *OfferCreate) SetImmediateOrCancelFlag() <span class="cov8" title="1">{
        o.Flags |= tfImmediateOrCancel
}</span>

// Treat the offer as a Fill or Kill order. The Offer never creates an Offer object in the ledger, and is canceled if it cannot be fully filled at the time of execution. By default, this means that the owner must receive the full TakerPays amount; if the tfSell flag is enabled, the owner must be able to spend the entire TakerGets amount instead.
func (o *OfferCreate) SetFillOrKillFlag() <span class="cov8" title="1">{
        o.Flags |= tfFillOrKill
}</span>

// tfSell indicates that the offer is selling, not buying.
func (o *OfferCreate) SetSellFlag() <span class="cov8" title="1">{
        o.Flags |= tfSell
}</span>

// TxType returns the type of the transaction (OfferCreate).
func (*OfferCreate) TxType() TxType <span class="cov8" title="1">{
        return OfferCreateTx
}</span>

// Flatten returns a map of the OfferCreate transaction fields.
func (s *OfferCreate) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := s.BaseTx.Flatten()

        if s.Expiration != 0 </span><span class="cov8" title="1">{
                flattened["Expiration"] = s.Expiration
        }</span>
        <span class="cov8" title="1">if s.OfferSequence != 0 </span><span class="cov8" title="1">{
                flattened["OfferSequence"] = s.OfferSequence
        }</span>
        <span class="cov8" title="1">flattened["TakerGets"] = s.TakerGets.Flatten()
        flattened["TakerPays"] = s.TakerPays.Flatten()

        return flattened</span>
}

// Validates the OfferCreate transaction.
func (o *OfferCreate) Validate() (bool, error) <span class="cov8" title="1">{
        _, err := o.BaseTx.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(o.TakerGets, "TakerGets", true); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(o.TakerPays, "TakerPays", true); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package transaction

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type PathStep struct {
        Account  types.Address `json:"account,omitempty"`
        Currency string        `json:"currency,omitempty"`
        Issuer   types.Address `json:"issuer,omitempty"`
}

func (p *PathStep) Flatten() map[string]interface{} <span class="cov8" title="1">{
        flattened := make(map[string]interface{})

        if p.Account != "" </span><span class="cov8" title="1">{
                flattened["account"] = p.Account.String()
        }</span>

        <span class="cov8" title="1">if p.Currency != "" </span><span class="cov8" title="1">{
                flattened["currency"] = p.Currency
        }</span>

        <span class="cov8" title="1">if p.Issuer != "" </span><span class="cov8" title="1">{
                flattened["issuer"] = p.Issuer.String()
        }</span>

        <span class="cov8" title="1">return flattened</span>

}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file165" style="display: none">package transaction
=======
		<pre class="file" id="file161" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"
        "errors"

        "github.com/Peersyst/xrpl-go/pkg/typecheck"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

const (
        // Do not use the default path; only use paths included in the Paths field.
        // This is intended to force the transaction to take arbitrage opportunities.
        // Most clients do not need this.
        tfRippleNotDirect uint = 65536
        // If the specified Amount cannot be sent without spending more than SendMax,
        // reduce the received amount instead of failing outright. See Partial
        // Payments for more details.
        tfPartialPayment uint = 131072
        // Only take paths where all the conversions have an input:output ratio that
        // is equal or better than the ratio of Amount:SendMax. See Limit Quality for
        // details.
        tfLimitQuality uint = 262144
)

// A Payment transaction represents a transfer of value from one account to another.
type Payment struct {
        BaseTx
        // API v1: Only available in API v1.
        // The maximum amount of currency to deliver.
        // For non-XRP amounts, the nested field names MUST be lower-case.
        // If the tfPartialPayment flag is set, deliver up to this amount instead.
        Amount types.CurrencyAmount

        // API v2: Only available in API v2.
        // The maximum amount of currency to deliver.
        // For non-XRP amounts, the nested field names MUST be lower-case.
        // If the tfPartialPayment flag is set, deliver up to this amount instead.
        DeliverMax types.CurrencyAmount `json:",omitempty"`

        // (Optional) Minimum amount of destination currency this transaction should deliver.
        // Only valid if this is a partial payment.
        // For non-XRP amounts, the nested field names are lower-case.
        DeliverMin types.CurrencyAmount `json:",omitempty"`

        // The unique address of the account receiving the payment.
        Destination types.Address

        // (Optional) Arbitrary tag that identifies the reason for the payment to the destination, or a hosted recipient to pay.
        DestinationTag uint32 `json:",omitempty"`

        // (Optional) Arbitrary 256-bit hash representing a specific reason or identifier for this payment
        InvoiceID types.Hash256 `json:",omitempty"`

        // (Optional, auto-fillable) Array of payment paths to be used for this transaction.
        // Must be omitted for XRP-to-XRP transactions.
        Paths [][]PathStep `json:",omitempty"`

        // (Optional) Highest amount of source currency this transaction is allowed to cost,
        // including transfer fees, exchange rates, and slippage.
        // Does not include the XRP destroyed as a cost for submitting the transaction.
        // For non-XRP amounts, the nested field names MUST be lower-case.
        // Must be supplied for cross-currency/cross-issue payments.
        // Must be omitted for XRP-to-XRP payments.
        SendMax types.CurrencyAmount `json:",omitempty"`
}

// TxType returns the type of the transaction (Payment).
func (Payment) TxType() TxType <span class="cov0" title="0">{
        return PaymentTx
}</span>

// Flatten returns the flattened map of the Payment transaction.
func (p *Payment) Flatten() FlatTransaction <span class="cov8" title="1">{
        // Add BaseTx fields
        flattened := p.BaseTx.Flatten()

        // Add Payment-specific fields
        flattened["TransactionType"] = "Payment"

        if p.Amount != nil </span><span class="cov8" title="1">{
                flattened["Amount"] = p.Amount.Flatten()
        }</span>

        <span class="cov8" title="1">if p.DeliverMax != nil </span><span class="cov0" title="0">{
                flattened["DeliverMax"] = p.DeliverMax.Flatten()
        }</span>

        <span class="cov8" title="1">if p.DeliverMin != nil </span><span class="cov8" title="1">{
                flattened["DeliverMin"] = p.DeliverMin.Flatten()
        }</span>

        <span class="cov8" title="1">if p.Destination != "" </span><span class="cov8" title="1">{
                flattened["Destination"] = p.Destination.String()
        }</span>

        <span class="cov8" title="1">if p.DestinationTag != 0 </span><span class="cov0" title="0">{
                flattened["DestinationTag"] = int(p.DestinationTag)
        }</span>

        <span class="cov8" title="1">if p.InvoiceID != "" </span><span class="cov0" title="0">{
                flattened["InvoiceID"] = p.InvoiceID.String()
        }</span>

        <span class="cov8" title="1">if len(p.Paths) &gt; 0 </span><span class="cov8" title="1">{
                flattenedPaths := make([][]interface{}, 0)
                for _, path := range p.Paths </span><span class="cov8" title="1">{
                        flattenedPath := make([]interface{}, 0)
                        for _, step := range path </span><span class="cov8" title="1">{
                                flattenedStep := step.Flatten()
                                if flattenedStep != nil </span><span class="cov8" title="1">{
                                        flattenedPath = append(flattenedPath, flattenedStep)
                                }</span>
                        }
                        <span class="cov8" title="1">flattenedPaths = append(flattenedPaths, flattenedPath)</span>
                }
                <span class="cov8" title="1">flattened["Paths"] = flattenedPaths</span>
        }

        <span class="cov8" title="1">if p.SendMax != nil </span><span class="cov0" title="0">{
                flattened["SendMax"] = p.SendMax.Flatten()
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

// SetRippleNotDirectFlag sets the RippleNotDirect flag.
//
// RippleNotDirect: Do not use the default path; only use paths included in the Paths field.
// This is intended to force the transaction to take arbitrage opportunities.
// Most clients do not need this.
func (p *Payment) SetRippleNotDirectFlag() <span class="cov8" title="1">{
        p.Flags |= tfRippleNotDirect
}</span>

// SetPartialPaymentFlag sets the PartialPayment flag.
//
// PartialPayment: If the specified Amount cannot be sent without spending more than SendMax,
// reduce the received amount instead of failing outright. See Partial
// Payments for more details.
func (p *Payment) SetPartialPaymentFlag() <span class="cov8" title="1">{
        p.Flags |= tfPartialPayment
}</span>

// SetLimitQualityFlag sets the LimitQuality flag.
//
// LimitQuality: Only take paths where all the conversions have an input:output ratio that
// is equal or better than the ratio of Amount:SendMax. See Limit Quality for
// details.
func (p *Payment) SetLimitQualityFlag() <span class="cov8" title="1">{
        p.Flags |= tfLimitQuality
}</span>

// UnmarshalJSON unmarshals the Payment transaction from JSON.
func (p *Payment) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type pHelper struct {
                BaseTx
                Amount         json.RawMessage
                Destination    types.Address
                DestinationTag uint32          `json:",omitempty"`
                InvoiceID      types.Hash256   `json:",omitempty"`
                Paths          [][]PathStep    `json:",omitempty"`
                SendMax        json.RawMessage `json:",omitempty"`
                DeliverMin     json.RawMessage `json:",omitempty"`
        }
        var h pHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*p = Payment{
                BaseTx:         h.BaseTx,
                Destination:    h.Destination,
                DestinationTag: h.DestinationTag,
                InvoiceID:      h.InvoiceID,
                Paths:          h.Paths,
        }
        var amount, max, min types.CurrencyAmount
        var err error
        amount, err = types.UnmarshalCurrencyAmount(h.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">max, err = types.UnmarshalCurrencyAmount(h.SendMax)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">min, err = types.UnmarshalCurrencyAmount(h.DeliverMin)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.Amount = amount
        p.DeliverMin = min
        p.SendMax = max

        return nil</span>
}

// ValidatePayment validates the Payment struct and make sure all the fields are correct.
func (tx *Payment) Validate() (bool, error) <span class="cov8" title="1">{
        flattenTx := tx.Flatten()

        // Validate the base transaction
        _, err := tx.BaseTx.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field Amount is set
        <span class="cov8" title="1">if tx.Amount == nil </span><span class="cov8" title="1">{
                return false, errors.New("missing field Amount")
        }</span>

        // Check if the field Amount is valid
        <span class="cov8" title="1">if ok, err := IsAmount(tx.Amount, "Amount", true); !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field Destination is set and valid
        <span class="cov8" title="1">err = ValidateRequiredField(flattenTx, "Destination", typecheck.IsString)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // Check if the field DestinationTag is valid
        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "DestinationTag", typecheck.IsUint32)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field InvoiceId is valid
        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "InvoiceId", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field Paths is valid
        <span class="cov8" title="1">if tx.Paths != nil </span><span class="cov8" title="1">{
                if ok, err := IsPaths(tx.Paths); !ok </span><span class="cov8" title="1">{
                        return false, err
                }</span>
        }

        // Check if the field SendMax is valid
        <span class="cov8" title="1">if ok, err := IsAmount(tx.SendMax, "SendMax", false); !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field DeliverMax is valid
        <span class="cov8" title="1">if ok, err := IsAmount(tx.DeliverMax, "DeliverMax", false); !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field DeliverMin is valid
        <span class="cov8" title="1">if ok, err := IsAmount(tx.DeliverMin, "DeliverMin", false); !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check partial payment fields
        <span class="cov8" title="1">if ok, err := checkPartialPayment(tx); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func checkPartialPayment(tx *Payment) (bool, error) <span class="cov8" title="1">{
        if tx.DeliverMin == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if tx.Flags == 0 </span><span class="cov8" title="1">{
                return false, errors.New("payment transaction: tfPartialPayment flag required with DeliverMin")
        }</span>

        <span class="cov8" title="1">if !IsFlagEnabled(tx.Flags, uint(tfPartialPayment)) </span><span class="cov0" title="0">{
                return false, errors.New("payment transaction: tfPartialPayment flag required with DeliverMin")
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(tx.DeliverMin, "DeliverMin", true); !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file166" style="display: none">package transaction
=======
		<pre class="file" id="file162" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

const (
        // Clear the channel's Expiration time. (Expiration is different from the
        // channel's immutable CancelAfter time.) Only the source address of the
        // payment channel can use this flag.
        tfRenew uint = 65536 // 0x00010000
        // Request to close the channel. Only the channel source and destination
        // addresses can use this flag. This flag closes the channel immediately if it
        // has no more XRP allocated to it after processing the current claim, or if
        // the destination address uses it. If the source address uses this flag when
        // the channel still holds XRP, this schedules the channel to close after
        // SettleDelay seconds have passed. (Specifically, this sets the Expiration of
        // the channel to the close time of the previous ledger plus the channel's
        // SettleDelay time, unless the channel already has an earlier Expiration
        // time.) If the destination address uses this flag when the channel still
        // holds XRP, any XRP that remains after processing the claim is returned to
        // the source address.
        tfClose uint = 131072 // 0x00020000
)

// Claim XRP from a payment channel, adjust the payment channel's expiration,
// or both.
type PaymentChannelClaim struct {
        BaseTx
        Channel   types.Hash256
        Balance   types.XRPCurrencyAmount `json:",omitempty"`
        Amount    types.XRPCurrencyAmount `json:",omitempty"`
        Signature string                  `json:",omitempty"`
        PublicKey string                  `json:",omitempty"`
}

// TxType returns the type of the transaction (PaymentChannelClaim).
func (*PaymentChannelClaim) TxType() TxType <span class="cov0" title="0">{
        return PaymentChannelClaimTx
}</span>

// Flatten returns a flattened map of the PaymentChannelClaim transaction.
func (s *PaymentChannelClaim) Flatten() FlatTransaction <span class="cov0" title="0">{
        flattened := s.BaseTx.Flatten()

        flattened["TransactionType"] = "PaymentChannelClaim"

        if s.Channel != "" </span><span class="cov0" title="0">{
                flattened["Channel"] = s.Channel.String()
        }</span>
        <span class="cov0" title="0">if s.Balance != 0 </span><span class="cov0" title="0">{
                flattened["Balance"] = s.Balance.Flatten()
        }</span>
        <span class="cov0" title="0">if s.Amount != 0 </span><span class="cov0" title="0">{
                flattened["Amount"] = s.Amount.Flatten()
        }</span>
        <span class="cov0" title="0">if s.Signature != "" </span><span class="cov0" title="0">{
                flattened["Signature"] = s.Signature
        }</span>
        <span class="cov0" title="0">if s.PublicKey != "" </span><span class="cov0" title="0">{
                flattened["PublicKey"] = s.PublicKey
        }</span>
        <span class="cov0" title="0">return flattened</span>
}

// SetRenewFlag sets the Renew flag.
//
// Renew: Clear the channel's Expiration time. (Expiration is different from the
// channel's immutable CancelAfter time.) Only the source address of the
// payment channel can use this flag.
func (s *PaymentChannelClaim) SetRenewFlag() <span class="cov8" title="1">{
        s.Flags |= tfRenew
}</span>

// SetCloseFlag sets the Close flag.
//
// Close: Request to close the channel. Only the channel source and destination
// addresses can use this flag. This flag closes the channel immediately if it
// has no more XRP allocated to it after processing the current claim, or if
// the destination address uses it. If the source address uses this flag when
// the channel still holds XRP, this schedules the channel to close after
// SettleDelay seconds have passed. (Specifically, this sets the Expiration of
// the channel to the close time of the previous ledger plus the channel's
// SettleDelay time, unless the channel already has an earlier Expiration
// time.) If the destination address uses this flag when the channel still
// holds XRP, any XRP that remains after processing the claim is returned to
// the source address.
func (s *PaymentChannelClaim) SetCloseFlag() <span class="cov8" title="1">{
        s.Flags |= tfClose
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file167" style="display: none">package transaction
=======
		<pre class="file" id="file163" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type PaymentChannelCreate struct {
        BaseTx
        Amount         types.XRPCurrencyAmount
        Destination    types.Address
        SettleDelay    uint
        PublicKey      string
        CancelAfter    uint `json:",omitempty"`
        DestinationTag uint `json:",omitempty"`
}

func (*PaymentChannelCreate) TxType() TxType <span class="cov0" title="0">{
        return PaymentChannelCreateTx
}</span>

// TODO: Implement flatten
func (s *PaymentChannelCreate) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file168" style="display: none">package transaction
=======
		<pre class="file" id="file164" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type PaymentChannelFund struct {
        BaseTx
        Channel    types.Hash256
        Amount     types.XRPCurrencyAmount
        Expiration uint `json:",omitempty"`
}

func (*PaymentChannelFund) TxType() TxType <span class="cov0" title="0">{
        return PaymentChannelFundTx
}</span>

// TODO: Implement flatten
func (s *PaymentChannelFund) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file169" style="display: none">package transaction
=======
		<pre class="file" id="file165" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type SetRegularKey struct {
        BaseTx
        RegularKey types.Address `json:",omitempty"`
}

func (*SetRegularKey) TxType() TxType <span class="cov0" title="0">{
        return SetRegularKeyTx
}</span>

// TODO: Implement flatten
func (s *SetRegularKey) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file170" style="display: none">package transaction
=======
		<pre class="file" id="file166" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type Signer struct {
        SignerData SignerData `json:"Signer"`
}

type FlatSigner map[string]interface{}

func (s *Signer) Flatten() FlatSigner <span class="cov8" title="1">{
        flattened := make(FlatSigner)
        if s.SignerData != (SignerData{}) </span><span class="cov8" title="1">{
                flattened["SignerData"] = s.SignerData.Flatten()
        }</span>
        <span class="cov8" title="1">return flattened</span>
}

type SignerData struct {
        Account       types.Address
        TxnSignature  string
        SigningPubKey string
}

type FlatSignerData map[string]interface{}

func (sd *SignerData) Flatten() FlatSignerData <span class="cov8" title="1">{
        flattened := make(FlatSignerData)
        if sd.Account != "" </span><span class="cov8" title="1">{
                flattened["Account"] = sd.Account.String()
        }</span>
        <span class="cov8" title="1">if sd.TxnSignature != "" </span><span class="cov8" title="1">{
                flattened["TxnSignature"] = sd.TxnSignature
        }</span>
        <span class="cov8" title="1">if sd.SigningPubKey != "" </span><span class="cov8" title="1">{
                flattened["SigningPubKey"] = sd.SigningPubKey
        }</span>
        <span class="cov8" title="1">return flattened</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file171" style="display: none">package transaction
=======
		<pre class="file" id="file167" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
)

type SignerListSet struct {
        BaseTx
        SignerQuorum  uint
        SignerEntries []ledger.SignerEntryWrapper
}

func (*SignerListSet) TxType() TxType <span class="cov0" title="0">{
        return SignerListSetTx
}</span>

// TODO: Implement flatten
func (s *SignerListSet) Flatten() FlatTransaction <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file172" style="display: none">package transaction
=======
		<pre class="file" id="file168" style="display: none">package transaction
>>>>>>> v1.x.x

// A TicketCreate transaction sets aside one or more sequence numbers as Tickets.
type TicketCreate struct {
        // Base transaction fields
        BaseTx

        //How many Tickets to create. This must be a positive number and cannot cause
        // the account to own more than 250 Tickets after executing this transaction.
        TicketCount uint32
}

func (*TicketCreate) TxType() TxType <span class="cov0" title="0">{
        return TicketCreateTx
}</span>

func (t *TicketCreate) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := t.BaseTx.Flatten()

        flattened["TransactionType"] = "TicketCreate"

        if t.TicketCount != 0 </span><span class="cov8" title="1">{
                flattened["TicketCount"] = t.TicketCount
        }</span>

        <span class="cov8" title="1">return flattened</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file173" style="display: none">package transaction
=======
		<pre class="file" id="file169" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

type TxMeta interface {
        TxMeta()
}

type TxObjMeta struct {
        AffectedNodes          []AffectedNode       `json:"AffectedNodes,omitempty"`
        PartialDeliveredAmount types.CurrencyAmount `json:"DeliveredAmount,omitempty"`
        TransactionIndex       uint64               `json:"TransactionIndex,omitempty"`
        TransactionResult      string               `json:"TransactionResult,omitempty"`
        DeliveredAmount        types.CurrencyAmount `json:"delivered_amount,omitempty"`
}

func (TxObjMeta) TxMeta() {<span class="cov0" title="0">}</span>

type AffectedNode struct {
        CreatedNode  *CreatedNode  `json:"CreatedNode,omitempty"`
        ModifiedNode *ModifiedNode `json:"ModifiedNode,omitempty"`
        DeletedNode  *DeletedNode  `json:"DeletedNode,omitempty"`
}

type CreatedNode struct {
        LedgerEntryType ledger.LedgerEntryType  `json:"LedgerEntryType,omitempty"`
        LedgerIndex     string                  `json:"LedgerIndex,omitempty"`
        NewFields       ledger.FlatLedgerObject `json:"NewFields,omitempty"`
}

type ModifiedNode struct {
        LedgerEntryType   ledger.LedgerEntryType  `json:"LedgerEntryType,omitempty"`
        LedgerIndex       string                  `json:"LedgerIndex,omitempty"`
        FinalFields       ledger.FlatLedgerObject `json:"FinalFields,omitempty"`
        PreviousFields    ledger.FlatLedgerObject `json:"PreviousFields,omitempty"`
        PreviousTxnID     string                  `json:"PreviousTxnID,omitempty"`
        PreviousTxnLgrSeq uint64                  `json:"PreviousTxnLgrSeq,omitempty"`
}

type DeletedNode struct {
        LedgerEntryType ledger.LedgerEntryType  `json:"LedgerEntryType,omitempty"`
        LedgerIndex     string                  `json:"LedgerIndex,omitempty"`
        FinalFields     ledger.FlatLedgerObject `json:"FinalFields,omitempty"`
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file174" style="display: none">package transaction
=======
		<pre class="file" id="file170" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"
        "errors"

        "github.com/Peersyst/xrpl-go/pkg/typecheck"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

const (
        // Authorize the other party to hold currency issued by this account. (No
        // effect unless using the asfRequireAuth AccountSet flag.) Cannot be unset.
        tfSetAuth uint = 65536 // 0x00010000
        // Enable the No Ripple flag, which blocks rippling between two trust lines.
        // of the same currency if this flag is enabled on both.
        tfSetNoRipple uint = 131072 // 0x00020000
        // Disable the No Ripple flag, allowing rippling on this trust line.
        tfClearNoRipple uint = 262144 // 0x00040000
        // Freeze the trust line
        tfSetFreeze uint = 1048576 // 0x00100000
        // Unfreeze the trust line
        tfClearFreeze uint = 2097152 // 0x00200000
)

// Create or modify a trust line linking two accounts.
type TrustSet struct {
        // Base transaction fields
        BaseTx
        //Object defining the trust line to create or modify, in the format of a Currency Amount.
        LimitAmount types.CurrencyAmount
        // (Optional) Value incoming balances on this trust line at the ratio of this number per 1,000,000,000 units.
        // A value of 0 is shorthand for treating balances at face value. For example, if you set the value to 10,000,000, 1% of incoming funds remain with the sender.
        // If an account sends 100 currency, the sender retains 1 currency unit and the destination receives 99 units. This option is included for parity: in practice, you are much more likely to set a QualityOut value.
        // Note that this fee is separate and independent from token transfer fees.
        QualityIn uint32 `json:",omitempty"`
        // (Optional) Value outgoing balances on this trust line at the ratio of this number per 1,000,000,000 units.
        // A value of 0 is shorthand for treating balances at face value. For example, if you set the value to 10,000,000, 1% of outgoing funds would remain with the issuer.
        // If the sender sends 100 currency units, the issuer retains 1 currency unit and the destination receives 99 units. Note that this fee is separate and independent from token transfer fees.
        QualityOut uint32 `json:",omitempty"`
}

// TxType returns the type of the transaction (TrustSet).
func (*TrustSet) TxType() TxType <span class="cov0" title="0">{
        return TrustSetTx
}</span>

// Flatten returns a flattened map of the TrustSet transaction.
func (t *TrustSet) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := t.BaseTx.Flatten()

        flattened["TransactionType"] = "TrustSet"

        if t.LimitAmount != nil </span><span class="cov8" title="1">{
                flattened["LimitAmount"] = t.LimitAmount.Flatten()
        }</span>
        <span class="cov8" title="1">if t.QualityIn != 0 </span><span class="cov0" title="0">{
                flattened["QualityIn"] = t.QualityIn
        }</span>
        <span class="cov8" title="1">if t.QualityOut != 0 </span><span class="cov0" title="0">{
                flattened["QualityOut"] = t.QualityOut
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

// Set the SetAuth flag
//
// SetAuth: Authorize the other party to hold currency issued by this account. (No
// effect unless using the asfRequireAuth AccountSet flag.) Cannot be unset.
func (t *TrustSet) SetSetAuthFlag() <span class="cov8" title="1">{
        t.Flags |= tfSetAuth
}</span>

// Set the SetNoRipple flag
//
// SetNoRipple: Enable the No Ripple flag, which blocks rippling between two trust lines.
// of the same currency if this flag is enabled on both.
func (t *TrustSet) SetSetNoRippleFlag() <span class="cov8" title="1">{
        t.Flags |= tfSetNoRipple
}</span>

// Set the ClearNoRipple flag
//
// ClearNoRipple: Disable the No Ripple flag, allowing rippling on this trust line.
func (t *TrustSet) SetClearNoRippleFlag() <span class="cov8" title="1">{
        t.Flags |= tfClearNoRipple
}</span>

// Set the SetFreeze flag
//
// SetFreeze: Freeze the trust line
func (t *TrustSet) SetSetFreezeFlag() <span class="cov0" title="0">{
        t.Flags |= tfSetFreeze
}</span>

// Set the ClearFreeze flag
//
// ClearFreeze: Unfreeze the trust line
func (t *TrustSet) SetClearFreezeFlag() <span class="cov0" title="0">{
        t.Flags |= tfClearFreeze
}</span>

func (t *TrustSet) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type tsHelper struct {
                BaseTx
                LimitAmount json.RawMessage
                QualityIn   uint32 `json:",omitempty"`
                QualityOut  uint32 `json:",omitempty"`
        }
        var h tsHelper
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*t = TrustSet{
                BaseTx:     h.BaseTx,
                QualityIn:  h.QualityIn,
                QualityOut: h.QualityOut,
        }
        limit, err := types.UnmarshalCurrencyAmount(h.LimitAmount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">t.LimitAmount = limit

        return nil</span>
}

// Validates the TrustSet transaction.
func (tx *TrustSet) Validate() (bool, error) <span class="cov8" title="1">{
        // Validate the base transaction
        _, err := tx.BaseTx.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if the field LimitAmount is set
        <span class="cov8" title="1">if tx.LimitAmount == nil </span><span class="cov8" title="1">{
                return false, errors.New("trustSet: missing field LimitAmount")
        }</span>

        <span class="cov8" title="1">if ok, err := IsAmount(tx.LimitAmount, "LimitAmount", true); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // Check if QualityIn is a number
        <span class="cov8" title="1">if tx.QualityIn != 0 &amp;&amp; !typecheck.IsUint32(tx.QualityIn) </span><span class="cov0" title="0">{
                return false, errors.New("trustSet: QualityIn must be a number")
        }</span>

        // Check if QualityOut is a number
        <span class="cov8" title="1">if tx.QualityOut != 0 &amp;&amp; !typecheck.IsUint32(tx.QualityOut) </span><span class="cov0" title="0">{
                return false, errors.New("trustSet: QualityOut must be a number")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file175" style="display: none">package transaction
=======
		<pre class="file" id="file171" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "encoding/json"
        "fmt"

        "github.com/Peersyst/xrpl-go/pkg/typecheck"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// TODO: Refactor to use a single interface for all transaction types
type Tx interface {
        TxType() TxType
}

type TxHash string

func (*TxHash) TxType() TxType <span class="cov0" title="0">{
        return HashedTx
}</span>

type Binary struct {
        TxBlob string `json:"tx_blob"`
}

func (tx *Binary) TxType() TxType <span class="cov0" title="0">{
        return BinaryTx
}</span>

type BaseTx struct {
        // The unique address of the transaction sender.
        Account types.Address
        //
        // The type of transaction. Valid types include: `Payment`, `OfferCreate`,
        // `TrustSet`, and many others.
        //
        TransactionType TxType
        //
        // Integer amount of XRP, in drops, to be destroyed as a cost for
        // distributing this transaction to the network. Some transaction types have
        // different minimum requirements.
        //
        Fee types.XRPCurrencyAmount `json:",omitempty"`
        //
        // The sequence number of the account sending the transaction. A transaction
        // is only valid if the Sequence number is exactly 1 greater than the previous
        // transaction from the same account. The special case 0 means the transaction
        // is using a Ticket instead.
        //
        Sequence uint `json:",omitempty"`
        //
        // Hash value identifying another transaction. If provided, this transaction
        // is only valid if the sending account's previously-sent transaction matches
        // the provided hash.
        //
        AccountTxnID types.Hash256 `json:",omitempty"`
        // Set of bit-flags for this transaction.
        Flags uint `json:",omitempty"`
        //
        // Highest ledger index this transaction can appear in. Specifying this field
        // places a strict upper limit on how long the transaction can wait to be
        // validated or rejected.
        //
        LastLedgerSequence uint `json:",omitempty"`
        //
        // Additional arbitrary information used to identify this transaction.
        //
        Memos []MemoWrapper `json:",omitempty"`
        // The network id of the transaction.
        NetworkId uint `json:",omitempty"`
        //
        // Array of objects that represent a multi-signature which authorizes this
        // transaction.
        //
        Signers []Signer `json:",omitempty"`
        //
        // Arbitrary integer used to identify the reason for this payment, or a sender
        // on whose behalf this transaction is made. Conventionally, a refund should
        // specify the initial payment's SourceTag as the refund payment's
        // DestinationTag.
        //
        SourceTag uint `json:",omitempty"`
        //
        // Hex representation of the public key that corresponds to the private key
        // used to sign this transaction. If an empty string, indicates a
        // multi-signature is present in the Signers field instead.
        //
        SigningPubKey string `json:",omitempty"`
        //
        // The sequence number of the ticket to use in place of a Sequence number. If
        // this is provided, Sequence must be 0. Cannot be used with AccountTxnID.
        //
        TicketSequence uint `json:",omitempty"`
        //
        // The signature that verifies this transaction as originating from the
        // account it says it is from.
        //
        TxnSignature string `json:",omitempty"`
}

func (tx *BaseTx) TxType() TxType <span class="cov0" title="0">{
        return tx.TransactionType
}</span>

func (tx *BaseTx) Flatten() FlatTransaction <span class="cov8" title="1">{
        flattened := make(FlatTransaction)

        if tx.Account != "" </span><span class="cov8" title="1">{
                flattened["Account"] = tx.Account.String()
        }</span>
        <span class="cov8" title="1">if tx.TransactionType != "" </span><span class="cov8" title="1">{
                flattened["TransactionType"] = tx.TransactionType.String()
        }</span>
        <span class="cov8" title="1">if tx.Fee != 0 </span><span class="cov8" title="1">{
                flattened["Fee"] = tx.Fee.String()
        }</span>
        <span class="cov8" title="1">if tx.Sequence != 0 </span><span class="cov8" title="1">{
                flattened["Sequence"] = tx.Sequence
        }</span>
        <span class="cov8" title="1">if tx.AccountTxnID != "" </span><span class="cov8" title="1">{
                flattened["AccountTxnID"] = tx.AccountTxnID.String()
        }</span>
        <span class="cov8" title="1">if tx.Flags != 0 </span><span class="cov8" title="1">{
                flattened["Flags"] = int(tx.Flags)
        }</span>
        <span class="cov8" title="1">if tx.LastLedgerSequence != 0 </span><span class="cov8" title="1">{
                flattened["LastLedgerSequence"] = tx.LastLedgerSequence
        }</span>
        <span class="cov8" title="1">if len(tx.Memos) &gt; 0 </span><span class="cov8" title="1">{
                flattenedMemos := make([]any, 0)
                for _, memo := range tx.Memos </span><span class="cov8" title="1">{
                        flattenedMemo := memo.Flatten()
                        if flattenedMemo != nil </span><span class="cov8" title="1">{
                                flattenedMemos = append(flattenedMemos, flattenedMemo)
                        }</span>
                }
                <span class="cov8" title="1">flattened["Memos"] = flattenedMemos</span>
        }
        <span class="cov8" title="1">if tx.NetworkId != 0 </span><span class="cov8" title="1">{
                flattened["NetworkId"] = tx.NetworkId
        }</span>
        <span class="cov8" title="1">if len(tx.Signers) &gt; 0 </span><span class="cov8" title="1">{
                flattenedSigners := make([]FlatSigner, 0)
                for _, signer := range tx.Signers </span><span class="cov8" title="1">{
                        flattenedSigner := signer.Flatten()
                        if flattenedSigner != nil </span><span class="cov8" title="1">{
                                flattenedSigners = append(flattenedSigners, flattenedSigner)
                        }</span>
                }
                <span class="cov8" title="1">flattened["Signers"] = flattenedSigners</span>
        }
        <span class="cov8" title="1">if tx.SourceTag != 0 </span><span class="cov8" title="1">{
                flattened["SourceTag"] = tx.SourceTag
        }</span>
        <span class="cov8" title="1">if tx.SigningPubKey != "" </span><span class="cov8" title="1">{
                flattened["SigningPubKey"] = tx.SigningPubKey
        }</span>
        <span class="cov8" title="1">if tx.TicketSequence != 0 </span><span class="cov8" title="1">{
                flattened["TicketSequence"] = tx.TicketSequence
        }</span>
        <span class="cov8" title="1">if tx.TxnSignature != "" </span><span class="cov8" title="1">{
                flattened["TxnSignature"] = tx.TxnSignature
        }</span>

        <span class="cov8" title="1">return flattened</span>
}

func UnmarshalTx(data json.RawMessage) (Tx, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if data[0] == '"' </span><span class="cov0" title="0">{
                var ret TxHash
                if err := json.Unmarshal(data, &amp;ret); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;ret, nil</span>
        } else<span class="cov8" title="1"> if data[0] != '{' </span><span class="cov0" title="0">{
                // TODO error verbosity/record failed json
                return nil, fmt.Errorf("unexpected tx format; must be tx object or hash string")
        }</span>
        // TODO AMM endpoint support
        <span class="cov8" title="1">type txTypeParser struct {
                TransactionType TxType
                TxBlob          string `json:"tx_blob"`
        }
        var txType txTypeParser
        if err := json.Unmarshal(data, &amp;txType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(txType.TxBlob) &gt; 0 &amp;&amp; len(txType.TransactionType) == 0 </span><span class="cov0" title="0">{
                return &amp;Binary{
                        TxBlob: txType.TxBlob,
                }, nil
        }</span>

        <span class="cov8" title="1">fmt.Println("TxType", txType.TransactionType)
        var tx Tx
        switch txType.TransactionType </span>{
        case AMMBidTx:<span class="cov0" title="0">
                tx = &amp;AMMBid{}</span>
        case AMMCreateTx:<span class="cov0" title="0">
                tx = &amp;AMMCreate{}</span>
        case AMMDepositTx:<span class="cov0" title="0">
                tx = &amp;AMMDeposit{}</span>
        case AMMVoteTx:<span class="cov0" title="0">
                tx = &amp;AMMVote{}</span>
        case AMMWithdrawTx:<span class="cov0" title="0">
                tx = &amp;AMMWithdraw{}</span>
        case AccountSetTx:<span class="cov8" title="1">
                tx = &amp;AccountSet{}</span>
        case AccountDeleteTx:<span class="cov8" title="1">
                tx = &amp;AccountDelete{}</span>
        case CheckCancelTx:<span class="cov8" title="1">
                tx = &amp;CheckCancel{}</span>
        case CheckCashTx:<span class="cov8" title="1">
                tx = &amp;CheckCash{}</span>
        case CheckCreateTx:<span class="cov8" title="1">
                tx = &amp;CheckCreate{}</span>
        case ClawbackTx:<span class="cov8" title="1">
                tx = &amp;Clawback{}</span>
        case DepositPreauthTx:<span class="cov8" title="1">
                tx = &amp;DepositPreauth{}</span>
        case EscrowCancelTx:<span class="cov8" title="1">
                tx = &amp;EscrowCancel{}</span>
        case EscrowCreateTx:<span class="cov8" title="1">
                tx = &amp;EscrowCreate{}</span>
        case EscrowFinishTx:<span class="cov8" title="1">
                tx = &amp;EscrowFinish{}</span>
        case NFTokenAcceptOfferTx:<span class="cov8" title="1">
                tx = &amp;NFTokenAcceptOffer{}</span>
        case NFTokenBurnTx:<span class="cov8" title="1">
                tx = &amp;NFTokenBurn{}</span>
        case NFTokenCancelOfferTx:<span class="cov8" title="1">
                tx = &amp;NFTokenCancelOffer{}</span>
        case NFTokenCreateOfferTx:<span class="cov8" title="1">
                tx = &amp;NFTokenCreateOffer{}</span>
        case NFTokenMintTx:<span class="cov8" title="1">
                tx = &amp;NFTokenMint{}</span>
        case OfferCreateTx:<span class="cov0" title="0">
                tx = &amp;OfferCreate{}</span>
        case OfferCancelTx:<span class="cov0" title="0">
                tx = &amp;OfferCancel{}</span>
        case PaymentTx:<span class="cov8" title="1">
                tx = &amp;Payment{}</span>
        case PaymentChannelClaimTx:<span class="cov8" title="1">
                tx = &amp;PaymentChannelClaim{}</span>
        case PaymentChannelCreateTx:<span class="cov8" title="1">
                tx = &amp;PaymentChannelCreate{}</span>
        case PaymentChannelFundTx:<span class="cov8" title="1">
                tx = &amp;PaymentChannelFund{}</span>
        case SetRegularKeyTx:<span class="cov8" title="1">
                tx = &amp;SetRegularKey{}</span>
        case SignerListSetTx:<span class="cov8" title="1">
                tx = &amp;SignerListSet{}</span>
        case TrustSetTx:<span class="cov8" title="1">
                tx = &amp;TrustSet{}</span>
        case TicketCreateTx:<span class="cov8" title="1">
                tx = &amp;TicketCreate{}</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported transaction type %s", txType.TransactionType)</span>
        }
        <span class="cov8" title="1">if err := json.Unmarshal(data, tx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return tx, nil</span>
}

func (tx *BaseTx) Validate() (bool, error) <span class="cov8" title="1">{
        flattenTx := tx.Flatten()

        err := ValidateRequiredField(flattenTx, "TransactionType", typecheck.IsString)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateRequiredField(flattenTx, "Account", typecheck.IsString)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // optional fields
        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "Fee", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "Sequence", typecheck.IsUint)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "AccountTxnID", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "LastLedgerSequence", typecheck.IsUint)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "SourceTag", typecheck.IsUint)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "SigningPubKey", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "TicketSequence", typecheck.IsUint)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "TxnSignature", typecheck.IsString)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = ValidateOptionalField(flattenTx, "NetworkID", typecheck.IsUint)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // memos
        <span class="cov8" title="1">err = validateMemos(tx.Memos)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // signers
        <span class="cov8" title="1">err = validateSigners(tx.Signers)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file176" style="display: none">package transaction
=======
		<pre class="file" id="file172" style="display: none">package transaction
>>>>>>> v1.x.x

type TxType string

const (
        AccountSetTx           TxType = "AccountSet"
        AccountDeleteTx        TxType = "AccountDelete"
        AMMBidTx               TxType = "AMMBid"
        AMMCreateTx            TxType = "AMMCreate"
        AMMDeleteTx            TxType = "AMMDelete"
        AMMDepositTx           TxType = "AMMDeposit"
        AMMVoteTx              TxType = "AMMVote"
        AMMWithdrawTx          TxType = "AMMWithdraw"
        CheckCancelTx          TxType = "CheckCancel"
        CheckCashTx            TxType = "CheckCash"
        CheckCreateTx          TxType = "CheckCreate"
        ClawbackTx             TxType = "Clawback"
        DepositPreauthTx       TxType = "DepositPreauth"
        EscrowCancelTx         TxType = "EscrowCancel"
        EscrowCreateTx         TxType = "EscrowCreate"
        EscrowFinishTx         TxType = "EscrowFinish"
        NFTokenAcceptOfferTx   TxType = "NFTokenAcceptOffer"
        NFTokenBurnTx          TxType = "NFTokenBurn"
        NFTokenCancelOfferTx   TxType = "NFTokenCancelOffer"
        NFTokenCreateOfferTx   TxType = "NFTokenCreateOffer"
        NFTokenMintTx          TxType = "NFTokenMint"
        OfferCreateTx          TxType = "OfferCreate"
        OfferCancelTx          TxType = "OfferCancel"
        PaymentTx              TxType = "Payment"
        PaymentChannelClaimTx  TxType = "PaymentChannelClaim"
        PaymentChannelCreateTx TxType = "PaymentChannelCreate"
        PaymentChannelFundTx   TxType = "PaymentChannelFund"
        SetRegularKeyTx        TxType = "SetRegularKey"
        SignerListSetTx        TxType = "SignerListSet"
        TrustSetTx             TxType = "TrustSet"
        TicketCreateTx         TxType = "TicketCreate"
        HashedTx               TxType = "HASH"   // TX stored as a string, rather than complete tx obj
        BinaryTx               TxType = "BINARY" // TX stored as a string, json tagged as 'tx_blob'
)

func (t TxType) String() string <span class="cov8" title="1">{
        return string(t)
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file177" style="display: none">package types
=======
		<pre class="file" id="file173" style="display: none">package types
>>>>>>> v1.x.x

type Address string

func (a Address) String() string <span class="cov0" title="0">{
        return string(a)
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file178" style="display: none">package types
=======
		<pre class="file" id="file174" style="display: none">package types
>>>>>>> v1.x.x

import (
        "encoding/json"
        "strconv"
)

type CurrencyKind int

const (
        XRP CurrencyKind = iota
        ISSUED
)

type CurrencyAmount interface {
        Kind() CurrencyKind
        Flatten() interface{}
}

func UnmarshalCurrencyAmount(data []byte) (CurrencyAmount, error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">switch data[0] </span>{
        case '{':<span class="cov0" title="0">
                var i IssuedCurrencyAmount
                if err := json.Unmarshal(data, &amp;i); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return i, nil</span>
        default:<span class="cov0" title="0">
                var x XRPCurrencyAmount
                if err := json.Unmarshal(data, &amp;x); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return x, nil</span>
        }
}

type IssuedCurrencyAmount struct {
        Issuer   Address `json:"issuer,omitempty"`
        Currency string  `json:"currency,omitempty"`
        Value    string  `json:"value,omitempty"`
}

func (IssuedCurrencyAmount) Kind() CurrencyKind <span class="cov0" title="0">{
        return ISSUED
}</span>

func (i IssuedCurrencyAmount) Flatten() interface{} <span class="cov0" title="0">{
        json := make(map[string]interface{})

        if i.Issuer != "" </span><span class="cov0" title="0">{
                json["issuer"] = i.Issuer.String()
        }</span>

        <span class="cov0" title="0">if i.Currency != "" </span><span class="cov0" title="0">{
                json["currency"] = i.Currency
        }</span>

        <span class="cov0" title="0">if i.Value != "" </span><span class="cov0" title="0">{
                json["value"] = i.Value
        }</span>
        <span class="cov0" title="0">return json</span>
}

// IsZero returns true if the IssuedCurrencyAmount is the zero value (empty object).
func (i IssuedCurrencyAmount) IsZero() bool <span class="cov8" title="1">{
        return i == IssuedCurrencyAmount{}
}</span>

type XRPCurrencyAmount uint64

func (a XRPCurrencyAmount) Uint64() uint64 <span class="cov0" title="0">{
        return uint64(a)
}</span>

func (a XRPCurrencyAmount) String() string <span class="cov0" title="0">{
        return strconv.FormatUint(uint64(a), 10)
}</span>

func (XRPCurrencyAmount) Kind() CurrencyKind <span class="cov0" title="0">{
        return XRP
}</span>

func (a XRPCurrencyAmount) Flatten() interface{} <span class="cov0" title="0">{
        return a.String()
}</span>

func (a XRPCurrencyAmount) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        s := strconv.FormatUint(uint64(a), 10)
        return json.Marshal(s)
}</span>

func (a *XRPCurrencyAmount) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">v, err := strconv.ParseUint(s, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*a = XRPCurrencyAmount(v)
        return nil</span>
}

func (a *XRPCurrencyAmount) UnmarshalText(data []byte) error <span class="cov0" title="0">{

        v, err := strconv.ParseUint(string(data), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*a = XRPCurrencyAmount(v)
        return nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file179" style="display: none">package types
=======
		<pre class="file" id="file175" style="display: none">package types
>>>>>>> v1.x.x

type Hash128 string

func (h *Hash128) String() string <span class="cov0" title="0">{
        return string(*h)
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file180" style="display: none">package types
=======
		<pre class="file" id="file176" style="display: none">package types
>>>>>>> v1.x.x

type Hash256 string

func (h *Hash256) String() string <span class="cov0" title="0">{
        return string(*h)
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file181" style="display: none">package transaction
=======
		<pre class="file" id="file177" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "fmt"
)

func ValidateRequiredField(tx FlatTransaction, field string, checkValidity func(interface{}) bool) error <span class="cov8" title="1">{
        // Check if the field is present in the transaction map.
        if _, ok := tx[field]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("%s is missing", field)
        }</span>

        // Check if the field is valid.
        <span class="cov8" title="1">if !checkValidity(tx[field]) </span><span class="cov0" title="0">{
                transactionType, _ := tx["TransactionType"].(string)
                return fmt.Errorf("%s: invalid field %s", transactionType, field)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateOptionalField validates an optional field in the transaction map.
func ValidateOptionalField(tx FlatTransaction, paramName string, checkValidity func(interface{}) bool) error <span class="cov8" title="1">{
        // Check if the field is present in the transaction map.
        if value, ok := tx[paramName]; ok </span><span class="cov8" title="1">{
                // Check if the field is valid.
                if !checkValidity(value) </span><span class="cov0" title="0">{
                        transactionType, _ := tx["TransactionType"].(string)
                        return fmt.Errorf("%s: invalid field %s", transactionType, paramName)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateMemos validates the Memos field in the transaction map.
func validateMemos(memoWrapper []MemoWrapper) error <span class="cov8" title="1">{
        // loop through each memo and validate it
        for _, memo := range memoWrapper </span><span class="cov8" title="1">{
                isMemo, err := IsMemo(memo.Memo)
                if !isMemo </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateSigners validates the Signers field in the transaction map.
func validateSigners(signers []Signer) error <span class="cov8" title="1">{
        // loop through each signer and validate it
        for _, signer := range signers </span><span class="cov8" title="1">{
                isSigner, err := IsSigner(signer.SignerData)
                if !isSigner </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file182" style="display: none">package transaction
=======
		<pre class="file" id="file178" style="display: none">package transaction
>>>>>>> v1.x.x

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        maputils "github.com/Peersyst/xrpl-go/pkg/map_utils"
        "github.com/Peersyst/xrpl-go/pkg/typecheck"
        "github.com/Peersyst/xrpl-go/xrpl/currency"
        "github.com/Peersyst/xrpl-go/xrpl/ledger-entry-types"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

const (
        // The Memos field includes arbitrary messaging data with the transaction.
        // It is presented as an array of objects. Each object has only one field, Memo,
        // which in turn contains another object with one or more of the following fields:
        // MemoData, MemoFormat, and MemoType. https://xrpl.org/docs/references/protocol/transactions/common-fields#memos-field
        MEMO_SIZE   = 3
        SIGNER_SIZE = 3
        // For a token, must have the following fields: currency, issuer, value. https://xrpl.org/docs/references/protocol/data-types/basic-data-types#specifying-currency-amounts
        ISSUED_CURRENCY_SIZE       = 3
        STANDARD_CURRENCY_CODE_LEN = 3
)

// IsMemo checks if the given object is a valid Memo object.
func IsMemo(memo Memo) (bool, error) <span class="cov8" title="1">{
        // Get the size of the Memo object.
        size := len(maputils.GetKeys(memo.Flatten()))

        if size == 0 </span><span class="cov8" title="1">{
                return false, errors.New("memo object should have at least one field, MemoData, MemoFormat or MemoType")
        }</span>

        <span class="cov8" title="1">validData := memo.MemoData == "" || typecheck.IsHex(memo.MemoData)
        if !validData </span><span class="cov8" title="1">{
                return false, errors.New("memoData should be a hexadecimal string")
        }</span>

        <span class="cov8" title="1">validFormat := memo.MemoFormat == "" || typecheck.IsHex(memo.MemoFormat)
        if !validFormat </span><span class="cov8" title="1">{
                return false, errors.New("memoFormat should be a hexadecimal string")
        }</span>

        <span class="cov8" title="1">validType := memo.MemoType == "" || typecheck.IsHex(memo.MemoType)
        if !validType </span><span class="cov8" title="1">{
                return false, errors.New("memoType should be a hexadecimal string")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// IsSigner checks if the given object is a valid Signer object.
func IsSigner(signerData SignerData) (bool, error) <span class="cov8" title="1">{
        size := len(maputils.GetKeys(signerData.Flatten()))
        if size != SIGNER_SIZE </span><span class="cov8" title="1">{
                return false, errors.New("signers: Signer should have 3 fields: Account, TxnSignature, SigningPubKey")
        }</span>

        <span class="cov8" title="1">validAccount := strings.TrimSpace(signerData.Account.String()) != "" &amp;&amp; addresscodec.IsValidClassicAddress(signerData.Account.String())
        if !validAccount </span><span class="cov8" title="1">{
                return false, errors.New("signers: Account should be a string")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(signerData.TxnSignature) == "" </span><span class="cov8" title="1">{
                return false, errors.New("signers: TxnSignature should be a non-empty string")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(signerData.SigningPubKey) == "" </span><span class="cov8" title="1">{
                return false, errors.New("signers: SigningPubKey should be a non-empty string")
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}

// IsAmount checks if the given object is a valid Amount object.
// It is a string for an XRP amount or a map for an IssuedCurrency amount.
func IsAmount(field types.CurrencyAmount, fieldName string, isFieldRequired bool) (bool, error) <span class="cov8" title="1">{
        if isFieldRequired &amp;&amp; field == nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("missing field %s", fieldName)
        }</span>

        <span class="cov8" title="1">if !isFieldRequired &amp;&amp; field == nil </span><span class="cov8" title="1">{
                // no need to check further properties on a nil field, will create a panic with tests otherwise
                return true, nil
        }</span>

        <span class="cov8" title="1">if field.Kind() == types.XRP </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if ok, err := IsIssuedCurrency(field); !ok </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// IsIssuedCurrency checks if the given object is a valid IssuedCurrency object.
func IsIssuedCurrency(input types.CurrencyAmount) (bool, error) <span class="cov8" title="1">{
        if input.Kind() == types.XRP </span><span class="cov8" title="1">{
                return false, errors.New("an issued currency cannot be of type XRP")
        }</span>

        // Get the size of the IssuedCurrency object.
        <span class="cov8" title="1">issuedAmount, _ := input.(types.IssuedCurrencyAmount)

        numOfKeys := len(maputils.GetKeys(issuedAmount.Flatten().(map[string]interface{})))
        if numOfKeys != ISSUED_CURRENCY_SIZE </span><span class="cov8" title="1">{
                return false, errors.New("issued currency object should have 3 fields: currency, issuer, value")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(issuedAmount.Currency) == "" </span><span class="cov8" title="1">{
                return false, errors.New("currency field is required for an issued currency")
        }</span>
        <span class="cov8" title="1">if strings.ToUpper(issuedAmount.Currency) == currency.NATIVE_CURRENCY_SYMBOL </span><span class="cov8" title="1">{
                return false, errors.New("cannot have an issued currency with a similar standard code as XRP")
        }</span>

        <span class="cov8" title="1">if !addresscodec.IsValidClassicAddress(issuedAmount.Issuer.String()) </span><span class="cov8" title="1">{
                return false, errors.New("issuer field is not a valid XRPL classic address")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(issuedAmount.Value) == "" </span><span class="cov8" title="1">{
                return false, errors.New("value field is required for an issued currency")
        }</span>

        // Check if the value is a valid positive number
        <span class="cov8" title="1">value, err := strconv.ParseFloat(issuedAmount.Value, 64)
        if err != nil || value &lt; 0 </span><span class="cov8" title="1">{
                return false, errors.New("value field should be a valid positive number")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// IsPath checks if the given pathstep is valid.
func IsPath(path []PathStep) (bool, error) <span class="cov8" title="1">{
        for _, pathStep := range path </span><span class="cov8" title="1">{

                hasAccount := pathStep.Account != ""
                hasCurrency := pathStep.Currency != ""
                hasIssuer := pathStep.Issuer != ""

                /**
                In summary, the following combination of fields are valid, optionally with type, type_hex, or both (but these two are deprecated):

                - account by itself
                - currency by itself
                - currency and issuer as long as the currency is not XRP
                - issuer by itself

                Any other use of account, currency, and issuer fields in a path step is invalid.

                https://xrpl.org/docs/concepts/tokens/fungible-tokens/paths#path-specifications
                */
                if (hasAccount &amp;&amp; !hasCurrency &amp;&amp; !hasIssuer) || (hasCurrency &amp;&amp; !hasAccount &amp;&amp; !hasIssuer) || (hasIssuer &amp;&amp; !hasAccount &amp;&amp; !hasCurrency) </span><span class="cov8" title="1">{
                        return true, nil
                }</span> else<span class="cov8" title="1"> if hasIssuer &amp;&amp; hasCurrency &amp;&amp; pathStep.Currency != currency.NATIVE_CURRENCY_SYMBOL </span><span class="cov8" title="1">{
                        return true, nil
                }</span> else<span class="cov8" title="1"> {
                        return false, errors.New("invalid path step, check the valid fields combination at https://xrpl.org/docs/concepts/tokens/fungible-tokens/paths#path-specifications")
                }</span>

        }
        <span class="cov8" title="1">return true, nil</span>
}

// IsPaths checks if the given slice of slices of maps is a valid Paths.
func IsPaths(pathsteps [][]PathStep) (bool, error) <span class="cov8" title="1">{
        if len(pathsteps) == 0 </span><span class="cov8" title="1">{
                return false, errors.New("paths should have at least one path")
        }</span>

        <span class="cov8" title="1">for _, path := range pathsteps </span><span class="cov8" title="1">{
                if len(path) == 0 </span><span class="cov8" title="1">{
                        return false, errors.New("path should have at least one path step")
                }</span>

                <span class="cov8" title="1">if ok, err := IsPath(path); !ok </span><span class="cov8" title="1">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// IsAsset checks if the given object is a valid Asset object.
func IsAsset(asset ledger.Asset) (bool, error) <span class="cov8" title="1">{
        // Get the size of the Asset object.
        lenKeys := len(maputils.GetKeys(asset.Flatten()))

        if lenKeys == 0 </span><span class="cov8" title="1">{
                return false, errors.New("asset object should have at least one field 'currency', or two fields 'currency' and 'issuer'")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(asset.Currency) == "" </span><span class="cov8" title="1">{
                return false, errors.New("currency field is required for an asset")
        }</span>

        <span class="cov8" title="1">if strings.ToUpper(asset.Currency) == currency.NATIVE_CURRENCY_SYMBOL &amp;&amp; strings.TrimSpace(asset.Issuer.String()) == "" </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if strings.ToUpper(asset.Currency) == currency.NATIVE_CURRENCY_SYMBOL &amp;&amp; asset.Issuer != "" </span><span class="cov8" title="1">{
                return false, errors.New("issuer field should be omitted for XRP currency")
        }</span>

        <span class="cov8" title="1">if asset.Currency != "" &amp;&amp; !addresscodec.IsValidClassicAddress(asset.Issuer.String()) </span><span class="cov8" title="1">{
                return false, errors.New("issuer field must be a valid XRPL classic address")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file183" style="display: none">package xrpl
=======
		<pre class="file" id="file179" style="display: none">package xrpl
>>>>>>> v1.x.x

import (
        "encoding/hex"
        "errors"
        "fmt"
        "strings"

        addresscodec "github.com/Peersyst/xrpl-go/address-codec"
        binarycodec "github.com/Peersyst/xrpl-go/binary-codec"
        "github.com/Peersyst/xrpl-go/keypairs"
        "github.com/Peersyst/xrpl-go/xrpl/hash"
        "github.com/tyler-smith/go-bip32"
        "github.com/tyler-smith/go-bip39"
)

// A utility for deriving a wallet composed of a keypair (publicKey/privateKey).
// A wallet can be derived from either a seed, mnemonic, or entropy (array of random numbers).
// It provides functionality to sign/verify transactions offline.
type Wallet struct {
        PublicKey      string
        PrivateKey     string
        ClassicAddress string
        Seed           string
}

// Creates a new random Wallet. In order to make this a valid account on ledger, you must
// Send XRP to it.
func NewWallet(alg addresscodec.CryptoImplementation) (Wallet, error) <span class="cov0" title="0">{
        seed, err := keypairs.GenerateSeed("", alg)
        if err != nil </span><span class="cov0" title="0">{
                return Wallet{}, err
        }</span>
        <span class="cov0" title="0">return NewWalletFromSeed(seed, "")</span>
}

// Derives a wallet from a seed.
// Returns a Wallet object. If an error occurs, it will be returned.
func NewWalletFromSeed(seed string, masterAddress string) (Wallet, error) <span class="cov8" title="1">{
        privKey, pubKey, err := keypairs.DeriveKeypair(seed, false)
        if err != nil </span><span class="cov0" title="0">{
                return Wallet{}, err
        }</span>

        <span class="cov8" title="1">var classicAddr string
        if ok := addresscodec.IsValidClassicAddress(masterAddress); ok </span><span class="cov0" title="0">{
                classicAddr = masterAddress
        }</span> else<span class="cov8" title="1"> {
                addr, err := keypairs.DeriveClassicAddress(pubKey)
                if err != nil </span><span class="cov0" title="0">{
                        return Wallet{}, err
                }</span>
                <span class="cov8" title="1">classicAddr = addr</span>
        }

        <span class="cov8" title="1">return Wallet{
                PublicKey:      pubKey,
                PrivateKey:     privKey,
                Seed:           seed,
                ClassicAddress: classicAddr,
        }, nil</span>

}

// Derives a wallet from a secret (AKA a seed).
// Returns a Wallet object. If an error occurs, it will be returned.
func NewWalletFromSecret(seed string) (Wallet, error) <span class="cov8" title="1">{
        return NewWalletFromSeed(seed, "")
}</span>

// // Derives a wallet from a bip39 or RFC1751 mnemonic (Defaults to bip39).
// // Returns a Wallet object. If an error occurs, it will be returned.
func NewWalletFromMnemonic(mnemonic string) (*Wallet, error) <span class="cov8" title="1">{
        // Validate the mnemonic
        if !bip39.IsMnemonicValid(mnemonic) </span><span class="cov0" title="0">{
                return nil, errors.New("invalid mnemonic")
        }</span>

        // Generate seed from mnemonic
        <span class="cov8" title="1">seed := bip39.NewSeed(mnemonic, "")

        // Derive the master key
        masterKey, err := bip32.NewMasterKey(seed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Derive the key using the path m/44'/144'/0'/0/0
        <span class="cov8" title="1">path := []uint32{
                44 + bip32.FirstHardenedChild,
                144 + bip32.FirstHardenedChild,
                bip32.FirstHardenedChild,
                0,
                0,
        }

        key := masterKey
        for _, childNum := range path </span><span class="cov8" title="1">{
                key, err = key.NewChildKey(childNum)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Convert the private key to the format expected by the XRPL library
        <span class="cov8" title="1">privKey := strings.ToUpper(hex.EncodeToString(key.Key))
        pubKey := strings.ToUpper(hex.EncodeToString(key.PublicKey().Key))

        // Derive classic address
        classicAddr, err := keypairs.DeriveClassicAddress(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Wallet{
                PublicKey:      pubKey,
                PrivateKey:     fmt.Sprintf("00%s", privKey),
                ClassicAddress: classicAddr,
                Seed:           "", // We don't have the seed in this case
        }, nil</span>
}

// Signs a transaction offline.
// In order for a transaction to be validated, it must be signed by the account sending the transaction to prove
// that the owner is actually the one deciding to take that action.
//
// TODO: Refactor to accept a `Transaction` object instead of a map.
func (w *Wallet) Sign(tx map[string]interface{}) (string, string, error) <span class="cov8" title="1">{
        tx["SigningPubKey"] = w.PublicKey

        // Validate the transaction fields
        // err := transactions.ValidateTx(tx)
        // if err != nil {
        //         return "", "", err
        // }

        encodedTx, _ := binarycodec.EncodeForSigning(tx)
        hexTx, err := hex.DecodeString(encodedTx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">txHash, err := keypairs.Sign(string(hexTx), w.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">tx["TxnSignature"] = txHash

        txBlob, err := binarycodec.Encode(tx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">txHash, err = hash.HashTxBlob(txBlob)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return txBlob, txHash, nil</span>
}

// Returns the classic address of the wallet.
func (w *Wallet) GetAddress() string <span class="cov0" title="0">{
        return w.ClassicAddress
}</span>

// Verifies a signed transaction offline.
// Returns a boolean indicating if the transaction is valid and an error if it is not.
// If the transaction is signed with a public key, the public key must match the one in the transaction.
// func (w *Wallet) VerifyTransaction(tx map[string]any) (bool, error) {
//         return false, errors.New("not implemented")
// }

// // Gets an X-address in Testnet/Mainnet format.
// func (w *Wallet) GetXAddress() (string, error) {
//         return "", errors.New("not implemented")
// }
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file184" style="display: none">package websocket
=======
		<pre class="file" id="file180" style="display: none">package websocket
>>>>>>> v1.x.x

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "sync/atomic"

        binarycodec "github.com/Peersyst/xrpl-go/binary-codec"
        "github.com/Peersyst/xrpl-go/xrpl"
        "github.com/Peersyst/xrpl-go/xrpl/currency"
        transaction "github.com/Peersyst/xrpl-go/xrpl/transaction"
        "github.com/mitchellh/mapstructure"

        "github.com/Peersyst/xrpl-go/xrpl/queries/account"
        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/queries/server"
        requests "github.com/Peersyst/xrpl-go/xrpl/queries/transactions"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
        "github.com/gorilla/websocket"
)

const (
        DEFAULT_FEE_CUSHION float32 = 1.2
        DEFAULT_MAX_FEE_XRP float32 = 2
)

var ErrIncorrectId = errors.New("incorrect id")

type WebsocketClient struct {
        cfg WebsocketClientConfig

        idCounter atomic.Uint32
        NetworkId uint32
}

// Creates a new websocket client with cfg.
// This client will open and close a websocket connection for each request.
func NewWebsocketClient(cfg WebsocketClientConfig) *WebsocketClient <span class="cov0" title="0">{
        return &amp;WebsocketClient{
                cfg: cfg,
        }
}</span>

func (c *WebsocketClient) Autofill(tx *transaction.FlatTransaction) error <span class="cov0" title="0">{
        if err := c.setValidTransactionAddresses(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := c.setTransactionFlags(tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, ok := (*tx)["NetworkID"]; !ok </span><span class="cov0" title="0">{
                if c.NetworkId != 0 </span><span class="cov0" title="0">{
                        (*tx)["NetworkID"] = c.NetworkId
                }</span>
        }
        <span class="cov0" title="0">if _, ok := (*tx)["Sequence"]; !ok </span><span class="cov0" title="0">{
                err := c.setTransactionNextValidSequenceNumber(tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if _, ok := (*tx)["Fee"]; !ok </span><span class="cov0" title="0">{
                err := c.calculateFeePerTransactionType(tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if _, ok := (*tx)["LastLedgerSequence"]; !ok </span><span class="cov0" title="0">{
                err := c.setLastLedgerSequence(tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if txType, ok := (*tx)["TransactionType"].(transaction.TxType); ok </span><span class="cov0" title="0">{
                if acc, ok := (*tx)["Account"].(types.Address); txType == transaction.AccountDeleteTx &amp;&amp; ok </span><span class="cov0" title="0">{
                        err := c.checkAccountDeleteBlockers(acc)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if txType == transaction.PaymentTx </span><span class="cov0" title="0">{
                        err := c.checkPaymentAmounts(tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *WebsocketClient) FundWallet(wallet *xrpl.Wallet) error <span class="cov0" title="0">{
        if wallet.ClassicAddress == "" </span><span class="cov0" title="0">{
                return errors.New("fund wallet: cannot fund a wallet without a classic address")
        }</span>

        <span class="cov0" title="0">err := c.cfg.faucetProvider.FundWallet(wallet.ClassicAddress)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebsocketClient) sendRequest(req WebsocketXRPLRequest) (WebsocketXRPLResponse, error) <span class="cov8" title="1">{
        err := req.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">id := c.idCounter.Add(1)

        // TODO: Decouple connection
        conn, _, err := websocket.DefaultDialer.Dial(c.cfg.host, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        msg, err := c.formatRequest(req, int(id), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = conn.WriteMessage(websocket.TextMessage, msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, v, err := conn.ReadMessage()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">jDec := json.NewDecoder(bytes.NewReader(json.RawMessage(v)))
        jDec.UseNumber()
        var res WebSocketClientXrplResponse
        err = jDec.Decode(&amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if res.ID != int(id) </span><span class="cov8" title="1">{
                return nil, ErrIncorrectId
        }</span>
        <span class="cov8" title="1">if err := res.CheckError(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;res, nil</span>
}

func (c *WebsocketClient) SubmitTransactionBlob(txBlob string, failHard bool) (*requests.SubmitResponse, error) <span class="cov0" title="0">{
        tx, err := binarycodec.Decode(txBlob)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, okTxSig := tx["TxSignature"].(string)
        _, okPubKey := tx["SigningPubKey"].(string)
        signers, okSigners := tx["Signers"].([]transaction.Signer)

        if okSigners &amp;&amp; len(signers) &gt; 0 </span><span class="cov0" title="0">{
                for _, signer := range signers </span><span class="cov0" title="0">{
                        if signer.SignerData.SigningPubKey == "" &amp;&amp; signer.SignerData.TxnSignature == "" </span><span class="cov0" title="0">{
                                return nil, errors.New("signer data is empty")
                        }</span>
                }
        } else<span class="cov0" title="0"> if !okTxSig &amp;&amp; !okPubKey </span><span class="cov0" title="0">{
                return nil, errors.New("transaction must have a TxSignature or SigningPubKey set")
        }</span>

        <span class="cov0" title="0">return c.submitRequest(&amp;requests.SubmitRequest{
                TxBlob:   txBlob,
                FailHard: failHard,
        })</span>
}

func (c *WebsocketClient) submitRequest(req *requests.SubmitRequest) (*requests.SubmitResponse, error) <span class="cov0" title="0">{
        res, err := c.sendRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var subRes requests.SubmitResponse
        err = res.GetResult(&amp;subRes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;subRes, nil</span>
}

func (c *WebsocketClient) formatRequest(req WebsocketXRPLRequest, id int, marker any) ([]byte, error) <span class="cov8" title="1">{
        m := make(map[string]any)
        m["id"] = id
        m["command"] = req.Method()
        if marker != nil </span><span class="cov8" title="1">{
                m["marker"] = marker
        }</span>
        <span class="cov8" title="1">dec, _ := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{TagName: "json", Result: &amp;m})
        err := dec.Decode(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return json.Marshal(m)</span>
}

// TODO: Implement this when IsValidXAddress is implemented
func (c *WebsocketClient) getClassicAccountAndTag(address string) (string, uint32) <span class="cov8" title="1">{
        return address, 0
}</span>

func (c *WebsocketClient) convertTransactionAddressToClassicAddress(tx *transaction.FlatTransaction, fieldName string) <span class="cov8" title="1">{
        if address, ok := (*tx)[fieldName].(string); ok </span><span class="cov8" title="1">{
                classicAddress, _ := c.getClassicAccountAndTag(address)
                (*tx)[fieldName] = classicAddress
        }</span>
}

func (c *WebsocketClient) validateTransactionAddress(tx *transaction.FlatTransaction, addressField, tagField string) error <span class="cov8" title="1">{
        classicAddress, tag := c.getClassicAccountAndTag((*tx)[addressField].(string))
        (*tx)[addressField] = classicAddress

        if tag != uint32(0) </span><span class="cov0" title="0">{
                if txTag, ok := (*tx)[tagField].(uint32); ok &amp;&amp; txTag != tag </span><span class="cov0" title="0">{
                        return fmt.Errorf("the %s, if present, must be equal to the tag of the %s", addressField, tagField)
                }</span>
                <span class="cov0" title="0">(*tx)[tagField] = tag</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Sets valid addresses for the transaction.
func (c *WebsocketClient) setValidTransactionAddresses(tx *transaction.FlatTransaction) error <span class="cov8" title="1">{
        // Validate if "Account" address is an xAddress
        if err := c.validateTransactionAddress(tx, "Account", "SourceTag"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, ok := (*tx)["Destination"]; ok </span><span class="cov8" title="1">{
                if err := c.validateTransactionAddress(tx, "Destination", "DestinationTag"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // DepositPreuaht
        <span class="cov8" title="1">c.convertTransactionAddressToClassicAddress(tx, "Authorize")
        c.convertTransactionAddressToClassicAddress(tx, "Unauthorize")
        // EscrowCancel, EscrowFinish
        c.convertTransactionAddressToClassicAddress(tx, "Owner")
        // SetRegularKey
        c.convertTransactionAddressToClassicAddress(tx, "RegularKey")

        return nil</span>
}

// Sets the next valid sequence number for a given transaction.
func (c *WebsocketClient) setTransactionNextValidSequenceNumber(tx *transaction.FlatTransaction) error <span class="cov8" title="1">{
        if _, ok := (*tx)["Account"].(string); !ok </span><span class="cov8" title="1">{
                return errors.New("missing Account in transaction")
        }</span>
        <span class="cov8" title="1">res, err := c.GetAccountInfo(&amp;account.AccountInfoRequest{
                Account:     types.Address((*tx)["Account"].(string)),
                LedgerIndex: common.LedgerTitle("current"),
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">(*tx)["Sequence"] = int(res.AccountData.Sequence)
        return nil</span>
}

// Calculates the current transaction fee for the ledger.
// Note: This is a public API that can be called directly.
func (c *WebsocketClient) getFeeXrp(cushion float32) (string, error) <span class="cov8" title="1">{
        res, err := c.GetServerInfo(&amp;server.ServerInfoRequest{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if res.Info.ValidatedLedger.BaseFeeXRP == 0 </span><span class="cov0" title="0">{
                return "", errors.New("getFeeXrp: could not get BaseFeeXrp from ServerInfo")
        }</span>

        <span class="cov8" title="1">loadFactor := res.Info.LoadFactor
        if res.Info.LoadFactor == 0 </span><span class="cov0" title="0">{
                loadFactor = 1
        }</span>

        <span class="cov8" title="1">fee := res.Info.ValidatedLedger.BaseFeeXRP * float32(loadFactor) * cushion

        if fee &gt; c.cfg.maxFeeXRP </span><span class="cov8" title="1">{
                fee = c.cfg.maxFeeXRP
        }</span>

        // Round fee to NUM_DECIMAL_PLACES
        <span class="cov8" title="1">roundedFee := float32(math.Round(float64(fee)*math.Pow10(int(currency.MAX_FRACTION_LENGTH)))) / float32(math.Pow10(int(currency.MAX_FRACTION_LENGTH)))

        // Convert the rounded fee back to a string with NUM_DECIMAL_PLACES
        return fmt.Sprintf("%.*f", currency.MAX_FRACTION_LENGTH, roundedFee), nil</span>
}

// Calculates the fee per transaction type.
//
// TODO: Add fee support for `EscrowFinish` `AccountDelete`, `AMMCreate`, and multisigned transactions.
func (c *WebsocketClient) calculateFeePerTransactionType(tx *transaction.FlatTransaction) error <span class="cov8" title="1">{
        fee, err := c.getFeeXrp(c.cfg.feeCushion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">feeDrops, err := currency.XrpToDrops(fee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">(*tx)["Fee"] = feeDrops

        return nil</span>
}

// Sets the latest validated ledger sequence for the transaction.
// Modifies the `LastLedgerSequence` field in the tx.
func (c *WebsocketClient) setLastLedgerSequence(tx *transaction.FlatTransaction) error <span class="cov8" title="1">{
        index, err := c.GetLedgerIndex()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">(*tx)["LastLedgerSequence"] = index.Int() + int(LEDGER_OFFSET)
        return err</span>
}

// Checks for any blockers that prevent the deletion of an account.
// Returns nil if there are no blockers, otherwise returns an error.
func (c *WebsocketClient) checkAccountDeleteBlockers(address types.Address) error <span class="cov8" title="1">{
        accObjects, err := c.GetAccountObjects(&amp;account.AccountObjectsRequest{
                Account:              address,
                LedgerIndex:          common.LedgerTitle("validated"),
                DeletionBlockersOnly: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(accObjects.AccountObjects) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("account %s cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c *WebsocketClient) checkPaymentAmounts(tx *transaction.FlatTransaction) error <span class="cov0" title="0">{
        if _, ok := (*tx)["DeliverMax"]; ok </span><span class="cov0" title="0">{
                if _, ok := (*tx)["Amount"]; !ok </span><span class="cov0" title="0">{
                        (*tx)["Amount"] = (*tx)["DeliverMax"]
                }</span> else<span class="cov0" title="0"> {
                        if (*tx)["Amount"] != (*tx)["DeliverMax"] </span><span class="cov0" title="0">{
                                return errors.New("payment transaction: Amount and DeliverMax fields must be identical when both are provided")
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Sets a transaction's flags to its numeric representation.
// TODO: Add flag support for AMMDeposit, AMMWithdraw,
// NFTTOkenCreateOffer, NFTokenMint, OfferCreate, XChainModifyBridge (not supported).
func (c *WebsocketClient) setTransactionFlags(tx *transaction.FlatTransaction) error <span class="cov8" title="1">{
        flags, ok := (*tx)["Flags"].(uint32)
        if !ok &amp;&amp; flags &gt; 0 </span><span class="cov0" title="0">{
                (*tx)["Flags"] = int(0)
                return nil
        }</span>

        <span class="cov8" title="1">_, ok = (*tx)["TransactionType"].(string)
        if !ok </span><span class="cov8" title="1">{
                return errors.New("transaction type is missing in transaction")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file185" style="display: none">package websocket
=======
		<pre class="file" id="file181" style="display: none">package websocket
>>>>>>> v1.x.x

type WebsocketClientConfig struct {
        // Connection config
        host string

        // Fee config
        feeCushion float32
        maxFeeXRP  float32

        // Faucet config
        faucetProvider FaucetProvider
}

func NewWebsocketClientConfig() *WebsocketClientConfig <span class="cov0" title="0">{
        return &amp;WebsocketClientConfig{
                host:       "localhost",
                feeCushion: DEFAULT_FEE_CUSHION,
                maxFeeXRP:  DEFAULT_MAX_FEE_XRP,
        }
}</span>

// WithHost sets the host of the websocket client.
// Default: "localhost"
func (wc WebsocketClientConfig) WithHost(host string) WebsocketClientConfig <span class="cov0" title="0">{
        wc.host = host
        return wc
}</span>

// WithFeeCushion sets the fee cushion of the websocket client.
// Default: 1.2
func (wc WebsocketClientConfig) WithFeeCushion(feeCushion float32) WebsocketClientConfig <span class="cov0" title="0">{
        wc.feeCushion = feeCushion
        return wc
}</span>

// WithMaxFeeXRP sets the maximum fee in XRP that the websocket client will use.
// Default: 2
func (wc WebsocketClientConfig) WithMaxFeeXRP(maxFeeXrp float32) WebsocketClientConfig <span class="cov0" title="0">{
        wc.maxFeeXRP = maxFeeXrp
        return wc
}</span>

// WithFaucetProvider sets the faucet provider of the websocket client.
// Default: faucet.NewLocalFaucetProvider()
func (wc WebsocketClientConfig) WithFaucetProvider(fp FaucetProvider) WebsocketClientConfig <span class="cov0" title="0">{
        wc.faucetProvider = fp
        return wc
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file186" style="display: none">package websocket
=======
		<pre class="file" id="file182" style="display: none">package websocket
>>>>>>> v1.x.x

import (
        "github.com/Peersyst/xrpl-go/xrpl/currency"
        "github.com/Peersyst/xrpl-go/xrpl/queries/account"
        "github.com/Peersyst/xrpl-go/xrpl/queries/common"
        "github.com/Peersyst/xrpl-go/xrpl/queries/ledger"
        "github.com/Peersyst/xrpl-go/xrpl/queries/server"
        "github.com/Peersyst/xrpl-go/xrpl/transaction/types"
)

// GetAccountInfo retrieves information about an account on the XRP Ledger.
// It takes an AccountInfoRequest as input and returns an AccountInfoResponse,
// along with the raw XRPL response and any error encountered.
func (c *WebsocketClient) GetAccountInfo(req *account.AccountInfoRequest) (*account.AccountInfoResponse, error) <span class="cov8" title="1">{
        res, err := c.sendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var air account.AccountInfoResponse
        err = res.GetResult(&amp;air)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;air, nil</span>
}

// GetAccountObjects retrieves a list of objects owned by an account on the XRP Ledger.
// It takes an AccountObjectsRequest as input and returns an AccountObjectsResponse,
// along with any error encountered.
func (c *WebsocketClient) GetAccountObjects(req *account.AccountObjectsRequest) (*account.AccountObjectsResponse, error) <span class="cov8" title="1">{
        res, err := c.sendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var acr account.AccountObjectsResponse
        err = res.GetResult(&amp;acr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;acr, nil</span>
}

// GetXrpBalance retrieves the XRP balance of a given account address.
// It returns the balance as a string in XRP (not drops) and any error encountered.
func (c *WebsocketClient) GetXrpBalance(address string) (string, error) <span class="cov8" title="1">{
        res, err := c.GetAccountInfo(&amp;account.AccountInfoRequest{
                Account: types.Address(address),
        })
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">xrpBalance, err := currency.DropsToXrp(res.AccountData.Balance.String())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return xrpBalance, nil</span>
}

// GetAccountLines retrieves the lines associated with an account on the XRP Ledger.
// It takes an AccountLinesRequest as input and returns an AccountLinesResponse,
// along with any error encountered.
func (c *WebsocketClient) GetAccountLines(req *account.AccountLinesRequest) (*account.AccountLinesResponse, error) <span class="cov8" title="1">{
        res, err := c.sendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var acr account.AccountLinesResponse
        err = res.GetResult(&amp;acr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;acr, nil</span>
}

// Returns the index of the most recently validated ledger.
func (c *WebsocketClient) GetLedgerIndex() (common.LedgerIndex, error) <span class="cov8" title="1">{
        res, err := c.sendRequest(&amp;ledger.LedgerRequest{
                LedgerIndex: common.LedgerTitle("validated"),
        })
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">var lr ledger.LedgerResponse
        err = res.GetResult(&amp;lr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return lr.LedgerIndex, err</span>
}

// GetServerInfo retrieves information about the server.
// It takes a ServerInfoRequest as input and returns a ServerInfoResponse,
// along with any error encountered.
func (c *WebsocketClient) GetServerInfo(req *server.ServerInfoRequest) (*server.ServerInfoResponse, error) <span class="cov8" title="1">{
        res, err := c.sendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var sir server.ServerInfoResponse
        err = res.GetResult(&amp;sir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;sir, err</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file187" style="display: none">package websocket
=======
		<pre class="file" id="file183" style="display: none">package websocket
>>>>>>> v1.x.x

import (
        "fmt"

        "github.com/mitchellh/mapstructure"
)

type WebsocketXRPLResponse interface {
        GetResult(v any) error
}

type XRPLResponseWarning struct {
        Id      int    `json:"id"`
        Message string `json:"message"`
        Details any    `json:"details,omitempty"`
}

type ErrorWebsocketClientXrplResponse struct {
        Type    string
        Request map[string]any
}

func (e *ErrorWebsocketClientXrplResponse) Error() string <span class="cov8" title="1">{
        return e.Type
}</span>

type WebSocketClientXrplResponse struct {
        ID        int                   `json:"id"`
        Status    string                `json:"status"`
        Type      string                `json:"type"`
        Error     string                `json:"error,omitempty"`
        Result    map[string]any        `json:"result,omitempty"`
        Value     map[string]any        `json:"value,omitempty"`
        Warning   string                `json:"warning,omitempty"`
        Warnings  []XRPLResponseWarning `json:"warnings,omitempty"`
        Forwarded bool                  `json:"forwarded,omitempty"`
}

func (r *WebSocketClientXrplResponse) GetResult(v any) error <span class="cov8" title="1">{
        dec, err := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{TagName: "json", Result: &amp;v, DecodeHook: mapstructure.TextUnmarshallerHookFunc()})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = dec.Decode(r.Result)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("aqui", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *WebSocketClientXrplResponse) CheckError() error <span class="cov8" title="1">{
        if r.Error != "" </span><span class="cov8" title="1">{
                return &amp;ErrorWebsocketClientXrplResponse{
                        Type:    r.Error,
                        Request: r.Value,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
<<<<<<< HEAD
=======
		<pre class="file" id="file184" style="display: none">package testutil

import (
        "log"
        "net/http"
        "net/http/httptest"
        "net/url"

        "github.com/gorilla/websocket"
)

type MockWebSocketServer struct {
        Msgs []map[string]any
}

type connFn func(*websocket.Conn)

func (ms *MockWebSocketServer) TestWebSocketServer(writeFunc connFn) *httptest.Server <span class="cov8" title="1">{
        var upgrader = websocket.Upgrader{}

        s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                upgrader.CheckOrigin = func(r *http.Request) bool </span><span class="cov8" title="1">{ return true }</span>
                <span class="cov8" title="1">c, err := upgrader.Upgrade(w, r, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Upgrade:", err)
                }</span>

                <span class="cov8" title="1">writeFunc(c)</span>
        }))

        <span class="cov8" title="1">return s</span>
}

func ConvertHttpToWS(u string) (string, error) <span class="cov8" title="1">{
        s, err := url.Parse(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">switch s.Scheme </span>{
        case "http":<span class="cov8" title="1">
                s.Scheme = "ws"</span>
        case "https":<span class="cov0" title="0">
                s.Scheme = "wss"</span>
        }

        <span class="cov8" title="1">return s.String(), nil</span>
}
</pre>
		
>>>>>>> v1.x.x
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
